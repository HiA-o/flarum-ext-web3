var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from4, except, desc) => {
  if (from4 && typeof from4 === "object" || typeof from4 === "function") {
    for (let key of __getOwnPropNames(from4))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from4[key], enumerable: !(desc = __getOwnPropDesc(from4, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@esbuild-plugins/node-globals-polyfill/_virtual-process-polyfill_.js
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e5) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e6) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e5) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e6) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout2 = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout2);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      args[i5 - 1] = arguments[i5];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance, performanceNow, startTime, process, defines;
var init_virtual_process_polyfill = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/_virtual-process-polyfill_.js"() {
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener = noop;
    once = noop;
    off = noop;
    removeListener = noop;
    removeAllListeners = noop;
    emit = noop;
    performance = globalThis.performance || {};
    performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    process = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    defines = {};
    Object.keys(defines).forEach((key) => {
      const segs = key.split(".");
      let target = process;
      for (let i5 = 0; i5 < segs.length; i5++) {
        const seg = segs[i5];
        if (i5 === segs.length - 1) {
          target[seg] = defines[key];
        } else {
          target = target[seg] || (target[seg] = {});
        }
      }
    });
  }
});

// node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i5 = 0, len = code.length; i5 < len; ++i5) {
    lookup[i5] = code[i5];
    revLookup[code.charCodeAt(i5)] = i5;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function base64toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i5, j5, l5, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l5 = placeHolders > 0 ? len - 4 : len;
  var L4 = 0;
  for (i5 = 0, j5 = 0; i5 < l5; i5 += 4, j5 += 3) {
    tmp = revLookup[b64.charCodeAt(i5)] << 18 | revLookup[b64.charCodeAt(i5 + 1)] << 12 | revLookup[b64.charCodeAt(i5 + 2)] << 6 | revLookup[b64.charCodeAt(i5 + 3)];
    arr[L4++] = tmp >> 16 & 255;
    arr[L4++] = tmp >> 8 & 255;
    arr[L4++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i5)] << 2 | revLookup[b64.charCodeAt(i5 + 1)] >> 4;
    arr[L4++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i5)] << 10 | revLookup[b64.charCodeAt(i5 + 1)] << 4 | revLookup[b64.charCodeAt(i5 + 2)] >> 2;
    arr[L4++] = tmp >> 8 & 255;
    arr[L4++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i5 = start; i5 < end; i5 += 3) {
    tmp = (uint8[i5] << 16) + (uint8[i5 + 1] << 8) + uint8[i5 + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function base64fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i5 = 0, len2 = len - extraBytes; i5 < len2; i5 += maxChunkLength) {
    parts.push(
      encodeChunk(
        uint8,
        i5,
        i5 + maxChunkLength > len2 ? len2 : i5 + maxChunkLength
      )
    );
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill3, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill3, encoding) : createBuffer(that, size).fill(fill3);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i5 = 0; i5 < size; ++i5) {
      that[i5] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i5 = 0; i5 < length; i5 += 1) {
    that[i5] = array[i5] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError(
    "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
  );
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError(
      "Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes"
    );
  }
  return length | 0;
}
function internalIsBuffer(b4) {
  return !!(b4 != null && b4._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b4, n3, m5) {
  var i5 = b4[n3];
  b4[n3] = b4[m5];
  b4[m5] = i5;
}
function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
  if (buffer2.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer2.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer2.length + byteOffset;
  if (byteOffset >= buffer2.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer2.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(
          buffer2,
          val,
          byteOffset
        );
      } else {
        return Uint8Array.prototype.lastIndexOf.call(
          buffer2,
          val,
          byteOffset
        );
      }
    }
    return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i6) {
    if (indexSize === 1) {
      return buf[i6];
    } else {
      return buf.readUInt16BE(i6 * indexSize);
    }
  }
  var i5;
  if (dir) {
    var foundIndex = -1;
    for (i5 = byteOffset; i5 < arrLength; i5++) {
      if (read2(arr, i5) === read2(val, foundIndex === -1 ? 0 : i5 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i5;
        if (i5 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i5 -= i5 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i5 = byteOffset; i5 >= 0; i5--) {
      var found = true;
      for (var j5 = 0; j5 < valLength; j5++) {
        if (read2(arr, i5 + j5) !== read2(val, j5)) {
          found = false;
          break;
        }
      }
      if (found)
        return i5;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i5 = 0; i5 < length; ++i5) {
    var parsed = parseInt(string.substr(i5 * 2, 2), 16);
    if (isNaN(parsed))
      return i5;
    buf[offset + i5] = parsed;
  }
  return i5;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(
    utf8ToBytes(string, buf.length - offset),
    buf,
    offset,
    length
  );
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(
    utf16leToBytes(string, buf.length - offset),
    buf,
    offset,
    length
  );
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64fromByteArray(buf);
  } else {
    return base64fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i5 = start;
  while (i5 < end) {
    var firstByte = buf[i5];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i5 + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i5 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i5 + 1];
          thirdByte = buf[i5 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i5 + 1];
          thirdByte = buf[i5 + 2];
          fourthByte = buf[i5 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i5 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i5 = 0;
  while (i5 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i5, i5 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i5 = start; i5 < end; ++i5) {
    ret += String.fromCharCode(buf[i5] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i5 = start; i5 < end; ++i5) {
    ret += String.fromCharCode(buf[i5]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i5 = start; i5 < end; ++i5) {
    out += toHex(buf[i5]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i5 = 0; i5 < bytes.length; i5 += 2) {
    res += String.fromCharCode(bytes[i5] + bytes[i5 + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max2, min2) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max2 || value < min2)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i5 = 0, j5 = Math.min(buf.length - offset, 2); i5 < j5; ++i5) {
    buf[offset + i5] = (value & 255 << 8 * (littleEndian ? i5 : 1 - i5)) >>> (littleEndian ? i5 : 1 - i5) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i5 = 0, j5 = Math.min(buf.length - offset, 4); i5 < j5; ++i5) {
    buf[offset + i5] = value >>> (littleEndian ? i5 : 3 - i5) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max2, min2) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      4,
      34028234663852886e22,
      -34028234663852886e22
    );
  }
  ieee754write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      8,
      17976931348623157e292,
      -17976931348623157e292
    );
  }
  ieee754write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n3) {
  if (n3 < 16)
    return "0" + n3.toString(16);
  return n3.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i5 = 0; i5 < length; ++i5) {
    codePoint = string.charCodeAt(i5);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i5 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i5 = 0; i5 < str.length; ++i5) {
    byteArray.push(str.charCodeAt(i5) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c5, hi, lo;
  var byteArray = [];
  for (var i5 = 0; i5 < str.length; ++i5) {
    if ((units -= 2) < 0)
      break;
    c5 = str.charCodeAt(i5);
    hi = c5 >> 8;
    lo = c5 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i5 = 0; i5 < length; ++i5) {
    if (i5 + offset >= dst.length || i5 >= src.length)
      break;
    dst[i5 + offset] = src[i5];
  }
  return i5;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
function ieee754read(buffer2, offset, isLE, mLen, nBytes) {
  var e5, m5;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i5 = isLE ? nBytes - 1 : 0;
  var d5 = isLE ? -1 : 1;
  var s5 = buffer2[offset + i5];
  i5 += d5;
  e5 = s5 & (1 << -nBits) - 1;
  s5 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e5 = e5 * 256 + buffer2[offset + i5], i5 += d5, nBits -= 8) {
  }
  m5 = e5 & (1 << -nBits) - 1;
  e5 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m5 = m5 * 256 + buffer2[offset + i5], i5 += d5, nBits -= 8) {
  }
  if (e5 === 0) {
    e5 = 1 - eBias;
  } else if (e5 === eMax) {
    return m5 ? NaN : (s5 ? -1 : 1) * Infinity;
  } else {
    m5 = m5 + Math.pow(2, mLen);
    e5 = e5 - eBias;
  }
  return (s5 ? -1 : 1) * m5 * Math.pow(2, e5 - mLen);
}
function ieee754write(buffer2, value, offset, isLE, mLen, nBytes) {
  var e5, m5, c5;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i5 = isLE ? 0 : nBytes - 1;
  var d5 = isLE ? 1 : -1;
  var s5 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m5 = isNaN(value) ? 1 : 0;
    e5 = eMax;
  } else {
    e5 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c5 = Math.pow(2, -e5)) < 1) {
      e5--;
      c5 *= 2;
    }
    if (e5 + eBias >= 1) {
      value += rt / c5;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c5 >= 2) {
      e5++;
      c5 /= 2;
    }
    if (e5 + eBias >= eMax) {
      m5 = 0;
      e5 = eMax;
    } else if (e5 + eBias >= 1) {
      m5 = (value * c5 - 1) * Math.pow(2, mLen);
      e5 = e5 + eBias;
    } else {
      m5 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e5 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i5] = m5 & 255, i5 += d5, m5 /= 256, mLen -= 8) {
  }
  e5 = e5 << mLen | m5;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i5] = e5 & 255, i5 += d5, e5 /= 256, eLen -= 8) {
  }
  buffer2[offset + i5 - d5] |= s5 * 128;
}
var lookup, revLookup, Arr, inited, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_Buffer = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    Buffer2.kMaxLength = kMaxLength();
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
      }
    }
    Buffer2.alloc = function(size, fill3, encoding) {
      return alloc(null, size, fill3, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a5, b4) {
      if (!internalIsBuffer(a5) || !internalIsBuffer(b4)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a5 === b4)
        return 0;
      var x5 = a5.length;
      var y5 = b4.length;
      for (var i5 = 0, len = Math.min(x5, y5); i5 < len; ++i5) {
        if (a5[i5] !== b4[i5]) {
          x5 = a5[i5];
          y5 = b4[i5];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i5;
      if (length === void 0) {
        length = 0;
        for (i5 = 0; i5 < list.length; ++i5) {
          length += list[i5].length;
        }
      }
      var buffer2 = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        var buf = list[i5];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer2, pos);
        pos += buf.length;
      }
      return buffer2;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 2) {
        swap(this, i5, i5 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 4) {
        swap(this, i5, i5 + 3);
        swap(this, i5 + 1, i5 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 8) {
        swap(this, i5, i5 + 7);
        swap(this, i5 + 1, i5 + 6);
        swap(this, i5 + 2, i5 + 5);
        swap(this, i5 + 3, i5 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b4) {
      if (!internalIsBuffer(b4))
        throw new TypeError("Argument must be a Buffer");
      if (this === b4)
        return true;
      return Buffer2.compare(this, b4) === 0;
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x5 = thisEnd - thisStart;
      var y5 = end - start;
      var len = Math.min(x5, y5);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i5 = 0; i5 < len; ++i5) {
        if (thisCopy[i5] !== targetCopy[i5]) {
          x5 = thisCopy[i5];
          y5 = targetCopy[i5];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i5 = 0; i5 < sliceLen; ++i5) {
          newBuf[i5] = this[i5 + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i5 = 0;
      while (++i5 < byteLength3 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      var val = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i5 = 0;
      while (++i5 < byteLength3 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var i5 = byteLength3;
      var mul = 1;
      var val = this[offset + --i5];
      while (i5 > 0 && (mul *= 256)) {
        val += this[offset + --i5] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i5 = 0;
      this[offset] = value & 255;
      while (++i5 < byteLength3 && (mul *= 256)) {
        this[offset + i5] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i5 = byteLength3 - 1;
      var mul = 1;
      this[offset + i5] = value & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        this[offset + i5] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i5 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i5 < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i5 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i5] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i5 = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i5] = value & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i5 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i5] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i5;
      if (this === target && start < targetStart && targetStart < end) {
        for (i5 = len - 1; i5 >= 0; --i5) {
          target[i5 + targetStart] = this[i5 + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i5 = 0; i5 < len; ++i5) {
          target[i5 + targetStart] = this[i5 + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js
var init_buffer = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js"() {
    init_Buffer();
  }
});

// node-modules-polyfills:buffer
var buffer_exports = {};
__export(buffer_exports, {
  Buffer: () => Buffer3,
  INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
  SlowBuffer: () => SlowBuffer,
  isBuffer: () => isBuffer2,
  kMaxLength: () => _kMaxLength
});
function init2() {
  inited2 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i5 = 0, len = code.length; i5 < len; ++i5) {
    lookup2[i5] = code[i5];
    revLookup2[code.charCodeAt(i5)] = i5;
  }
  revLookup2["-".charCodeAt(0)] = 62;
  revLookup2["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited2) {
    init2();
  }
  var i5, j5, l5, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr2(len * 3 / 4 - placeHolders);
  l5 = placeHolders > 0 ? len - 4 : len;
  var L4 = 0;
  for (i5 = 0, j5 = 0; i5 < l5; i5 += 4, j5 += 3) {
    tmp = revLookup2[b64.charCodeAt(i5)] << 18 | revLookup2[b64.charCodeAt(i5 + 1)] << 12 | revLookup2[b64.charCodeAt(i5 + 2)] << 6 | revLookup2[b64.charCodeAt(i5 + 3)];
    arr[L4++] = tmp >> 16 & 255;
    arr[L4++] = tmp >> 8 & 255;
    arr[L4++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup2[b64.charCodeAt(i5)] << 2 | revLookup2[b64.charCodeAt(i5 + 1)] >> 4;
    arr[L4++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup2[b64.charCodeAt(i5)] << 10 | revLookup2[b64.charCodeAt(i5 + 1)] << 4 | revLookup2[b64.charCodeAt(i5 + 2)] >> 2;
    arr[L4++] = tmp >> 8 & 255;
    arr[L4++] = tmp & 255;
  }
  return arr;
}
function tripletToBase642(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
}
function encodeChunk2(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i5 = start; i5 < end; i5 += 3) {
    tmp = (uint8[i5] << 16) + (uint8[i5 + 1] << 8) + uint8[i5 + 2];
    output.push(tripletToBase642(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited2) {
    init2();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i5 = 0, len2 = len - extraBytes; i5 < len2; i5 += maxChunkLength) {
    parts.push(encodeChunk2(uint8, i5, i5 + maxChunkLength > len2 ? len2 : i5 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup2[tmp >> 2];
    output += lookup2[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup2[tmp >> 10];
    output += lookup2[tmp >> 4 & 63];
    output += lookup2[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer2, offset, isLE, mLen, nBytes) {
  var e5, m5;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i5 = isLE ? nBytes - 1 : 0;
  var d5 = isLE ? -1 : 1;
  var s5 = buffer2[offset + i5];
  i5 += d5;
  e5 = s5 & (1 << -nBits) - 1;
  s5 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e5 = e5 * 256 + buffer2[offset + i5], i5 += d5, nBits -= 8) {
  }
  m5 = e5 & (1 << -nBits) - 1;
  e5 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m5 = m5 * 256 + buffer2[offset + i5], i5 += d5, nBits -= 8) {
  }
  if (e5 === 0) {
    e5 = 1 - eBias;
  } else if (e5 === eMax) {
    return m5 ? NaN : (s5 ? -1 : 1) * Infinity;
  } else {
    m5 = m5 + Math.pow(2, mLen);
    e5 = e5 - eBias;
  }
  return (s5 ? -1 : 1) * m5 * Math.pow(2, e5 - mLen);
}
function write2(buffer2, value, offset, isLE, mLen, nBytes) {
  var e5, m5, c5;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i5 = isLE ? 0 : nBytes - 1;
  var d5 = isLE ? 1 : -1;
  var s5 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m5 = isNaN(value) ? 1 : 0;
    e5 = eMax;
  } else {
    e5 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c5 = Math.pow(2, -e5)) < 1) {
      e5--;
      c5 *= 2;
    }
    if (e5 + eBias >= 1) {
      value += rt / c5;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c5 >= 2) {
      e5++;
      c5 /= 2;
    }
    if (e5 + eBias >= eMax) {
      m5 = 0;
      e5 = eMax;
    } else if (e5 + eBias >= 1) {
      m5 = (value * c5 - 1) * Math.pow(2, mLen);
      e5 = e5 + eBias;
    } else {
      m5 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e5 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i5] = m5 & 255, i5 += d5, m5 /= 256, mLen -= 8) {
  }
  e5 = e5 << mLen | m5;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i5] = e5 & 255, i5 += d5, e5 /= 256, eLen -= 8) {
  }
  buffer2[offset + i5 - d5] |= s5 * 128;
}
function kMaxLength2() {
  return Buffer3.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer2(that, length) {
  if (kMaxLength2() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer3.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer3.prototype;
  } else {
    if (that === null) {
      that = new Buffer3(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer3(arg, encodingOrOffset, length) {
  if (!Buffer3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer3)) {
    return new Buffer3(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe2(this, arg);
  }
  return from2(this, arg, encodingOrOffset, length);
}
function from2(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer2(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString2(that, value, encodingOrOffset);
  }
  return fromObject2(that, value);
}
function assertSize2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc2(that, size, fill3, encoding) {
  assertSize2(size);
  if (size <= 0) {
    return createBuffer2(that, size);
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer2(that, size).fill(fill3, encoding) : createBuffer2(that, size).fill(fill3);
  }
  return createBuffer2(that, size);
}
function allocUnsafe2(that, size) {
  assertSize2(size);
  that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
  if (!Buffer3.TYPED_ARRAY_SUPPORT) {
    for (var i5 = 0; i5 < size; ++i5) {
      that[i5] = 0;
    }
  }
  return that;
}
function fromString2(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer3.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength2(string, encoding) | 0;
  that = createBuffer2(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike2(that, array) {
  var length = array.length < 0 ? 0 : checked2(array.length) | 0;
  that = createBuffer2(that, length);
  for (var i5 = 0; i5 < length; i5 += 1) {
    that[i5] = array[i5] & 255;
  }
  return that;
}
function fromArrayBuffer2(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer3.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer3.prototype;
  } else {
    that = fromArrayLike2(that, array);
  }
  return that;
}
function fromObject2(that, obj) {
  if (internalIsBuffer2(obj)) {
    var len = checked2(obj.length) | 0;
    that = createBuffer2(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan2(obj.length)) {
        return createBuffer2(that, 0);
      }
      return fromArrayLike2(that, obj);
    }
    if (obj.type === "Buffer" && isArray(obj.data)) {
      return fromArrayLike2(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked2(length) {
  if (length >= kMaxLength2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    length = 0;
  }
  return Buffer3.alloc(+length);
}
function internalIsBuffer2(b4) {
  return !!(b4 != null && b4._isBuffer);
}
function byteLength2(string, encoding) {
  if (internalIsBuffer2(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes2(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes2(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes2(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString2(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice2(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice2(this, start, end);
      case "ascii":
        return asciiSlice2(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice2(this, start, end);
      case "base64":
        return base64Slice2(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice2(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap2(b4, n3, m5) {
  var i5 = b4[n3];
  b4[n3] = b4[m5];
  b4[m5] = i5;
}
function bidirectionalIndexOf2(buffer2, val, byteOffset, encoding, dir) {
  if (buffer2.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer2.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer2.length + byteOffset;
  if (byteOffset >= buffer2.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer2.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer3.from(val, encoding);
  }
  if (internalIsBuffer2(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf2(buffer2, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer3.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
      }
    }
    return arrayIndexOf2(buffer2, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i6) {
    if (indexSize === 1) {
      return buf[i6];
    } else {
      return buf.readUInt16BE(i6 * indexSize);
    }
  }
  var i5;
  if (dir) {
    var foundIndex = -1;
    for (i5 = byteOffset; i5 < arrLength; i5++) {
      if (read2(arr, i5) === read2(val, foundIndex === -1 ? 0 : i5 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i5;
        if (i5 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i5 -= i5 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i5 = byteOffset; i5 >= 0; i5--) {
      var found = true;
      for (var j5 = 0; j5 < valLength; j5++) {
        if (read2(arr, i5 + j5) !== read2(val, j5)) {
          found = false;
          break;
        }
      }
      if (found)
        return i5;
    }
  }
  return -1;
}
function hexWrite2(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i5 = 0; i5 < length; ++i5) {
    var parsed = parseInt(string.substr(i5 * 2, 2), 16);
    if (isNaN(parsed))
      return i5;
    buf[offset + i5] = parsed;
  }
  return i5;
}
function utf8Write2(buf, string, offset, length) {
  return blitBuffer2(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
}
function asciiWrite2(buf, string, offset, length) {
  return blitBuffer2(asciiToBytes2(string), buf, offset, length);
}
function latin1Write2(buf, string, offset, length) {
  return asciiWrite2(buf, string, offset, length);
}
function base64Write2(buf, string, offset, length) {
  return blitBuffer2(base64ToBytes2(string), buf, offset, length);
}
function ucs2Write2(buf, string, offset, length) {
  return blitBuffer2(utf16leToBytes2(string, buf.length - offset), buf, offset, length);
}
function base64Slice2(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice2(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i5 = start;
  while (i5 < end) {
    var firstByte = buf[i5];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i5 + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i5 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i5 + 1];
          thirdByte = buf[i5 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i5 + 1];
          thirdByte = buf[i5 + 2];
          fourthByte = buf[i5 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i5 += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
function decodeCodePointsArray2(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i5 = 0;
  while (i5 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i5, i5 += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
function asciiSlice2(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i5 = start; i5 < end; ++i5) {
    ret += String.fromCharCode(buf[i5] & 127);
  }
  return ret;
}
function latin1Slice2(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i5 = start; i5 < end; ++i5) {
    ret += String.fromCharCode(buf[i5]);
  }
  return ret;
}
function hexSlice2(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i5 = start; i5 < end; ++i5) {
    out += toHex2(buf[i5]);
  }
  return out;
}
function utf16leSlice2(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i5 = 0; i5 < bytes.length; i5 += 2) {
    res += String.fromCharCode(bytes[i5] + bytes[i5 + 1] * 256);
  }
  return res;
}
function checkOffset2(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt2(buf, value, offset, ext, max2, min2) {
  if (!internalIsBuffer2(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max2 || value < min2)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt162(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i5 = 0, j5 = Math.min(buf.length - offset, 2); i5 < j5; ++i5) {
    buf[offset + i5] = (value & 255 << 8 * (littleEndian ? i5 : 1 - i5)) >>> (littleEndian ? i5 : 1 - i5) * 8;
  }
}
function objectWriteUInt322(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i5 = 0, j5 = Math.min(buf.length - offset, 4); i5 < j5; ++i5) {
    buf[offset + i5] = value >>> (littleEndian ? i5 : 3 - i5) * 8 & 255;
  }
}
function checkIEEE7542(buf, value, offset, ext, max2, min2) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 4);
  }
  write2(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 8);
  }
  write2(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean2(str) {
  str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim2(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex2(n3) {
  if (n3 < 16)
    return "0" + n3.toString(16);
  return n3.toString(16);
}
function utf8ToBytes2(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i5 = 0; i5 < length; ++i5) {
    codePoint = string.charCodeAt(i5);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i5 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes2(str) {
  var byteArray = [];
  for (var i5 = 0; i5 < str.length; ++i5) {
    byteArray.push(str.charCodeAt(i5) & 255);
  }
  return byteArray;
}
function utf16leToBytes2(str, units) {
  var c5, hi, lo;
  var byteArray = [];
  for (var i5 = 0; i5 < str.length; ++i5) {
    if ((units -= 2) < 0)
      break;
    c5 = str.charCodeAt(i5);
    hi = c5 >> 8;
    lo = c5 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes2(str) {
  return toByteArray(base64clean2(str));
}
function blitBuffer2(src, dst, offset, length) {
  for (var i5 = 0; i5 < length; ++i5) {
    if (i5 + offset >= dst.length || i5 >= src.length)
      break;
    dst[i5 + offset] = src[i5];
  }
  return i5;
}
function isnan2(val) {
  return val !== val;
}
function isBuffer2(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
}
function isFastBuffer2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
}
var lookup2, revLookup2, Arr2, inited2, toString2, isArray, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH2, INVALID_BASE64_RE2;
var init_buffer2 = __esm({
  "node-modules-polyfills:buffer"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    lookup2 = [];
    revLookup2 = [];
    Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited2 = false;
    toString2 = {}.toString;
    isArray = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer3.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength2();
    Buffer3.poolSize = 8192;
    Buffer3._augment = function(arr) {
      arr.__proto__ = Buffer3.prototype;
      return arr;
    };
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from2(null, value, encodingOrOffset, length);
    };
    if (Buffer3.TYPED_ARRAY_SUPPORT) {
      Buffer3.prototype.__proto__ = Uint8Array.prototype;
      Buffer3.__proto__ = Uint8Array;
    }
    Buffer3.alloc = function(size, fill3, encoding) {
      return alloc2(null, size, fill3, encoding);
    };
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe2(null, size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe2(null, size);
    };
    Buffer3.isBuffer = isBuffer2;
    Buffer3.compare = function compare3(a5, b4) {
      if (!internalIsBuffer2(a5) || !internalIsBuffer2(b4)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a5 === b4)
        return 0;
      var x5 = a5.length;
      var y5 = b4.length;
      for (var i5 = 0, len = Math.min(x5, y5); i5 < len; ++i5) {
        if (a5[i5] !== b4[i5]) {
          x5 = a5[i5];
          y5 = b4[i5];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding2(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat2(list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      var i5;
      if (length === void 0) {
        length = 0;
        for (i5 = 0; i5 < list.length; ++i5) {
          length += list[i5].length;
        }
      }
      var buffer2 = Buffer3.allocUnsafe(length);
      var pos = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        var buf = list[i5];
        if (!internalIsBuffer2(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer2, pos);
        pos += buf.length;
      }
      return buffer2;
    };
    Buffer3.byteLength = byteLength2;
    Buffer3.prototype._isBuffer = true;
    Buffer3.prototype.swap16 = function swap162() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 2) {
        swap2(this, i5, i5 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap322() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 4) {
        swap2(this, i5, i5 + 3);
        swap2(this, i5 + 1, i5 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap642() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 8) {
        swap2(this, i5, i5 + 7);
        swap2(this, i5 + 1, i5 + 6);
        swap2(this, i5 + 2, i5 + 5);
        swap2(this, i5 + 3, i5 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString3() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length);
      return slowToString2.apply(this, arguments);
    };
    Buffer3.prototype.equals = function equals2(b4) {
      if (!internalIsBuffer2(b4))
        throw new TypeError("Argument must be a Buffer");
      if (this === b4)
        return true;
      return Buffer3.compare(this, b4) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      var str = "";
      var max2 = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
        if (this.length > max2)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer3.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer2(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x5 = thisEnd - thisStart;
      var y5 = end - start;
      var len = Math.min(x5, y5);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i5 = 0; i5 < len; ++i5) {
        if (thisCopy[i5] !== targetCopy[i5]) {
          x5 = thisCopy[i5];
          y5 = targetCopy[i5];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    Buffer3.prototype.includes = function includes2(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
    };
    Buffer3.prototype.write = function write3(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite2(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write2(this, string, offset, length);
          case "ascii":
            return asciiWrite2(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write2(this, string, offset, length);
          case "base64":
            return base64Write2(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write2(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH2 = 4096;
    Buffer3.prototype.slice = function slice2(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer3.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer3(sliceLen, void 0);
        for (var i5 = 0; i5 < sliceLen; ++i5) {
          newBuf[i5] = this[i5 + start];
        }
      }
      return newBuf;
    };
    Buffer3.prototype.readUIntLE = function readUIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i5 = 0;
      while (++i5 < byteLength3 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUIntBE = function readUIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        checkOffset2(offset, byteLength3, this.length);
      }
      var val = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUInt8 = function readUInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUInt16LE = function readUInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUInt16BE = function readUInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUInt32LE = function readUInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUInt32BE = function readUInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i5 = 0;
      while (++i5 < byteLength3 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var i5 = byteLength3;
      var mul = 1;
      var val = this[offset + --i5];
      while (i5 > 0 && (mul *= 256)) {
        val += this[offset + --i5] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer3.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt2(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i5 = 0;
      this[offset] = value & 255;
      while (++i5 < byteLength3 && (mul *= 256)) {
        this[offset + i5] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUIntBE = function writeUIntBE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt2(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i5 = byteLength3 - 1;
      var mul = 1;
      this[offset + i5] = value & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        this[offset + i5] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUInt8 = function writeUInt82(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 1, 255, 0);
      if (!Buffer3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUInt16LE = function writeUInt16LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt162(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeUInt16BE = function writeUInt16BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt162(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeUInt32LE = function writeUInt32LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeUInt32BE = function writeUInt32BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i5 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i5 < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i5 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i5] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i5 = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i5] = value & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i5 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i5] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeInt8 = function writeInt82(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 1, 127, -128);
      if (!Buffer3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt162(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt162(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt322(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeFloatLE = function writeFloatLE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i5;
      if (this === target && start < targetStart && targetStart < end) {
        for (i5 = len - 1; i5 >= 0; --i5) {
          target[i5 + targetStart] = this[i5 + start];
        }
      } else if (len < 1e3 || !Buffer3.TYPED_ARRAY_SUPPORT) {
        for (i5 = 0; i5 < len; ++i5) {
          target[i5 + targetStart] = this[i5 + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill2(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer3(val, encoding).toString());
        var len = bytes.length;
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node-modules-polyfills-commonjs:buffer
var require_buffer = __commonJS({
  "node-modules-polyfills-commonjs:buffer"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_buffer2(), __toCommonJS(buffer_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var buffer2 = require_buffer();
    var Buffer4 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer4(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer4.prototype);
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill3, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill3 !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill3, encoding);
        } else {
          buf.fill(fill3);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// node_modules/randombytes/browser.js
var require_browser = __commonJS({
  "node_modules/randombytes/browser.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer4 = require_safe_buffer().Buffer;
    var crypto3 = globalThis.crypto || globalThis.msCrypto;
    if (crypto3 && crypto3.getRandomValues) {
      module.exports = randomBytes2;
    } else {
      module.exports = oldBrowser;
    }
    function randomBytes2(size, cb) {
      if (size > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes = Buffer4.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto3.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto3.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    if (typeof Object.create === "function") {
      module.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node-modules-polyfills:events
var events_exports = {};
__export(events_exports, {
  EventEmitter: () => EventEmitter,
  default: () => events_default
});
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i5 = 0; i5 < len; ++i5)
      listeners2[i5].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i5 = 0; i5 < len; ++i5)
      listeners2[i5].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i5 = 0; i5 < len; ++i5)
      listeners2[i5].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i5 = 0; i5 < len; ++i5)
      listeners2[i5].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i5 = 0; i5 < len; ++i5)
      listeners2[i5].apply(self2, args);
  }
}
function _addListener(target, type2, listener, prepend) {
  var m5;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      );
      events = target._events;
    }
    existing = events[type2];
  }
  if (!existing) {
    existing = events[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m5 = $getMaxListeners(target);
      if (m5 && m5 > 0 && existing.length > m5) {
        existing.warned = true;
        var w6 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w6.name = "MaxListenersExceededWarning";
        w6.emitter = target;
        w6.type = type2;
        w6.count = existing.length;
        emitWarning(w6);
      }
    }
  }
  return target;
}
function emitWarning(e5) {
  typeof console.warn === "function" ? console.warn(e5) : console.log(e5);
}
function _onceWrap(target, type2, listener) {
  var fired = false;
  function g5() {
    target.removeListener(type2, g5);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g5.listener = listener;
  return g5;
}
function listenerCount(type2) {
  var events = this._events;
  if (events) {
    var evlistener = events[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i5 = index, k5 = i5 + 1, n3 = list.length; k5 < n3; i5 += 1, k5 += 1)
    list[i5] = list[k5];
  list.pop();
}
function arrayClone(arr, i5) {
  var copy3 = new Array(i5);
  while (i5--)
    copy3[i5] = arr[i5];
  return copy3;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i5 = 0; i5 < ret.length; ++i5) {
    ret[i5] = arr[i5].listener || arr[i5];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n3) {
      if (typeof n3 !== "number" || n3 < 0 || isNaN(n3))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n3;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit2(type2) {
      var er, handler, len, args, i5, events, domain3;
      var needDomainExit = false;
      var doError = type2 === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain3 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain3) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain3;
          er.domainThrown = false;
          domain3.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type2];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i5 = 1; i5 < len; i5++)
            args[i5 - 1] = arguments[i5];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain3.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener2(type2, listener) {
      return _addListener(this, type2, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
      return _addListener(this, type2, listener, true);
    };
    EventEmitter.prototype.once = function once2(type2, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener2(type2, listener) {
      var list, events, position, i5, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type2];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type2];
          if (events.removeListener)
            this.emit("removeListener", type2, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i5 = list.length; i5-- > 0; ) {
          if (list[i5] === listener || list[i5].listener && list[i5].listener === listener) {
            originalListener = list[i5].listener;
            position = i5;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type2];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type2, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type2) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type2]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type2];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i5 = 0, key; i5 < keys2.length; ++i5) {
          key = keys2[i5];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type2];
      if (typeof listeners2 === "function") {
        this.removeListener(type2, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type2, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type2) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type2];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type2) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type2);
      } else {
        return listenerCount.call(emitter, type2);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills-commonjs:events
var require_events = __commonJS({
  "node-modules-polyfills-commonjs:events"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_events(), __toCommonJS(events_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_events().EventEmitter;
  }
});

// node-modules-polyfills:process
function defaultSetTimout2() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout2() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout2(fun) {
  if (cachedSetTimeout2 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
    cachedSetTimeout2 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout2(fun, 0);
  } catch (e5) {
    try {
      return cachedSetTimeout2.call(null, fun, 0);
    } catch (e6) {
      return cachedSetTimeout2.call(this, fun, 0);
    }
  }
}
function runClearTimeout2(marker) {
  if (cachedClearTimeout2 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
    cachedClearTimeout2 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout2(marker);
  } catch (e5) {
    try {
      return cachedClearTimeout2.call(null, marker);
    } catch (e6) {
      return cachedClearTimeout2.call(this, marker);
    }
  }
}
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2) {
    return;
  }
  draining2 = false;
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2);
  } else {
    queueIndex2 = -1;
  }
  if (queue2.length) {
    drainQueue2();
  }
}
function drainQueue2() {
  if (draining2) {
    return;
  }
  var timeout2 = runTimeout2(cleanUpNextTick2);
  draining2 = true;
  var len = queue2.length;
  while (len) {
    currentQueue2 = queue2;
    queue2 = [];
    while (++queueIndex2 < len) {
      if (currentQueue2) {
        currentQueue2[queueIndex2].run();
      }
    }
    queueIndex2 = -1;
    len = queue2.length;
  }
  currentQueue2 = null;
  draining2 = false;
  runClearTimeout2(timeout2);
}
function nextTick2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      args[i5 - 1] = arguments[i5];
    }
  }
  queue2.push(new Item2(fun, args));
  if (queue2.length === 1 && !draining2) {
    runTimeout2(drainQueue2);
  }
}
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop2() {
}
function binding2(name) {
  throw new Error("process.binding is not supported");
}
function cwd2() {
  return "/";
}
function chdir2(dir) {
  throw new Error("process.chdir is not supported");
}
function umask2() {
  return 0;
}
function hrtime2(previousTimestamp) {
  var clocktime = performanceNow2.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime2() {
  var currentTime = new Date();
  var dif = currentTime - startTime2;
  return dif / 1e3;
}
var cachedSetTimeout2, cachedClearTimeout2, queue2, draining2, currentQueue2, queueIndex2, title2, platform2, browser2, env2, argv2, version2, versions2, release2, config2, on2, addListener3, once3, off2, removeListener3, removeAllListeners3, emit3, performance2, performanceNow2, startTime2, browser$1, process_default;
var init_process = __esm({
  "node-modules-polyfills:process"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    cachedSetTimeout2 = defaultSetTimout2;
    cachedClearTimeout2 = defaultClearTimeout2;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout2 = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout2 = clearTimeout;
    }
    queue2 = [];
    draining2 = false;
    queueIndex2 = -1;
    Item2.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title2 = "browser";
    platform2 = "browser";
    browser2 = true;
    env2 = {};
    argv2 = [];
    version2 = "";
    versions2 = {};
    release2 = {};
    config2 = {};
    on2 = noop2;
    addListener3 = noop2;
    once3 = noop2;
    off2 = noop2;
    removeListener3 = noop2;
    removeAllListeners3 = noop2;
    emit3 = noop2;
    performance2 = globalThis.performance || {};
    performanceNow2 = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
      return new Date().getTime();
    };
    startTime2 = new Date();
    browser$1 = {
      nextTick: nextTick2,
      title: title2,
      browser: browser2,
      env: env2,
      argv: argv2,
      version: version2,
      versions: versions2,
      on: on2,
      addListener: addListener3,
      once: once3,
      off: off2,
      removeListener: removeListener3,
      removeAllListeners: removeAllListeners3,
      emit: emit3,
      binding: binding2,
      cwd: cwd2,
      chdir: chdir2,
      umask: umask2,
      hrtime: hrtime2,
      platform: platform2,
      release: release2,
      config: config2,
      uptime: uptime2
    };
    process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
var util_exports = {};
__export(util_exports, {
  _extend: () => _extend,
  debuglog: () => debuglog,
  default: () => util_default,
  deprecate: () => deprecate,
  format: () => format,
  inherits: () => inherits_default,
  inspect: () => inspect2,
  isArray: () => isArray2,
  isBoolean: () => isBoolean,
  isBuffer: () => isBuffer3,
  isDate: () => isDate,
  isError: () => isError,
  isFunction: () => isFunction,
  isNull: () => isNull,
  isNullOrUndefined: () => isNullOrUndefined,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPrimitive: () => isPrimitive,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isUndefined: () => isUndefined,
  log: () => log
});
function format(f5) {
  if (!isString(f5)) {
    var objects = [];
    for (var i5 = 0; i5 < arguments.length; i5++) {
      objects.push(inspect2(arguments[i5]));
    }
    return objects.join(" ");
  }
  var i5 = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f5).replace(formatRegExp, function(x6) {
    if (x6 === "%%")
      return "%";
    if (i5 >= len)
      return x6;
    switch (x6) {
      case "%s":
        return String(args[i5++]);
      case "%d":
        return Number(args[i5++]);
      case "%j":
        try {
          return JSON.stringify(args[i5++]);
        } catch (_6) {
          return "[Circular]";
        }
      default:
        return x6;
    }
  });
  for (var x5 = args[i5]; i5 < len; x5 = args[++i5]) {
    if (isNull(x5) || !isObject(x5)) {
      str += " " + x5;
    } else {
      str += " " + inspect2(x5);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect2(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect2.styles[styleType];
  if (style) {
    return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect2 && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base2 = "", array = false, braces = ["{", "}"];
  if (isArray2(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n3 = value.name ? ": " + value.name : "";
    base2 = " [Function" + n3 + "]";
  }
  if (isRegExp(value)) {
    base2 = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base2 = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base2 = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base2 + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base2, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i5 = 0, l5 = value.length; i5 < l5; ++i5) {
    if (hasOwnProperty(value, String(i5))) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        String(i5),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base2, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
}
function isArray2(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d5) {
  return isObject(d5) && objectToString(d5) === "[object Date]";
}
function isError(e5) {
  return isObject(e5) && (objectToString(e5) === "[object Error]" || e5 instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
}
function isBuffer3(maybeBuf) {
  return Buffer2.isBuffer(maybeBuf);
}
function objectToString(o5) {
  return Object.prototype.toString.call(o5);
}
function pad(n3) {
  return n3 < 10 ? "0" + n3.toString(10) : n3.toString(10);
}
function timestamp() {
  var d5 = new Date();
  var time = [
    pad(d5.getHours()),
    pad(d5.getMinutes()),
    pad(d5.getSeconds())
  ].join(":");
  return [d5.getDate(), months[d5.getMonth()], time].join(" ");
}
function log() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments));
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys2 = Object.keys(add);
  var i5 = keys2.length;
  while (i5--) {
    origin[keys2[i5]] = add[keys2[i5]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron, months, util_default;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_process();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect2.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect2.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
    months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    util_default = {
      inherits: inherits_default,
      _extend,
      log,
      isBuffer: isBuffer3,
      isPrimitive,
      isFunction,
      isError,
      isDate,
      isObject,
      isRegExp,
      isUndefined,
      isSymbol,
      isString,
      isNumber,
      isNullOrUndefined,
      isNull,
      isBoolean,
      isArray: isArray2,
      inspect: inspect2,
      deprecate,
      format,
      debuglog
    };
  }
});

// node-modules-polyfills-commonjs:util
var require_util = __commonJS({
  "node-modules-polyfills-commonjs:util"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_util(), __toCommonJS(util_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        var source = arguments[i5] != null ? arguments[i5] : {};
        if (i5 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require_buffer();
    var Buffer4 = _require.Buffer;
    var _require2 = require_util();
    var inspect4 = _require2.inspect;
    var custom = inspect4 && inspect4.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer4.prototype.copy.call(src, target, offset);
    }
    module.exports = /* @__PURE__ */ function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList2, [{
        key: "push",
        value: function push(v5) {
          var entry = {
            data: v5,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v5) {
          var entry = {
            data: v5,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s5) {
          if (this.length === 0)
            return "";
          var p5 = this.head;
          var ret = "" + p5.data;
          while (p5 = p5.next) {
            ret += s5 + p5.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat5(n3) {
          if (this.length === 0)
            return Buffer4.alloc(0);
          var ret = Buffer4.allocUnsafe(n3 >>> 0);
          var p5 = this.head;
          var i5 = 0;
          while (p5) {
            copyBuffer(p5.data, ret, i5);
            i5 += p5.data.length;
            p5 = p5.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n3, hasStrings) {
          var ret;
          if (n3 < this.head.data.length) {
            ret = this.head.data.slice(0, n3);
            this.head.data = this.head.data.slice(n3);
          } else if (n3 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n3) : this._getBuffer(n3);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n3) {
          var p5 = this.head;
          var c5 = 1;
          var ret = p5.data;
          n3 -= ret.length;
          while (p5 = p5.next) {
            var str = p5.data;
            var nb = n3 > str.length ? str.length : n3;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n3);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === str.length) {
                ++c5;
                if (p5.next)
                  this.head = p5.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = str.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n3) {
          var ret = Buffer4.allocUnsafe(n3);
          var p5 = this.head;
          var c5 = 1;
          p5.data.copy(ret);
          n3 -= p5.data.length;
          while (p5 = p5.next) {
            var buf = p5.data;
            var nb = n3 > buf.length ? buf.length : n3;
            buf.copy(ret, ret.length - n3, 0, nb);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === buf.length) {
                ++c5;
                if (p5.next)
                  this.head = p5.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = buf.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_6, options) {
          return inspect4(this, _objectSpread({}, options, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList2;
    }();
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/hash-base/node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage2(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage2(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i5) {
          return String(i5);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes3(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type2 = includes3(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser2 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = deprecate2;
    function deprecate2(fn, msg) {
      if (config4("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config4("throwDeprecation")) {
            throw new Error(msg);
          } else if (config4("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config4(name) {
      try {
        if (!globalThis.localStorage)
          return false;
      } catch (_6) {
        return false;
      }
      var val = globalThis.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Writable2;
    function CorkedRequest2(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex2;
    Writable2.WritableState = WritableState2;
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream2 = require_stream_browser();
    var Buffer4 = require_buffer().Buffer;
    var OurUint8Array = globalThis.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable2, Stream2);
    function nop2() {
    }
    function WritableState2(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite2(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest2(this);
    }
    WritableState2.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState2.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_6) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable2)
            return false;
          return object && object._writableState instanceof WritableState2;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable2(options) {
      Duplex2 = Duplex2 || require_stream_duplex();
      var isDuplex = this instanceof Duplex2;
      if (!isDuplex && !realHasInstance.call(Writable2, this))
        return new Writable2(options);
      this._writableState = new WritableState2(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd2(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk2(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer4.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop2;
      if (state.ending)
        writeAfterEnd2(this, cb);
      else if (isBuf || validChunk2(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer2(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk2(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer4.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk2(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite2(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError2(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe2, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe2(stream, state);
      }
    }
    function onwriteStateUpdate2(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite2(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate2(state);
      if (er)
        onwriteError2(stream, state, sync, er, cb);
      else {
        var finished = needFinish2(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer2(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite2, stream, state, finished, cb);
        } else {
          afterWrite2(stream, state, finished, cb);
        }
      }
    }
    function afterWrite2(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain2(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe2(stream, state);
    }
    function onwriteDrain2(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer2(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l5 = state.bufferedRequestCount;
        var buffer2 = new Array(l5);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count2 = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count2] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count2 += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite2(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest2(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite2(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable2(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function needFinish2(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe2(stream, state);
      });
    }
    function prefinish2(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe2(stream, state) {
      var need = needFinish2(state);
      if (need) {
        prefinish2(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable2(stream, state, cb) {
      state.ending = true;
      finishMaybe2(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var objectKeys3 = Object.keys || function(obj) {
      var keys3 = [];
      for (var key in obj) {
        keys3.push(key);
      }
      return keys3;
    };
    module.exports = Duplex2;
    var Readable2 = require_stream_readable();
    var Writable2 = require_stream_writable();
    require_inherits_browser()(Duplex2, Readable2);
    {
      keys2 = objectKeys3(Writable2.prototype);
      for (v5 = 0; v5 < keys2.length; v5++) {
        method = keys2[v5];
        if (!Duplex2.prototype[method])
          Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    var keys2;
    var method;
    var v5;
    function Duplex2(options) {
      if (!(this instanceof Duplex2))
        return new Duplex2(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend2);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function onend2() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT2, this);
    }
    function onEndNT2(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var isEncoding3 = Buffer4.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer4.isEncoding === isEncoding3 || !isEncoding3(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder2;
    function StringDecoder2(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer4.allocUnsafe(nb);
    }
    StringDecoder2.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r6;
      var i5;
      if (this.lastNeed) {
        r6 = this.fillLast(buf);
        if (r6 === void 0)
          return "";
        i5 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i5 = 0;
      }
      if (i5 < buf.length)
        return r6 ? r6 + this.text(buf, i5) : this.text(buf, i5);
      return r6 || "";
    };
    StringDecoder2.prototype.end = utf8End;
    StringDecoder2.prototype.text = utf8Text;
    StringDecoder2.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i5) {
      var j5 = buf.length - 1;
      if (j5 < i5)
        return 0;
      var nb = utf8CheckByte(buf[j5]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j5 < i5 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j5]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j5 < i5 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j5]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p5) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p5 = this.lastTotal - this.lastNeed;
      var r6 = utf8CheckExtraBytes(this, buf, p5);
      if (r6 !== void 0)
        return r6;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p5, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p5, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i5) {
      var total = utf8CheckIncomplete(this, buf, i5);
      if (!this.lastNeed)
        return buf.toString("utf8", i5);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i5, end);
    }
    function utf8End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r6 + "\uFFFD";
      return r6;
    }
    function utf16Text(buf, i5) {
      if ((buf.length - i5) % 2 === 0) {
        var r6 = buf.toString("utf16le", i5);
        if (r6) {
          var c5 = r6.charCodeAt(r6.length - 1);
          if (c5 >= 55296 && c5 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r6.slice(0, -1);
          }
        }
        return r6;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i5, buf.length - 1);
    }
    function utf16End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r6 + this.lastChar.toString("utf16le", 0, end);
      }
      return r6;
    }
    function base64Text(buf, i5) {
      var n3 = (buf.length - i5) % 3;
      if (n3 === 0)
        return buf.toString("base64", i5);
      this.lastNeed = 3 - n3;
      this.lastTotal = 3;
      if (n3 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i5, buf.length - n3);
    }
    function base64End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r6 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r6;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once4(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop4() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once4(callback || noop4);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend2 = function onend3() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend2);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend2);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done2) {
      return {
        value,
        done: done2
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error2 = this[kError];
        if (error2 !== null) {
          return Promise.reject(error2);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator2[kStream].read();
          if (data) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator2[kLastResolve] = resolve;
            iterator2[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator2[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator2[kLastReject];
          if (reject !== null) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            reject(err);
          }
          iterator2[kError] = err;
          return;
        }
        var resolve = iterator2[kLastResolve];
        if (resolve !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator2[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator2));
      return iterator2;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Readable2;
    var Duplex2;
    Readable2.ReadableState = ReadableState2;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type2) {
      return emitter.listeners(type2).length;
    };
    var Stream2 = require_stream_browser();
    var Buffer4 = require_buffer().Buffer;
    var OurUint8Array = globalThis.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug2;
    if (debugUtil && debugUtil.debuglog) {
      debug2 = debugUtil.debuglog("stream");
    } else {
      debug2 = function debug3() {
      };
    }
    var BufferList2 = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder2;
    var createReadableStreamAsyncIterator;
    var from4;
    require_inherits_browser()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener3(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState2(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList2();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder2(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex2 = Duplex2 || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      var isDuplex = this instanceof Duplex2;
      this._readableState = new ReadableState2(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer4.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk2(this, chunk, null, true, false);
    };
    function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug2("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk2(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid2(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore2(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore2(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable2(stream);
      }
      maybeReadMore2(stream, state);
    }
    function chunkInvalid2(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder2)
        StringDecoder2 = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder2(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p5 = this._readableState.buffer.head;
      var content = "";
      while (p5 !== null) {
        content += decoder.write(p5.data);
        p5 = p5.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM2 = 1073741824;
    function computeNewHighWaterMark2(n3) {
      if (n3 >= MAX_HWM2) {
        n3 = MAX_HWM2;
      } else {
        n3--;
        n3 |= n3 >>> 1;
        n3 |= n3 >>> 2;
        n3 |= n3 >>> 4;
        n3 |= n3 >>> 8;
        n3 |= n3 >>> 16;
        n3++;
      }
      return n3;
    }
    function howMuchToRead2(n3, state) {
      if (n3 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n3 !== n3) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n3 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark2(n3);
      if (n3 <= state.length)
        return n3;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n3) {
      debug2("read", n3);
      n3 = parseInt(n3, 10);
      var state = this._readableState;
      var nOrig = n3;
      if (n3 !== 0)
        state.emittedReadable = false;
      if (n3 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug2("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable2(this);
        else
          emitReadable2(this);
        return null;
      }
      n3 = howMuchToRead2(n3, state);
      if (n3 === 0 && state.ended) {
        if (state.length === 0)
          endReadable2(this);
        return null;
      }
      var doRead = state.needReadable;
      debug2("need readable", doRead);
      if (state.length === 0 || state.length - n3 < state.highWaterMark) {
        doRead = true;
        debug2("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug2("reading or ended", doRead);
      } else if (doRead) {
        debug2("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n3 = howMuchToRead2(nOrig, state);
      }
      var ret;
      if (n3 > 0)
        ret = fromList2(n3, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n3 = 0;
      } else {
        state.length -= n3;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n3 && state.ended)
          endReadable2(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk2(stream, state) {
      debug2("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable2(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_2(stream);
        }
      }
    }
    function emitReadable2(stream) {
      var state = stream._readableState;
      debug2("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug2("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_2, stream);
      }
    }
    function emitReadable_2(stream) {
      var state = stream._readableState;
      debug2("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow2(stream);
    }
    function maybeReadMore2(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_2, stream, state);
      }
    }
    function maybeReadMore_2(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug2("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n3) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend2 : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug2("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend2() {
        debug2("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain2(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug2("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        var ret = dest.write(chunk);
        debug2("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf4(state.pipes, dest) !== -1) && !cleanedUp) {
            debug2("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug2("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener3(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug2("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain2(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug2("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow2(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i5 = 0; i5 < len; i5++) {
          dests[i5].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf4(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug2("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable2(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick2, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick2(self2) {
      debug2("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug2("resume");
        state.flowing = !state.readableListening;
        resume2(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume2(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_2, stream, state);
      }
    }
    function resume_2(stream, state) {
      debug2("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow2(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug2("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug2("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow2(stream) {
      var state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug2("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug2("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i5 in stream) {
        if (this[i5] === void 0 && typeof stream[i5] === "function") {
          this[i5] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i5);
        }
      }
      for (var n3 = 0; n3 < kProxyEvents.length; n3++) {
        stream.on(kProxyEvents[n3], this.emit.bind(this, kProxyEvents[n3]));
      }
      this._read = function(n4) {
        debug2("wrapped _read", n4);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      enumerable: false,
      get: function get3() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList2;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      enumerable: false,
      get: function get3() {
        return this._readableState.length;
      }
    });
    function fromList2(n3, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n3 || n3 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n3, state.decoder);
      }
      return ret;
    }
    function endReadable2(stream) {
      var state = stream._readableState;
      debug2("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT2, state, stream);
      }
    }
    function endReadableNT2(state, stream) {
      debug2("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from4 === void 0) {
          from4 = require_from_browser();
        }
        return from4(Readable2, iterable, opts);
      };
    }
    function indexOf4(xs, x5) {
      for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
        if (xs[i5] === x5)
          return i5;
      }
      return -1;
    }
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Transform2;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex2 = require_stream_duplex();
    require_inherits_browser()(Transform2, Duplex2);
    function afterTransform2(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex2.call(this, options);
      this._transformState = {
        afterTransform: afterTransform2.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish2);
    }
    function prefinish2() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done2(_this, er, data);
        });
      } else {
        done2(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex2.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n3) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex2.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done2(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = PassThrough2;
    var Transform2 = require_stream_transform();
    require_inherits_browser()(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var eos;
    function once4(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop4(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once4(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe2(from4, to) {
      return from4.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop4;
      if (typeof streams[streams.length - 1] !== "function")
        return noop4;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error2;
      var destroys = streams.map(function(stream, i5) {
        var reading = i5 < streams.length - 1;
        var writing = i5 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error2)
            error2 = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error2);
        });
      });
      return streams.reduce(pipe2);
    }
    module.exports = pipeline;
  }
});

// node_modules/hash-base/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/hash-base/node_modules/readable-stream/readable-browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/hash-base/index.js
var require_hash_base = __commonJS({
  "node_modules/hash-base/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var Transform2 = require_readable_browser().Transform;
    var inherits2 = require_inherits_browser();
    function throwIfNotStringOrBuffer(val, prefix) {
      if (!Buffer4.isBuffer(val) && typeof val !== "string") {
        throw new TypeError(prefix + " must be a string or a buffer");
      }
    }
    function HashBase(blockSize) {
      Transform2.call(this);
      this._block = Buffer4.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits2(HashBase, Transform2);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error2 = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error2 = err;
      }
      callback(error2);
    };
    HashBase.prototype._flush = function(callback) {
      var error2 = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error2 = err;
      }
      callback(error2);
    };
    HashBase.prototype.update = function(data, encoding) {
      throwIfNotStringOrBuffer(data, "Data");
      if (this._finalized)
        throw new Error("Digest already called");
      if (!Buffer4.isBuffer(data))
        data = Buffer4.from(data, encoding);
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i5 = this._blockOffset; i5 < this._blockSize; )
          block[i5++] = data[offset++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset < data.length)
        block[this._blockOffset++] = data[offset++];
      for (var j5 = 0, carry = data.length * 8; carry > 0; ++j5) {
        this._length[j5] += carry;
        carry = this._length[j5] / 4294967296 | 0;
        if (carry > 0)
          this._length[j5] -= 4294967296 * carry;
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== void 0)
        digest = digest.toString(encoding);
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i5 = 0; i5 < 4; ++i5)
        this._length[i5] = 0;
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module.exports = HashBase;
  }
});

// node_modules/md5.js/index.js
var require_md5 = __commonJS({
  "node_modules/md5.js/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var HashBase = require_hash_base();
    var Buffer4 = require_safe_buffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits2(MD5, HashBase);
    MD5.prototype._update = function() {
      var M4 = ARRAY16;
      for (var i5 = 0; i5 < 16; ++i5)
        M4[i5] = this._block.readInt32LE(i5 * 4);
      var a5 = this._a;
      var b4 = this._b;
      var c5 = this._c;
      var d5 = this._d;
      a5 = fnF(a5, b4, c5, d5, M4[0], 3614090360, 7);
      d5 = fnF(d5, a5, b4, c5, M4[1], 3905402710, 12);
      c5 = fnF(c5, d5, a5, b4, M4[2], 606105819, 17);
      b4 = fnF(b4, c5, d5, a5, M4[3], 3250441966, 22);
      a5 = fnF(a5, b4, c5, d5, M4[4], 4118548399, 7);
      d5 = fnF(d5, a5, b4, c5, M4[5], 1200080426, 12);
      c5 = fnF(c5, d5, a5, b4, M4[6], 2821735955, 17);
      b4 = fnF(b4, c5, d5, a5, M4[7], 4249261313, 22);
      a5 = fnF(a5, b4, c5, d5, M4[8], 1770035416, 7);
      d5 = fnF(d5, a5, b4, c5, M4[9], 2336552879, 12);
      c5 = fnF(c5, d5, a5, b4, M4[10], 4294925233, 17);
      b4 = fnF(b4, c5, d5, a5, M4[11], 2304563134, 22);
      a5 = fnF(a5, b4, c5, d5, M4[12], 1804603682, 7);
      d5 = fnF(d5, a5, b4, c5, M4[13], 4254626195, 12);
      c5 = fnF(c5, d5, a5, b4, M4[14], 2792965006, 17);
      b4 = fnF(b4, c5, d5, a5, M4[15], 1236535329, 22);
      a5 = fnG(a5, b4, c5, d5, M4[1], 4129170786, 5);
      d5 = fnG(d5, a5, b4, c5, M4[6], 3225465664, 9);
      c5 = fnG(c5, d5, a5, b4, M4[11], 643717713, 14);
      b4 = fnG(b4, c5, d5, a5, M4[0], 3921069994, 20);
      a5 = fnG(a5, b4, c5, d5, M4[5], 3593408605, 5);
      d5 = fnG(d5, a5, b4, c5, M4[10], 38016083, 9);
      c5 = fnG(c5, d5, a5, b4, M4[15], 3634488961, 14);
      b4 = fnG(b4, c5, d5, a5, M4[4], 3889429448, 20);
      a5 = fnG(a5, b4, c5, d5, M4[9], 568446438, 5);
      d5 = fnG(d5, a5, b4, c5, M4[14], 3275163606, 9);
      c5 = fnG(c5, d5, a5, b4, M4[3], 4107603335, 14);
      b4 = fnG(b4, c5, d5, a5, M4[8], 1163531501, 20);
      a5 = fnG(a5, b4, c5, d5, M4[13], 2850285829, 5);
      d5 = fnG(d5, a5, b4, c5, M4[2], 4243563512, 9);
      c5 = fnG(c5, d5, a5, b4, M4[7], 1735328473, 14);
      b4 = fnG(b4, c5, d5, a5, M4[12], 2368359562, 20);
      a5 = fnH(a5, b4, c5, d5, M4[5], 4294588738, 4);
      d5 = fnH(d5, a5, b4, c5, M4[8], 2272392833, 11);
      c5 = fnH(c5, d5, a5, b4, M4[11], 1839030562, 16);
      b4 = fnH(b4, c5, d5, a5, M4[14], 4259657740, 23);
      a5 = fnH(a5, b4, c5, d5, M4[1], 2763975236, 4);
      d5 = fnH(d5, a5, b4, c5, M4[4], 1272893353, 11);
      c5 = fnH(c5, d5, a5, b4, M4[7], 4139469664, 16);
      b4 = fnH(b4, c5, d5, a5, M4[10], 3200236656, 23);
      a5 = fnH(a5, b4, c5, d5, M4[13], 681279174, 4);
      d5 = fnH(d5, a5, b4, c5, M4[0], 3936430074, 11);
      c5 = fnH(c5, d5, a5, b4, M4[3], 3572445317, 16);
      b4 = fnH(b4, c5, d5, a5, M4[6], 76029189, 23);
      a5 = fnH(a5, b4, c5, d5, M4[9], 3654602809, 4);
      d5 = fnH(d5, a5, b4, c5, M4[12], 3873151461, 11);
      c5 = fnH(c5, d5, a5, b4, M4[15], 530742520, 16);
      b4 = fnH(b4, c5, d5, a5, M4[2], 3299628645, 23);
      a5 = fnI(a5, b4, c5, d5, M4[0], 4096336452, 6);
      d5 = fnI(d5, a5, b4, c5, M4[7], 1126891415, 10);
      c5 = fnI(c5, d5, a5, b4, M4[14], 2878612391, 15);
      b4 = fnI(b4, c5, d5, a5, M4[5], 4237533241, 21);
      a5 = fnI(a5, b4, c5, d5, M4[12], 1700485571, 6);
      d5 = fnI(d5, a5, b4, c5, M4[3], 2399980690, 10);
      c5 = fnI(c5, d5, a5, b4, M4[10], 4293915773, 15);
      b4 = fnI(b4, c5, d5, a5, M4[1], 2240044497, 21);
      a5 = fnI(a5, b4, c5, d5, M4[8], 1873313359, 6);
      d5 = fnI(d5, a5, b4, c5, M4[15], 4264355552, 10);
      c5 = fnI(c5, d5, a5, b4, M4[6], 2734768916, 15);
      b4 = fnI(b4, c5, d5, a5, M4[13], 1309151649, 21);
      a5 = fnI(a5, b4, c5, d5, M4[4], 4149444226, 6);
      d5 = fnI(d5, a5, b4, c5, M4[11], 3174756917, 10);
      c5 = fnI(c5, d5, a5, b4, M4[2], 718787259, 15);
      b4 = fnI(b4, c5, d5, a5, M4[9], 3951481745, 21);
      this._a = this._a + a5 | 0;
      this._b = this._b + b4 | 0;
      this._c = this._c + c5 | 0;
      this._d = this._d + d5 | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer2 = Buffer4.allocUnsafe(16);
      buffer2.writeInt32LE(this._a, 0);
      buffer2.writeInt32LE(this._b, 4);
      buffer2.writeInt32LE(this._c, 8);
      buffer2.writeInt32LE(this._d, 12);
      return buffer2;
    };
    function rotl(x5, n3) {
      return x5 << n3 | x5 >>> 32 - n3;
    }
    function fnF(a5, b4, c5, d5, m5, k5, s5) {
      return rotl(a5 + (b4 & c5 | ~b4 & d5) + m5 + k5 | 0, s5) + b4 | 0;
    }
    function fnG(a5, b4, c5, d5, m5, k5, s5) {
      return rotl(a5 + (b4 & d5 | c5 & ~d5) + m5 + k5 | 0, s5) + b4 | 0;
    }
    function fnH(a5, b4, c5, d5, m5, k5, s5) {
      return rotl(a5 + (b4 ^ c5 ^ d5) + m5 + k5 | 0, s5) + b4 | 0;
    }
    function fnI(a5, b4, c5, d5, m5, k5, s5) {
      return rotl(a5 + (c5 ^ (b4 | ~d5)) + m5 + k5 | 0, s5) + b4 | 0;
    }
    module.exports = MD5;
  }
});

// node_modules/ripemd160/index.js
var require_ripemd160 = __commonJS({
  "node_modules/ripemd160/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_buffer().Buffer;
    var inherits2 = require_inherits_browser();
    var HashBase = require_hash_base();
    var ARRAY16 = new Array(16);
    var zl = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var zr = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var sl = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sr = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
    var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
    var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function RIPEMD160() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
    }
    inherits2(RIPEMD160, HashBase);
    RIPEMD160.prototype._update = function() {
      var words = ARRAY16;
      for (var j5 = 0; j5 < 16; ++j5)
        words[j5] = this._block.readInt32LE(j5 * 4);
      var al = this._a | 0;
      var bl = this._b | 0;
      var cl = this._c | 0;
      var dl = this._d | 0;
      var el = this._e | 0;
      var ar = this._a | 0;
      var br = this._b | 0;
      var cr = this._c | 0;
      var dr = this._d | 0;
      var er = this._e | 0;
      for (var i5 = 0; i5 < 80; i5 += 1) {
        var tl;
        var tr;
        if (i5 < 16) {
          tl = fn1(al, bl, cl, dl, el, words[zl[i5]], hl[0], sl[i5]);
          tr = fn5(ar, br, cr, dr, er, words[zr[i5]], hr[0], sr[i5]);
        } else if (i5 < 32) {
          tl = fn2(al, bl, cl, dl, el, words[zl[i5]], hl[1], sl[i5]);
          tr = fn4(ar, br, cr, dr, er, words[zr[i5]], hr[1], sr[i5]);
        } else if (i5 < 48) {
          tl = fn3(al, bl, cl, dl, el, words[zl[i5]], hl[2], sl[i5]);
          tr = fn3(ar, br, cr, dr, er, words[zr[i5]], hr[2], sr[i5]);
        } else if (i5 < 64) {
          tl = fn4(al, bl, cl, dl, el, words[zl[i5]], hl[3], sl[i5]);
          tr = fn2(ar, br, cr, dr, er, words[zr[i5]], hr[3], sr[i5]);
        } else {
          tl = fn5(al, bl, cl, dl, el, words[zl[i5]], hl[4], sl[i5]);
          tr = fn1(ar, br, cr, dr, er, words[zr[i5]], hr[4], sr[i5]);
        }
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = tl;
        ar = er;
        er = dr;
        dr = rotl(cr, 10);
        cr = br;
        br = tr;
      }
      var t5 = this._b + cl + dr | 0;
      this._b = this._c + dl + er | 0;
      this._c = this._d + el + ar | 0;
      this._d = this._e + al + br | 0;
      this._e = this._a + bl + cr | 0;
      this._a = t5;
    };
    RIPEMD160.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer2 = Buffer4.alloc ? Buffer4.alloc(20) : new Buffer4(20);
      buffer2.writeInt32LE(this._a, 0);
      buffer2.writeInt32LE(this._b, 4);
      buffer2.writeInt32LE(this._c, 8);
      buffer2.writeInt32LE(this._d, 12);
      buffer2.writeInt32LE(this._e, 16);
      return buffer2;
    };
    function rotl(x5, n3) {
      return x5 << n3 | x5 >>> 32 - n3;
    }
    function fn1(a5, b4, c5, d5, e5, m5, k5, s5) {
      return rotl(a5 + (b4 ^ c5 ^ d5) + m5 + k5 | 0, s5) + e5 | 0;
    }
    function fn2(a5, b4, c5, d5, e5, m5, k5, s5) {
      return rotl(a5 + (b4 & c5 | ~b4 & d5) + m5 + k5 | 0, s5) + e5 | 0;
    }
    function fn3(a5, b4, c5, d5, e5, m5, k5, s5) {
      return rotl(a5 + ((b4 | ~c5) ^ d5) + m5 + k5 | 0, s5) + e5 | 0;
    }
    function fn4(a5, b4, c5, d5, e5, m5, k5, s5) {
      return rotl(a5 + (b4 & d5 | c5 & ~d5) + m5 + k5 | 0, s5) + e5 | 0;
    }
    function fn5(a5, b4, c5, d5, e5, m5, k5, s5) {
      return rotl(a5 + (b4 ^ (c5 | ~d5)) + m5 + k5 | 0, s5) + e5 | 0;
    }
    module.exports = RIPEMD160;
  }
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/sha.js/hash.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer4.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer4.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i5 = 0; i5 < remainder; i5++) {
          block[assigned + i5] = data[offset + i5];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
  }
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/sha.js/sha.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash();
    var Buffer4 = require_safe_buffer().Buffer;
    var K2 = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W2 = new Array(80);
    function Sha() {
      this.init();
      this._w = W2;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s5, b4, c5, d5) {
      if (s5 === 0)
        return b4 & c5 | ~b4 & d5;
      if (s5 === 2)
        return b4 & c5 | b4 & d5 | c5 & d5;
      return b4 ^ c5 ^ d5;
    }
    Sha.prototype._update = function(M4) {
      var W3 = this._w;
      var a5 = this._a | 0;
      var b4 = this._b | 0;
      var c5 = this._c | 0;
      var d5 = this._d | 0;
      var e5 = this._e | 0;
      for (var i5 = 0; i5 < 16; ++i5)
        W3[i5] = M4.readInt32BE(i5 * 4);
      for (; i5 < 80; ++i5)
        W3[i5] = W3[i5 - 3] ^ W3[i5 - 8] ^ W3[i5 - 14] ^ W3[i5 - 16];
      for (var j5 = 0; j5 < 80; ++j5) {
        var s5 = ~~(j5 / 20);
        var t5 = rotl5(a5) + ft(s5, b4, c5, d5) + e5 + W3[j5] + K2[s5] | 0;
        e5 = d5;
        d5 = c5;
        c5 = rotl30(b4);
        b4 = a5;
        a5 = t5;
      }
      this._a = a5 + this._a | 0;
      this._b = b4 + this._b | 0;
      this._c = c5 + this._c | 0;
      this._d = d5 + this._d | 0;
      this._e = e5 + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(20);
      H4.writeInt32BE(this._a | 0, 0);
      H4.writeInt32BE(this._b | 0, 4);
      H4.writeInt32BE(this._c | 0, 8);
      H4.writeInt32BE(this._d | 0, 12);
      H4.writeInt32BE(this._e | 0, 16);
      return H4;
    };
    module.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash();
    var Buffer4 = require_safe_buffer().Buffer;
    var K2 = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W2 = new Array(80);
    function Sha1() {
      this.init();
      this._w = W2;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s5, b4, c5, d5) {
      if (s5 === 0)
        return b4 & c5 | ~b4 & d5;
      if (s5 === 2)
        return b4 & c5 | b4 & d5 | c5 & d5;
      return b4 ^ c5 ^ d5;
    }
    Sha1.prototype._update = function(M4) {
      var W3 = this._w;
      var a5 = this._a | 0;
      var b4 = this._b | 0;
      var c5 = this._c | 0;
      var d5 = this._d | 0;
      var e5 = this._e | 0;
      for (var i5 = 0; i5 < 16; ++i5)
        W3[i5] = M4.readInt32BE(i5 * 4);
      for (; i5 < 80; ++i5)
        W3[i5] = rotl1(W3[i5 - 3] ^ W3[i5 - 8] ^ W3[i5 - 14] ^ W3[i5 - 16]);
      for (var j5 = 0; j5 < 80; ++j5) {
        var s5 = ~~(j5 / 20);
        var t5 = rotl5(a5) + ft(s5, b4, c5, d5) + e5 + W3[j5] + K2[s5] | 0;
        e5 = d5;
        d5 = c5;
        c5 = rotl30(b4);
        b4 = a5;
        a5 = t5;
      }
      this._a = a5 + this._a | 0;
      this._b = b4 + this._b | 0;
      this._c = c5 + this._c | 0;
      this._d = d5 + this._d | 0;
      this._e = e5 + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(20);
      H4.writeInt32BE(this._a | 0, 0);
      H4.writeInt32BE(this._b | 0, 4);
      H4.writeInt32BE(this._c | 0, 8);
      H4.writeInt32BE(this._d | 0, 12);
      H4.writeInt32BE(this._e | 0, 16);
      return H4;
    };
    module.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash();
    var Buffer4 = require_safe_buffer().Buffer;
    var K2 = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W2 = new Array(64);
    function Sha256() {
      this.init();
      this._w = W2;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x5, y5, z5) {
      return z5 ^ x5 & (y5 ^ z5);
    }
    function maj(x5, y5, z5) {
      return x5 & y5 | z5 & (x5 | y5);
    }
    function sigma0(x5) {
      return (x5 >>> 2 | x5 << 30) ^ (x5 >>> 13 | x5 << 19) ^ (x5 >>> 22 | x5 << 10);
    }
    function sigma1(x5) {
      return (x5 >>> 6 | x5 << 26) ^ (x5 >>> 11 | x5 << 21) ^ (x5 >>> 25 | x5 << 7);
    }
    function gamma0(x5) {
      return (x5 >>> 7 | x5 << 25) ^ (x5 >>> 18 | x5 << 14) ^ x5 >>> 3;
    }
    function gamma1(x5) {
      return (x5 >>> 17 | x5 << 15) ^ (x5 >>> 19 | x5 << 13) ^ x5 >>> 10;
    }
    Sha256.prototype._update = function(M4) {
      var W3 = this._w;
      var a5 = this._a | 0;
      var b4 = this._b | 0;
      var c5 = this._c | 0;
      var d5 = this._d | 0;
      var e5 = this._e | 0;
      var f5 = this._f | 0;
      var g5 = this._g | 0;
      var h5 = this._h | 0;
      for (var i5 = 0; i5 < 16; ++i5)
        W3[i5] = M4.readInt32BE(i5 * 4);
      for (; i5 < 64; ++i5)
        W3[i5] = gamma1(W3[i5 - 2]) + W3[i5 - 7] + gamma0(W3[i5 - 15]) + W3[i5 - 16] | 0;
      for (var j5 = 0; j5 < 64; ++j5) {
        var T1 = h5 + sigma1(e5) + ch(e5, f5, g5) + K2[j5] + W3[j5] | 0;
        var T22 = sigma0(a5) + maj(a5, b4, c5) | 0;
        h5 = g5;
        g5 = f5;
        f5 = e5;
        e5 = d5 + T1 | 0;
        d5 = c5;
        c5 = b4;
        b4 = a5;
        a5 = T1 + T22 | 0;
      }
      this._a = a5 + this._a | 0;
      this._b = b4 + this._b | 0;
      this._c = c5 + this._c | 0;
      this._d = d5 + this._d | 0;
      this._e = e5 + this._e | 0;
      this._f = f5 + this._f | 0;
      this._g = g5 + this._g | 0;
      this._h = h5 + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(32);
      H4.writeInt32BE(this._a, 0);
      H4.writeInt32BE(this._b, 4);
      H4.writeInt32BE(this._c, 8);
      H4.writeInt32BE(this._d, 12);
      H4.writeInt32BE(this._e, 16);
      H4.writeInt32BE(this._f, 20);
      H4.writeInt32BE(this._g, 24);
      H4.writeInt32BE(this._h, 28);
      return H4;
    };
    module.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Sha256 = require_sha256();
    var Hash = require_hash();
    var Buffer4 = require_safe_buffer().Buffer;
    var W2 = new Array(64);
    function Sha224() {
      this.init();
      this._w = W2;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(28);
      H4.writeInt32BE(this._a, 0);
      H4.writeInt32BE(this._b, 4);
      H4.writeInt32BE(this._c, 8);
      H4.writeInt32BE(this._d, 12);
      H4.writeInt32BE(this._e, 16);
      H4.writeInt32BE(this._f, 20);
      H4.writeInt32BE(this._g, 24);
      return H4;
    };
    module.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash();
    var Buffer4 = require_safe_buffer().Buffer;
    var K2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W2 = new Array(160);
    function Sha512() {
      this.init();
      this._w = W2;
      Hash.call(this, 128, 112);
    }
    inherits2(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x5, y5, z5) {
      return z5 ^ x5 & (y5 ^ z5);
    }
    function maj(x5, y5, z5) {
      return x5 & y5 | z5 & (x5 | y5);
    }
    function sigma0(x5, xl) {
      return (x5 >>> 28 | xl << 4) ^ (xl >>> 2 | x5 << 30) ^ (xl >>> 7 | x5 << 25);
    }
    function sigma1(x5, xl) {
      return (x5 >>> 14 | xl << 18) ^ (x5 >>> 18 | xl << 14) ^ (xl >>> 9 | x5 << 23);
    }
    function Gamma0(x5, xl) {
      return (x5 >>> 1 | xl << 31) ^ (x5 >>> 8 | xl << 24) ^ x5 >>> 7;
    }
    function Gamma0l(x5, xl) {
      return (x5 >>> 1 | xl << 31) ^ (x5 >>> 8 | xl << 24) ^ (x5 >>> 7 | xl << 25);
    }
    function Gamma1(x5, xl) {
      return (x5 >>> 19 | xl << 13) ^ (xl >>> 29 | x5 << 3) ^ x5 >>> 6;
    }
    function Gamma1l(x5, xl) {
      return (x5 >>> 19 | xl << 13) ^ (xl >>> 29 | x5 << 3) ^ (x5 >>> 6 | xl << 26);
    }
    function getCarry(a5, b4) {
      return a5 >>> 0 < b4 >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M4) {
      var W3 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i5 = 0; i5 < 32; i5 += 2) {
        W3[i5] = M4.readInt32BE(i5 * 4);
        W3[i5 + 1] = M4.readInt32BE(i5 * 4 + 4);
      }
      for (; i5 < 160; i5 += 2) {
        var xh = W3[i5 - 15 * 2];
        var xl = W3[i5 - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W3[i5 - 2 * 2];
        xl = W3[i5 - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W3[i5 - 7 * 2];
        var Wi7l = W3[i5 - 7 * 2 + 1];
        var Wi16h = W3[i5 - 16 * 2];
        var Wi16l = W3[i5 - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W3[i5] = Wih;
        W3[i5 + 1] = Wil;
      }
      for (var j5 = 0; j5 < 160; j5 += 2) {
        Wih = W3[j5];
        Wil = W3[j5 + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K2[j5];
        var Kil = K2[j5 + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(64);
      function writeInt64BE(h5, l5, offset) {
        H4.writeInt32BE(h5, offset);
        H4.writeInt32BE(l5, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H4;
    };
    module.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var SHA512 = require_sha512();
    var Hash = require_hash();
    var Buffer4 = require_safe_buffer().Buffer;
    var W2 = new Array(160);
    function Sha384() {
      this.init();
      this._w = W2;
      Hash.call(this, 128, 112);
    }
    inherits2(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(48);
      function writeInt64BE(h5, l5, offset) {
        H4.writeInt32BE(h5, offset);
        H4.writeInt32BE(l5, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H4;
    };
    module.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var exports = module.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports[algorithm];
      if (!Algorithm)
        throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports.sha = require_sha();
    exports.sha1 = require_sha1();
    exports.sha224 = require_sha224();
    exports.sha256 = require_sha256();
    exports.sha384 = require_sha384();
    exports.sha512 = require_sha512();
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_buffer2();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v5) {
      var entry = { data: v5, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v5) {
      var entry = { data: v5, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s5) {
      if (this.length === 0)
        return "";
      var p5 = this.head;
      var ret = "" + p5.data;
      while (p5 = p5.next) {
        ret += s5 + p5.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n3) {
      if (this.length === 0)
        return Buffer3.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer3.allocUnsafe(n3 >>> 0);
      var p5 = this.head;
      var i5 = 0;
      while (p5) {
        p5.data.copy(ret, i5);
        i5 += p5.data.length;
        p5 = p5.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
var string_decoder_exports = {};
__export(string_decoder_exports, {
  StringDecoder: () => StringDecoder
});
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer3(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer2) {
  return buffer2.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer2) {
  this.charReceived = buffer2.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer2) {
  this.charReceived = buffer2.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_buffer2();
    isBufferEncoding = Buffer3.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer2) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer2.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer2.length;
        buffer2.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer2 = buffer2.slice(available, buffer2.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer2.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer2);
      var end = buffer2.length;
      if (this.charLength) {
        buffer2.copy(this.charBuffer, 0, buffer2.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer2.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer2.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer2) {
      var i5 = buffer2.length >= 3 ? 3 : buffer2.length;
      for (; i5 > 0; i5--) {
        var c5 = buffer2[buffer2.length - i5];
        if (i5 == 1 && c5 >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i5 <= 2 && c5 >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i5 <= 3 && c5 >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i5;
    };
    StringDecoder.prototype.end = function(buffer2) {
      var res = "";
      if (buffer2 && buffer2.length)
        res = this.write(buffer2);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type2) {
  return emitter.listeners(type2).length;
}
function ReadableState(options, stream) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e5 = new Error("stream.push() after EOF");
      stream.emit("error", e5);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n3) {
  if (n3 >= MAX_HWM) {
    n3 = MAX_HWM;
  } else {
    n3--;
    n3 |= n3 >>> 1;
    n3 |= n3 >>> 2;
    n3 |= n3 >>> 4;
    n3 |= n3 >>> 8;
    n3 |= n3 >>> 16;
    n3++;
  }
  return n3;
}
function howMuchToRead(n3, state) {
  if (n3 <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n3 !== n3) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n3 > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n3);
  if (n3 <= state.length)
    return n3;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick2(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick2(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick2(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n3, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n3 || n3 >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n3, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n3, list, hasStrings) {
  var ret;
  if (n3 < list.head.data.length) {
    ret = list.head.data.slice(0, n3);
    list.head.data = list.head.data.slice(n3);
  } else if (n3 === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n3, list) : copyFromBuffer(n3, list);
  }
  return ret;
}
function copyFromBufferString(n3, list) {
  var p5 = list.head;
  var c5 = 1;
  var ret = p5.data;
  n3 -= ret.length;
  while (p5 = p5.next) {
    var str = p5.data;
    var nb = n3 > str.length ? str.length : n3;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n3);
    n3 -= nb;
    if (n3 === 0) {
      if (nb === str.length) {
        ++c5;
        if (p5.next)
          list.head = p5.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p5;
        p5.data = str.slice(nb);
      }
      break;
    }
    ++c5;
  }
  list.length -= c5;
  return ret;
}
function copyFromBuffer(n3, list) {
  var ret = Buffer2.allocUnsafe(n3);
  var p5 = list.head;
  var c5 = 1;
  p5.data.copy(ret);
  n3 -= p5.data.length;
  while (p5 = p5.next) {
    var buf = p5.data;
    var nb = n3 > buf.length ? buf.length : n3;
    buf.copy(ret, ret.length - n3, 0, nb);
    n3 -= nb;
    if (n3 === 0) {
      if (nb === buf.length) {
        ++c5;
        if (p5.next)
          list.head = p5.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p5;
        p5.data = buf.slice(nb);
      }
      break;
    }
    ++c5;
  }
  list.length -= c5;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick2(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs, f5) {
  for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
    f5(xs[i5], i5);
  }
}
function indexOf3(xs, x5) {
  for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
    if (xs[i5] === x5)
      return i5;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n3) {
      debug("read", n3);
      n3 = parseInt(n3, 10);
      var state = this._readableState;
      var nOrig = n3;
      if (n3 !== 0)
        state.emittedReadable = false;
      if (n3 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n3 = howMuchToRead(n3, state);
      if (n3 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n3 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n3 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n3 > 0)
        ret = fromList(n3, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n3 = 0;
      } else {
        state.length -= n3;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n3 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n3) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick2(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i5 = indexOf3(state.pipes, dest);
      if (i5 === -1)
        return this;
      state.pipes.splice(i5, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick2(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i5 in stream) {
        if (this[i5] === void 0 && typeof stream[i5] === "function") {
          this[i5] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i5);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n3) {
        debug("wrapped _read", n3);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick2(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer3.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick2(cb, er);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer3.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer3.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last2 = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last2) {
      last2.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick2(cb, er);
  else
    cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick2(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    var l5 = state.bufferedRequestCount;
    var buffer2 = new Array(l5);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count2 = 0;
    while (entry) {
      buffer2[count2] = entry;
      entry = entry.next;
      count2 += 1;
    }
    doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state.writing) {
        break;
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick2(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_util();
    init_buffer2();
    init_events();
    init_duplex();
    init_process();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer3.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick2(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v5;
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_util();
    init_process();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v5 = 0; v5 < keys.length; v5++) {
      method = keys[v5];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n3) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform.call(this, options);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_stream(), __toCommonJS(stream_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills-commonjs:string_decoder
var require_string_decoder2 = __commonJS({
  "node-modules-polyfills-commonjs:string_decoder"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_string_decoder(), __toCommonJS(string_decoder_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/cipher-base/index.js
var require_cipher_base = __commonJS({
  "node_modules/cipher-base/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var Transform2 = require_stream().Transform;
    var StringDecoder2 = require_string_decoder2().StringDecoder;
    var inherits2 = require_inherits_browser();
    function CipherBase(hashMode) {
      Transform2.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this.final = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits2(CipherBase, Transform2);
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      if (typeof data === "string") {
        data = Buffer4.from(data, inputEnc);
      }
      var outData = this._update(data);
      if (this.hashMode)
        return this;
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {
    };
    CipherBase.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _6, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e5) {
        err = e5;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done2) {
      var err;
      try {
        this.push(this.__final());
      } catch (e5) {
        err = e5;
      }
      done2(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this.__final() || Buffer4.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder2(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc)
        throw new Error("can't switch encodings");
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    module.exports = CipherBase;
  }
});

// node_modules/create-hash/browser.js
var require_browser3 = __commonJS({
  "node_modules/create-hash/browser.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var MD5 = require_md5();
    var RIPEMD160 = require_ripemd160();
    var sha = require_sha2();
    var Base = require_cipher_base();
    function Hash(hash) {
      Base.call(this, "digest");
      this._hash = hash;
    }
    inherits2(Hash, Base);
    Hash.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hash.prototype._final = function() {
      return this._hash.digest();
    };
    module.exports = function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === "md5")
        return new MD5();
      if (alg === "rmd160" || alg === "ripemd160")
        return new RIPEMD160();
      return new Hash(sha(alg));
    };
  }
});

// node_modules/create-hmac/legacy.js
var require_legacy = __commonJS({
  "node_modules/create-hmac/legacy.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Buffer4 = require_safe_buffer().Buffer;
    var Base = require_cipher_base();
    var ZEROS = Buffer4.alloc(128);
    var blocksize = 64;
    function Hmac(alg, key) {
      Base.call(this, "digest");
      if (typeof key === "string") {
        key = Buffer4.from(key);
      }
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        key = alg(key);
      } else if (key.length < blocksize) {
        key = Buffer4.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer4.allocUnsafe(blocksize);
      var opad = this._opad = Buffer4.allocUnsafe(blocksize);
      for (var i5 = 0; i5 < blocksize; i5++) {
        ipad[i5] = key[i5] ^ 54;
        opad[i5] = key[i5] ^ 92;
      }
      this._hash = [ipad];
    }
    inherits2(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.push(data);
    };
    Hmac.prototype._final = function() {
      var h5 = this._alg(Buffer4.concat(this._hash));
      return this._alg(Buffer4.concat([this._opad, h5]));
    };
    module.exports = Hmac;
  }
});

// node_modules/create-hash/md5.js
var require_md52 = __commonJS({
  "node_modules/create-hash/md5.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var MD5 = require_md5();
    module.exports = function(buffer2) {
      return new MD5().update(buffer2).digest();
    };
  }
});

// node_modules/create-hmac/browser.js
var require_browser4 = __commonJS({
  "node_modules/create-hmac/browser.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Legacy = require_legacy();
    var Base = require_cipher_base();
    var Buffer4 = require_safe_buffer().Buffer;
    var md5 = require_md52();
    var RIPEMD160 = require_ripemd160();
    var sha = require_sha2();
    var ZEROS = Buffer4.alloc(128);
    function Hmac(alg, key) {
      Base.call(this, "digest");
      if (typeof key === "string") {
        key = Buffer4.from(key);
      }
      var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        var hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
        key = hash.update(key).digest();
      } else if (key.length < blocksize) {
        key = Buffer4.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer4.allocUnsafe(blocksize);
      var opad = this._opad = Buffer4.allocUnsafe(blocksize);
      for (var i5 = 0; i5 < blocksize; i5++) {
        ipad[i5] = key[i5] ^ 54;
        opad[i5] = key[i5] ^ 92;
      }
      this._hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
      this._hash.update(ipad);
    }
    inherits2(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hmac.prototype._final = function() {
      var h5 = this._hash.digest();
      var hash = this._alg === "rmd160" ? new RIPEMD160() : sha(this._alg);
      return hash.update(this._opad).update(h5).digest();
    };
    module.exports = function createHmac(alg, key) {
      alg = alg.toLowerCase();
      if (alg === "rmd160" || alg === "ripemd160") {
        return new Hmac("rmd160", key);
      }
      if (alg === "md5") {
        return new Legacy(md5, key);
      }
      return new Hmac(alg, key);
    };
  }
});

// node_modules/browserify-sign/browser/algorithms.json
var require_algorithms = __commonJS({
  "node_modules/browserify-sign/browser/algorithms.json"(exports, module) {
    module.exports = {
      sha224WithRSAEncryption: {
        sign: "rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
      },
      "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
      },
      sha256WithRSAEncryption: {
        sign: "rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
      },
      "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
      },
      sha384WithRSAEncryption: {
        sign: "rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
      },
      "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
      },
      sha512WithRSAEncryption: {
        sign: "rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
      },
      "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
      },
      "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
      },
      "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
      },
      sha256: {
        sign: "ecdsa",
        hash: "sha256",
        id: ""
      },
      sha224: {
        sign: "ecdsa",
        hash: "sha224",
        id: ""
      },
      sha384: {
        sign: "ecdsa",
        hash: "sha384",
        id: ""
      },
      sha512: {
        sign: "ecdsa",
        hash: "sha512",
        id: ""
      },
      "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      DSA: {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
      },
      "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
      },
      "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
      },
      "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
      },
      "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
      },
      "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
      },
      "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
      },
      "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
      },
      "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
      },
      ripemd160WithRSA: {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
      },
      "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
      },
      md5WithRSAEncryption: {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
      },
      "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
      }
    };
  }
});

// node_modules/browserify-sign/algos.js
var require_algos = __commonJS({
  "node_modules/browserify-sign/algos.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_algorithms();
  }
});

// node_modules/pbkdf2/lib/precondition.js
var require_precondition = __commonJS({
  "node_modules/pbkdf2/lib/precondition.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var MAX_ALLOC = Math.pow(2, 30) - 1;
    module.exports = function(iterations, keylen) {
      if (typeof iterations !== "number") {
        throw new TypeError("Iterations not a number");
      }
      if (iterations < 0) {
        throw new TypeError("Bad iterations");
      }
      if (typeof keylen !== "number") {
        throw new TypeError("Key length not a number");
      }
      if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
        throw new TypeError("Bad key length");
      }
    };
  }
});

// node_modules/pbkdf2/lib/default-encoding.js
var require_default_encoding = __commonJS({
  "node_modules/pbkdf2/lib/default-encoding.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var defaultEncoding;
    if (globalThis.process && globalThis.process.browser) {
      defaultEncoding = "utf-8";
    } else if (globalThis.process && globalThis.process.version) {
      pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10);
      defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
    } else {
      defaultEncoding = "utf-8";
    }
    var pVersionMajor;
    module.exports = defaultEncoding;
  }
});

// node_modules/pbkdf2/lib/to-buffer.js
var require_to_buffer = __commonJS({
  "node_modules/pbkdf2/lib/to-buffer.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    module.exports = function(thing, encoding, name) {
      if (Buffer4.isBuffer(thing)) {
        return thing;
      } else if (typeof thing === "string") {
        return Buffer4.from(thing, encoding);
      } else if (ArrayBuffer.isView(thing)) {
        return Buffer4.from(thing.buffer);
      } else {
        throw new TypeError(name + " must be a string, a Buffer, a typed array or a DataView");
      }
    };
  }
});

// node_modules/pbkdf2/lib/sync-browser.js
var require_sync_browser = __commonJS({
  "node_modules/pbkdf2/lib/sync-browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var md5 = require_md52();
    var RIPEMD160 = require_ripemd160();
    var sha = require_sha2();
    var Buffer4 = require_safe_buffer().Buffer;
    var checkParameters = require_precondition();
    var defaultEncoding = require_default_encoding();
    var toBuffer = require_to_buffer();
    var ZEROS = Buffer4.alloc(128);
    var sizes = {
      md5: 16,
      sha1: 20,
      sha224: 28,
      sha256: 32,
      sha384: 48,
      sha512: 64,
      rmd160: 20,
      ripemd160: 20
    };
    function Hmac(alg, key, saltLen) {
      var hash = getDigest(alg);
      var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
      if (key.length > blocksize) {
        key = hash(key);
      } else if (key.length < blocksize) {
        key = Buffer4.concat([key, ZEROS], blocksize);
      }
      var ipad = Buffer4.allocUnsafe(blocksize + sizes[alg]);
      var opad = Buffer4.allocUnsafe(blocksize + sizes[alg]);
      for (var i5 = 0; i5 < blocksize; i5++) {
        ipad[i5] = key[i5] ^ 54;
        opad[i5] = key[i5] ^ 92;
      }
      var ipad1 = Buffer4.allocUnsafe(blocksize + saltLen + 4);
      ipad.copy(ipad1, 0, 0, blocksize);
      this.ipad1 = ipad1;
      this.ipad2 = ipad;
      this.opad = opad;
      this.alg = alg;
      this.blocksize = blocksize;
      this.hash = hash;
      this.size = sizes[alg];
    }
    Hmac.prototype.run = function(data, ipad) {
      data.copy(ipad, this.blocksize);
      var h5 = this.hash(ipad);
      h5.copy(this.opad, this.blocksize);
      return this.hash(this.opad);
    };
    function getDigest(alg) {
      function shaFunc(data) {
        return sha(alg).update(data).digest();
      }
      function rmd160Func(data) {
        return new RIPEMD160().update(data).digest();
      }
      if (alg === "rmd160" || alg === "ripemd160")
        return rmd160Func;
      if (alg === "md5")
        return md5;
      return shaFunc;
    }
    function pbkdf2(password, salt, iterations, keylen, digest) {
      checkParameters(iterations, keylen);
      password = toBuffer(password, defaultEncoding, "Password");
      salt = toBuffer(salt, defaultEncoding, "Salt");
      digest = digest || "sha1";
      var hmac = new Hmac(digest, password, salt.length);
      var DK = Buffer4.allocUnsafe(keylen);
      var block1 = Buffer4.allocUnsafe(salt.length + 4);
      salt.copy(block1, 0, 0, salt.length);
      var destPos = 0;
      var hLen = sizes[digest];
      var l5 = Math.ceil(keylen / hLen);
      for (var i5 = 1; i5 <= l5; i5++) {
        block1.writeUInt32BE(i5, salt.length);
        var T6 = hmac.run(block1, hmac.ipad1);
        var U2 = T6;
        for (var j5 = 1; j5 < iterations; j5++) {
          U2 = hmac.run(U2, hmac.ipad2);
          for (var k5 = 0; k5 < hLen; k5++)
            T6[k5] ^= U2[k5];
        }
        T6.copy(DK, destPos);
        destPos += hLen;
      }
      return DK;
    }
    module.exports = pbkdf2;
  }
});

// node_modules/pbkdf2/lib/async.js
var require_async = __commonJS({
  "node_modules/pbkdf2/lib/async.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var checkParameters = require_precondition();
    var defaultEncoding = require_default_encoding();
    var sync = require_sync_browser();
    var toBuffer = require_to_buffer();
    var ZERO_BUF;
    var subtle = globalThis.crypto && globalThis.crypto.subtle;
    var toBrowser = {
      sha: "SHA-1",
      "sha-1": "SHA-1",
      sha1: "SHA-1",
      sha256: "SHA-256",
      "sha-256": "SHA-256",
      sha384: "SHA-384",
      "sha-384": "SHA-384",
      "sha-512": "SHA-512",
      sha512: "SHA-512"
    };
    var checks = [];
    function checkNative(algo) {
      if (globalThis.process && !globalThis.process.browser) {
        return Promise.resolve(false);
      }
      if (!subtle || !subtle.importKey || !subtle.deriveBits) {
        return Promise.resolve(false);
      }
      if (checks[algo] !== void 0) {
        return checks[algo];
      }
      ZERO_BUF = ZERO_BUF || Buffer4.alloc(8);
      var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      checks[algo] = prom;
      return prom;
    }
    var nextTick3;
    function getNextTick() {
      if (nextTick3) {
        return nextTick3;
      }
      if (globalThis.process && globalThis.process.nextTick) {
        nextTick3 = globalThis.process.nextTick;
      } else if (globalThis.queueMicrotask) {
        nextTick3 = globalThis.queueMicrotask;
      } else if (globalThis.setImmediate) {
        nextTick3 = globalThis.setImmediate;
      } else {
        nextTick3 = globalThis.setTimeout;
      }
      return nextTick3;
    }
    function browserPbkdf2(password, salt, iterations, length, algo) {
      return subtle.importKey(
        "raw",
        password,
        { name: "PBKDF2" },
        false,
        ["deriveBits"]
      ).then(function(key) {
        return subtle.deriveBits({
          name: "PBKDF2",
          salt,
          iterations,
          hash: {
            name: algo
          }
        }, key, length << 3);
      }).then(function(res) {
        return Buffer4.from(res);
      });
    }
    function resolvePromise(promise, callback) {
      promise.then(function(out) {
        getNextTick()(function() {
          callback(null, out);
        });
      }, function(e5) {
        getNextTick()(function() {
          callback(e5);
        });
      });
    }
    module.exports = function(password, salt, iterations, keylen, digest, callback) {
      if (typeof digest === "function") {
        callback = digest;
        digest = void 0;
      }
      digest = digest || "sha1";
      var algo = toBrowser[digest.toLowerCase()];
      if (!algo || typeof globalThis.Promise !== "function") {
        getNextTick()(function() {
          var out;
          try {
            out = sync(password, salt, iterations, keylen, digest);
          } catch (e5) {
            return callback(e5);
          }
          callback(null, out);
        });
        return;
      }
      checkParameters(iterations, keylen);
      password = toBuffer(password, defaultEncoding, "Password");
      salt = toBuffer(salt, defaultEncoding, "Salt");
      if (typeof callback !== "function")
        throw new Error("No callback provided to pbkdf2");
      resolvePromise(checkNative(algo).then(function(resp) {
        if (resp)
          return browserPbkdf2(password, salt, iterations, keylen, algo);
        return sync(password, salt, iterations, keylen, digest);
      }), callback);
    };
  }
});

// node_modules/pbkdf2/browser.js
var require_browser5 = __commonJS({
  "node_modules/pbkdf2/browser.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports.pbkdf2 = require_async();
    exports.pbkdf2Sync = require_sync_browser();
  }
});

// node_modules/des.js/lib/des/utils.js
var require_utils = __commonJS({
  "node_modules/des.js/lib/des/utils.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports.readUInt32BE = function readUInt32BE3(bytes, off3) {
      var res = bytes[0 + off3] << 24 | bytes[1 + off3] << 16 | bytes[2 + off3] << 8 | bytes[3 + off3];
      return res >>> 0;
    };
    exports.writeUInt32BE = function writeUInt32BE3(bytes, value, off3) {
      bytes[0 + off3] = value >>> 24;
      bytes[1 + off3] = value >>> 16 & 255;
      bytes[2 + off3] = value >>> 8 & 255;
      bytes[3 + off3] = value & 255;
    };
    exports.ip = function ip(inL, inR, out, off3) {
      var outL = 0;
      var outR = 0;
      for (var i5 = 6; i5 >= 0; i5 -= 2) {
        for (var j5 = 0; j5 <= 24; j5 += 8) {
          outL <<= 1;
          outL |= inR >>> j5 + i5 & 1;
        }
        for (var j5 = 0; j5 <= 24; j5 += 8) {
          outL <<= 1;
          outL |= inL >>> j5 + i5 & 1;
        }
      }
      for (var i5 = 6; i5 >= 0; i5 -= 2) {
        for (var j5 = 1; j5 <= 25; j5 += 8) {
          outR <<= 1;
          outR |= inR >>> j5 + i5 & 1;
        }
        for (var j5 = 1; j5 <= 25; j5 += 8) {
          outR <<= 1;
          outR |= inL >>> j5 + i5 & 1;
        }
      }
      out[off3 + 0] = outL >>> 0;
      out[off3 + 1] = outR >>> 0;
    };
    exports.rip = function rip(inL, inR, out, off3) {
      var outL = 0;
      var outR = 0;
      for (var i5 = 0; i5 < 4; i5++) {
        for (var j5 = 24; j5 >= 0; j5 -= 8) {
          outL <<= 1;
          outL |= inR >>> j5 + i5 & 1;
          outL <<= 1;
          outL |= inL >>> j5 + i5 & 1;
        }
      }
      for (var i5 = 4; i5 < 8; i5++) {
        for (var j5 = 24; j5 >= 0; j5 -= 8) {
          outR <<= 1;
          outR |= inR >>> j5 + i5 & 1;
          outR <<= 1;
          outR |= inL >>> j5 + i5 & 1;
        }
      }
      out[off3 + 0] = outL >>> 0;
      out[off3 + 1] = outR >>> 0;
    };
    exports.pc1 = function pc1(inL, inR, out, off3) {
      var outL = 0;
      var outR = 0;
      for (var i5 = 7; i5 >= 5; i5--) {
        for (var j5 = 0; j5 <= 24; j5 += 8) {
          outL <<= 1;
          outL |= inR >> j5 + i5 & 1;
        }
        for (var j5 = 0; j5 <= 24; j5 += 8) {
          outL <<= 1;
          outL |= inL >> j5 + i5 & 1;
        }
      }
      for (var j5 = 0; j5 <= 24; j5 += 8) {
        outL <<= 1;
        outL |= inR >> j5 + i5 & 1;
      }
      for (var i5 = 1; i5 <= 3; i5++) {
        for (var j5 = 0; j5 <= 24; j5 += 8) {
          outR <<= 1;
          outR |= inR >> j5 + i5 & 1;
        }
        for (var j5 = 0; j5 <= 24; j5 += 8) {
          outR <<= 1;
          outR |= inL >> j5 + i5 & 1;
        }
      }
      for (var j5 = 0; j5 <= 24; j5 += 8) {
        outR <<= 1;
        outR |= inL >> j5 + i5 & 1;
      }
      out[off3 + 0] = outL >>> 0;
      out[off3 + 1] = outR >>> 0;
    };
    exports.r28shl = function r28shl(num, shift) {
      return num << shift & 268435455 | num >>> 28 - shift;
    };
    var pc2table = [
      14,
      11,
      17,
      4,
      27,
      23,
      25,
      0,
      13,
      22,
      7,
      18,
      5,
      9,
      16,
      24,
      2,
      20,
      12,
      21,
      1,
      8,
      15,
      26,
      15,
      4,
      25,
      19,
      9,
      1,
      26,
      16,
      5,
      11,
      23,
      8,
      12,
      7,
      17,
      0,
      22,
      3,
      10,
      14,
      6,
      20,
      27,
      24
    ];
    exports.pc2 = function pc2(inL, inR, out, off3) {
      var outL = 0;
      var outR = 0;
      var len = pc2table.length >>> 1;
      for (var i5 = 0; i5 < len; i5++) {
        outL <<= 1;
        outL |= inL >>> pc2table[i5] & 1;
      }
      for (var i5 = len; i5 < pc2table.length; i5++) {
        outR <<= 1;
        outR |= inR >>> pc2table[i5] & 1;
      }
      out[off3 + 0] = outL >>> 0;
      out[off3 + 1] = outR >>> 0;
    };
    exports.expand = function expand2(r6, out, off3) {
      var outL = 0;
      var outR = 0;
      outL = (r6 & 1) << 5 | r6 >>> 27;
      for (var i5 = 23; i5 >= 15; i5 -= 4) {
        outL <<= 6;
        outL |= r6 >>> i5 & 63;
      }
      for (var i5 = 11; i5 >= 3; i5 -= 4) {
        outR |= r6 >>> i5 & 63;
        outR <<= 6;
      }
      outR |= (r6 & 31) << 1 | r6 >>> 31;
      out[off3 + 0] = outL >>> 0;
      out[off3 + 1] = outR >>> 0;
    };
    var sTable = [
      14,
      0,
      4,
      15,
      13,
      7,
      1,
      4,
      2,
      14,
      15,
      2,
      11,
      13,
      8,
      1,
      3,
      10,
      10,
      6,
      6,
      12,
      12,
      11,
      5,
      9,
      9,
      5,
      0,
      3,
      7,
      8,
      4,
      15,
      1,
      12,
      14,
      8,
      8,
      2,
      13,
      4,
      6,
      9,
      2,
      1,
      11,
      7,
      15,
      5,
      12,
      11,
      9,
      3,
      7,
      14,
      3,
      10,
      10,
      0,
      5,
      6,
      0,
      13,
      15,
      3,
      1,
      13,
      8,
      4,
      14,
      7,
      6,
      15,
      11,
      2,
      3,
      8,
      4,
      14,
      9,
      12,
      7,
      0,
      2,
      1,
      13,
      10,
      12,
      6,
      0,
      9,
      5,
      11,
      10,
      5,
      0,
      13,
      14,
      8,
      7,
      10,
      11,
      1,
      10,
      3,
      4,
      15,
      13,
      4,
      1,
      2,
      5,
      11,
      8,
      6,
      12,
      7,
      6,
      12,
      9,
      0,
      3,
      5,
      2,
      14,
      15,
      9,
      10,
      13,
      0,
      7,
      9,
      0,
      14,
      9,
      6,
      3,
      3,
      4,
      15,
      6,
      5,
      10,
      1,
      2,
      13,
      8,
      12,
      5,
      7,
      14,
      11,
      12,
      4,
      11,
      2,
      15,
      8,
      1,
      13,
      1,
      6,
      10,
      4,
      13,
      9,
      0,
      8,
      6,
      15,
      9,
      3,
      8,
      0,
      7,
      11,
      4,
      1,
      15,
      2,
      14,
      12,
      3,
      5,
      11,
      10,
      5,
      14,
      2,
      7,
      12,
      7,
      13,
      13,
      8,
      14,
      11,
      3,
      5,
      0,
      6,
      6,
      15,
      9,
      0,
      10,
      3,
      1,
      4,
      2,
      7,
      8,
      2,
      5,
      12,
      11,
      1,
      12,
      10,
      4,
      14,
      15,
      9,
      10,
      3,
      6,
      15,
      9,
      0,
      0,
      6,
      12,
      10,
      11,
      1,
      7,
      13,
      13,
      8,
      15,
      9,
      1,
      4,
      3,
      5,
      14,
      11,
      5,
      12,
      2,
      7,
      8,
      2,
      4,
      14,
      2,
      14,
      12,
      11,
      4,
      2,
      1,
      12,
      7,
      4,
      10,
      7,
      11,
      13,
      6,
      1,
      8,
      5,
      5,
      0,
      3,
      15,
      15,
      10,
      13,
      3,
      0,
      9,
      14,
      8,
      9,
      6,
      4,
      11,
      2,
      8,
      1,
      12,
      11,
      7,
      10,
      1,
      13,
      14,
      7,
      2,
      8,
      13,
      15,
      6,
      9,
      15,
      12,
      0,
      5,
      9,
      6,
      10,
      3,
      4,
      0,
      5,
      14,
      3,
      12,
      10,
      1,
      15,
      10,
      4,
      15,
      2,
      9,
      7,
      2,
      12,
      6,
      9,
      8,
      5,
      0,
      6,
      13,
      1,
      3,
      13,
      4,
      14,
      14,
      0,
      7,
      11,
      5,
      3,
      11,
      8,
      9,
      4,
      14,
      3,
      15,
      2,
      5,
      12,
      2,
      9,
      8,
      5,
      12,
      15,
      3,
      10,
      7,
      11,
      0,
      14,
      4,
      1,
      10,
      7,
      1,
      6,
      13,
      0,
      11,
      8,
      6,
      13,
      4,
      13,
      11,
      0,
      2,
      11,
      14,
      7,
      15,
      4,
      0,
      9,
      8,
      1,
      13,
      10,
      3,
      14,
      12,
      3,
      9,
      5,
      7,
      12,
      5,
      2,
      10,
      15,
      6,
      8,
      1,
      6,
      1,
      6,
      4,
      11,
      11,
      13,
      13,
      8,
      12,
      1,
      3,
      4,
      7,
      10,
      14,
      7,
      10,
      9,
      15,
      5,
      6,
      0,
      8,
      15,
      0,
      14,
      5,
      2,
      9,
      3,
      2,
      12,
      13,
      1,
      2,
      15,
      8,
      13,
      4,
      8,
      6,
      10,
      15,
      3,
      11,
      7,
      1,
      4,
      10,
      12,
      9,
      5,
      3,
      6,
      14,
      11,
      5,
      0,
      0,
      14,
      12,
      9,
      7,
      2,
      7,
      2,
      11,
      1,
      4,
      14,
      1,
      7,
      9,
      4,
      12,
      10,
      14,
      8,
      2,
      13,
      0,
      15,
      6,
      12,
      10,
      9,
      13,
      0,
      15,
      3,
      3,
      5,
      5,
      6,
      8,
      11
    ];
    exports.substitute = function substitute(inL, inR) {
      var out = 0;
      for (var i5 = 0; i5 < 4; i5++) {
        var b4 = inL >>> 18 - i5 * 6 & 63;
        var sb = sTable[i5 * 64 + b4];
        out <<= 4;
        out |= sb;
      }
      for (var i5 = 0; i5 < 4; i5++) {
        var b4 = inR >>> 18 - i5 * 6 & 63;
        var sb = sTable[4 * 64 + i5 * 64 + b4];
        out <<= 4;
        out |= sb;
      }
      return out >>> 0;
    };
    var permuteTable = [
      16,
      25,
      12,
      11,
      3,
      20,
      4,
      15,
      31,
      17,
      9,
      6,
      27,
      14,
      1,
      22,
      30,
      24,
      8,
      18,
      0,
      5,
      29,
      23,
      13,
      19,
      2,
      26,
      10,
      21,
      28,
      7
    ];
    exports.permute = function permute(num) {
      var out = 0;
      for (var i5 = 0; i5 < permuteTable.length; i5++) {
        out <<= 1;
        out |= num >>> permuteTable[i5] & 1;
      }
      return out >>> 0;
    };
    exports.padSplit = function padSplit(num, size, group) {
      var str = num.toString(2);
      while (str.length < size)
        str = "0" + str;
      var out = [];
      for (var i5 = 0; i5 < size; i5 += group)
        out.push(str.slice(i5, i5 + group));
      return out.join(" ");
    };
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = assert3;
    function assert3(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert3.equal = function assertEqual(l5, r6, msg) {
      if (l5 != r6)
        throw new Error(msg || "Assertion failed: " + l5 + " != " + r6);
    };
  }
});

// node_modules/des.js/lib/des/cipher.js
var require_cipher = __commonJS({
  "node_modules/des.js/lib/des/cipher.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var assert3 = require_minimalistic_assert();
    function Cipher(options) {
      this.options = options;
      this.type = this.options.type;
      this.blockSize = 8;
      this._init();
      this.buffer = new Array(this.blockSize);
      this.bufferOff = 0;
    }
    module.exports = Cipher;
    Cipher.prototype._init = function _init() {
    };
    Cipher.prototype.update = function update(data) {
      if (data.length === 0)
        return [];
      if (this.type === "decrypt")
        return this._updateDecrypt(data);
      else
        return this._updateEncrypt(data);
    };
    Cipher.prototype._buffer = function _buffer(data, off3) {
      var min2 = Math.min(this.buffer.length - this.bufferOff, data.length - off3);
      for (var i5 = 0; i5 < min2; i5++)
        this.buffer[this.bufferOff + i5] = data[off3 + i5];
      this.bufferOff += min2;
      return min2;
    };
    Cipher.prototype._flushBuffer = function _flushBuffer(out, off3) {
      this._update(this.buffer, 0, out, off3);
      this.bufferOff = 0;
      return this.blockSize;
    };
    Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count2 = (this.bufferOff + data.length) / this.blockSize | 0;
      var out = new Array(count2 * this.blockSize);
      if (this.bufferOff !== 0) {
        inputOff += this._buffer(data, inputOff);
        if (this.bufferOff === this.buffer.length)
          outputOff += this._flushBuffer(out, outputOff);
      }
      var max2 = data.length - (data.length - inputOff) % this.blockSize;
      for (; inputOff < max2; inputOff += this.blockSize) {
        this._update(data, inputOff, out, outputOff);
        outputOff += this.blockSize;
      }
      for (; inputOff < data.length; inputOff++, this.bufferOff++)
        this.buffer[this.bufferOff] = data[inputOff];
      return out;
    };
    Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count2 = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
      var out = new Array(count2 * this.blockSize);
      for (; count2 > 0; count2--) {
        inputOff += this._buffer(data, inputOff);
        outputOff += this._flushBuffer(out, outputOff);
      }
      inputOff += this._buffer(data, inputOff);
      return out;
    };
    Cipher.prototype.final = function final(buffer2) {
      var first2;
      if (buffer2)
        first2 = this.update(buffer2);
      var last2;
      if (this.type === "encrypt")
        last2 = this._finalEncrypt();
      else
        last2 = this._finalDecrypt();
      if (first2)
        return first2.concat(last2);
      else
        return last2;
    };
    Cipher.prototype._pad = function _pad(buffer2, off3) {
      if (off3 === 0)
        return false;
      while (off3 < buffer2.length)
        buffer2[off3++] = 0;
      return true;
    };
    Cipher.prototype._finalEncrypt = function _finalEncrypt() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var out = new Array(this.blockSize);
      this._update(this.buffer, 0, out, 0);
      return out;
    };
    Cipher.prototype._unpad = function _unpad(buffer2) {
      return buffer2;
    };
    Cipher.prototype._finalDecrypt = function _finalDecrypt() {
      assert3.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var out = new Array(this.blockSize);
      this._flushBuffer(out, 0);
      return this._unpad(out);
    };
  }
});

// node_modules/des.js/lib/des/des.js
var require_des = __commonJS({
  "node_modules/des.js/lib/des/des.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var assert3 = require_minimalistic_assert();
    var inherits2 = require_inherits_browser();
    var utils = require_utils();
    var Cipher = require_cipher();
    function DESState() {
      this.tmp = new Array(2);
      this.keys = null;
    }
    function DES(options) {
      Cipher.call(this, options);
      var state = new DESState();
      this._desState = state;
      this.deriveKeys(state, options.key);
    }
    inherits2(DES, Cipher);
    module.exports = DES;
    DES.create = function create(options) {
      return new DES(options);
    };
    var shiftTable = [
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1
    ];
    DES.prototype.deriveKeys = function deriveKeys(state, key) {
      state.keys = new Array(16 * 2);
      assert3.equal(key.length, this.blockSize, "Invalid key length");
      var kL = utils.readUInt32BE(key, 0);
      var kR = utils.readUInt32BE(key, 4);
      utils.pc1(kL, kR, state.tmp, 0);
      kL = state.tmp[0];
      kR = state.tmp[1];
      for (var i5 = 0; i5 < state.keys.length; i5 += 2) {
        var shift = shiftTable[i5 >>> 1];
        kL = utils.r28shl(kL, shift);
        kR = utils.r28shl(kR, shift);
        utils.pc2(kL, kR, state.keys, i5);
      }
    };
    DES.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._desState;
      var l5 = utils.readUInt32BE(inp, inOff);
      var r6 = utils.readUInt32BE(inp, inOff + 4);
      utils.ip(l5, r6, state.tmp, 0);
      l5 = state.tmp[0];
      r6 = state.tmp[1];
      if (this.type === "encrypt")
        this._encrypt(state, l5, r6, state.tmp, 0);
      else
        this._decrypt(state, l5, r6, state.tmp, 0);
      l5 = state.tmp[0];
      r6 = state.tmp[1];
      utils.writeUInt32BE(out, l5, outOff);
      utils.writeUInt32BE(out, r6, outOff + 4);
    };
    DES.prototype._pad = function _pad(buffer2, off3) {
      var value = buffer2.length - off3;
      for (var i5 = off3; i5 < buffer2.length; i5++)
        buffer2[i5] = value;
      return true;
    };
    DES.prototype._unpad = function _unpad(buffer2) {
      var pad2 = buffer2[buffer2.length - 1];
      for (var i5 = buffer2.length - pad2; i5 < buffer2.length; i5++)
        assert3.equal(buffer2[i5], pad2);
      return buffer2.slice(0, buffer2.length - pad2);
    };
    DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off3) {
      var l5 = lStart;
      var r6 = rStart;
      for (var i5 = 0; i5 < state.keys.length; i5 += 2) {
        var keyL = state.keys[i5];
        var keyR = state.keys[i5 + 1];
        utils.expand(r6, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s5 = utils.substitute(keyL, keyR);
        var f5 = utils.permute(s5);
        var t5 = r6;
        r6 = (l5 ^ f5) >>> 0;
        l5 = t5;
      }
      utils.rip(r6, l5, out, off3);
    };
    DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off3) {
      var l5 = rStart;
      var r6 = lStart;
      for (var i5 = state.keys.length - 2; i5 >= 0; i5 -= 2) {
        var keyL = state.keys[i5];
        var keyR = state.keys[i5 + 1];
        utils.expand(l5, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s5 = utils.substitute(keyL, keyR);
        var f5 = utils.permute(s5);
        var t5 = l5;
        l5 = (r6 ^ f5) >>> 0;
        r6 = t5;
      }
      utils.rip(l5, r6, out, off3);
    };
  }
});

// node_modules/des.js/lib/des/cbc.js
var require_cbc = __commonJS({
  "node_modules/des.js/lib/des/cbc.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var assert3 = require_minimalistic_assert();
    var inherits2 = require_inherits_browser();
    var proto = {};
    function CBCState(iv) {
      assert3.equal(iv.length, 8, "Invalid IV length");
      this.iv = new Array(8);
      for (var i5 = 0; i5 < this.iv.length; i5++)
        this.iv[i5] = iv[i5];
    }
    function instantiate(Base) {
      function CBC(options) {
        Base.call(this, options);
        this._cbcInit();
      }
      inherits2(CBC, Base);
      var keys2 = Object.keys(proto);
      for (var i5 = 0; i5 < keys2.length; i5++) {
        var key = keys2[i5];
        CBC.prototype[key] = proto[key];
      }
      CBC.create = function create(options) {
        return new CBC(options);
      };
      return CBC;
    }
    exports.instantiate = instantiate;
    proto._cbcInit = function _cbcInit() {
      var state = new CBCState(this.options.iv);
      this._cbcState = state;
    };
    proto._update = function _update(inp, inOff, out, outOff) {
      var state = this._cbcState;
      var superProto = this.constructor.super_.prototype;
      var iv = state.iv;
      if (this.type === "encrypt") {
        for (var i5 = 0; i5 < this.blockSize; i5++)
          iv[i5] ^= inp[inOff + i5];
        superProto._update.call(this, iv, 0, out, outOff);
        for (var i5 = 0; i5 < this.blockSize; i5++)
          iv[i5] = out[outOff + i5];
      } else {
        superProto._update.call(this, inp, inOff, out, outOff);
        for (var i5 = 0; i5 < this.blockSize; i5++)
          out[outOff + i5] ^= iv[i5];
        for (var i5 = 0; i5 < this.blockSize; i5++)
          iv[i5] = inp[inOff + i5];
      }
    };
  }
});

// node_modules/des.js/lib/des/ede.js
var require_ede = __commonJS({
  "node_modules/des.js/lib/des/ede.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var assert3 = require_minimalistic_assert();
    var inherits2 = require_inherits_browser();
    var Cipher = require_cipher();
    var DES = require_des();
    function EDEState(type2, key) {
      assert3.equal(key.length, 24, "Invalid key length");
      var k1 = key.slice(0, 8);
      var k22 = key.slice(8, 16);
      var k32 = key.slice(16, 24);
      if (type2 === "encrypt") {
        this.ciphers = [
          DES.create({ type: "encrypt", key: k1 }),
          DES.create({ type: "decrypt", key: k22 }),
          DES.create({ type: "encrypt", key: k32 })
        ];
      } else {
        this.ciphers = [
          DES.create({ type: "decrypt", key: k32 }),
          DES.create({ type: "encrypt", key: k22 }),
          DES.create({ type: "decrypt", key: k1 })
        ];
      }
    }
    function EDE(options) {
      Cipher.call(this, options);
      var state = new EDEState(this.type, this.options.key);
      this._edeState = state;
    }
    inherits2(EDE, Cipher);
    module.exports = EDE;
    EDE.create = function create(options) {
      return new EDE(options);
    };
    EDE.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._edeState;
      state.ciphers[0]._update(inp, inOff, out, outOff);
      state.ciphers[1]._update(out, outOff, out, outOff);
      state.ciphers[2]._update(out, outOff, out, outOff);
    };
    EDE.prototype._pad = DES.prototype._pad;
    EDE.prototype._unpad = DES.prototype._unpad;
  }
});

// node_modules/des.js/lib/des.js
var require_des2 = __commonJS({
  "node_modules/des.js/lib/des.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports.utils = require_utils();
    exports.Cipher = require_cipher();
    exports.DES = require_des();
    exports.CBC = require_cbc();
    exports.EDE = require_ede();
  }
});

// node_modules/browserify-des/index.js
var require_browserify_des = __commonJS({
  "node_modules/browserify-des/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var CipherBase = require_cipher_base();
    var des = require_des2();
    var inherits2 = require_inherits_browser();
    var Buffer4 = require_safe_buffer().Buffer;
    var modes = {
      "des-ede3-cbc": des.CBC.instantiate(des.EDE),
      "des-ede3": des.EDE,
      "des-ede-cbc": des.CBC.instantiate(des.EDE),
      "des-ede": des.EDE,
      "des-cbc": des.CBC.instantiate(des.DES),
      "des-ecb": des.DES
    };
    modes.des = modes["des-cbc"];
    modes.des3 = modes["des-ede3-cbc"];
    module.exports = DES;
    inherits2(DES, CipherBase);
    function DES(opts) {
      CipherBase.call(this);
      var modeName = opts.mode.toLowerCase();
      var mode = modes[modeName];
      var type2;
      if (opts.decrypt) {
        type2 = "decrypt";
      } else {
        type2 = "encrypt";
      }
      var key = opts.key;
      if (!Buffer4.isBuffer(key)) {
        key = Buffer4.from(key);
      }
      if (modeName === "des-ede" || modeName === "des-ede-cbc") {
        key = Buffer4.concat([key, key.slice(0, 8)]);
      }
      var iv = opts.iv;
      if (!Buffer4.isBuffer(iv)) {
        iv = Buffer4.from(iv);
      }
      this._des = mode.create({
        key,
        iv,
        type: type2
      });
    }
    DES.prototype._update = function(data) {
      return Buffer4.from(this._des.update(data));
    };
    DES.prototype._final = function() {
      return Buffer4.from(this._des.final());
    };
  }
});

// node_modules/browserify-aes/modes/ecb.js
var require_ecb = __commonJS({
  "node_modules/browserify-aes/modes/ecb.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports.encrypt = function(self2, block) {
      return self2._cipher.encryptBlock(block);
    };
    exports.decrypt = function(self2, block) {
      return self2._cipher.decryptBlock(block);
    };
  }
});

// node_modules/buffer-xor/index.js
var require_buffer_xor = __commonJS({
  "node_modules/buffer-xor/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function xor(a5, b4) {
      var length = Math.min(a5.length, b4.length);
      var buffer2 = new Buffer2(length);
      for (var i5 = 0; i5 < length; ++i5) {
        buffer2[i5] = a5[i5] ^ b4[i5];
      }
      return buffer2;
    };
  }
});

// node_modules/browserify-aes/modes/cbc.js
var require_cbc2 = __commonJS({
  "node_modules/browserify-aes/modes/cbc.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var xor = require_buffer_xor();
    exports.encrypt = function(self2, block) {
      var data = xor(block, self2._prev);
      self2._prev = self2._cipher.encryptBlock(data);
      return self2._prev;
    };
    exports.decrypt = function(self2, block) {
      var pad2 = self2._prev;
      self2._prev = block;
      var out = self2._cipher.decryptBlock(block);
      return xor(out, pad2);
    };
  }
});

// node_modules/browserify-aes/modes/cfb.js
var require_cfb = __commonJS({
  "node_modules/browserify-aes/modes/cfb.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var xor = require_buffer_xor();
    function encryptStart(self2, data, decrypt2) {
      var len = data.length;
      var out = xor(data, self2._cache);
      self2._cache = self2._cache.slice(len);
      self2._prev = Buffer4.concat([self2._prev, decrypt2 ? data : out]);
      return out;
    }
    exports.encrypt = function(self2, data, decrypt2) {
      var out = Buffer4.allocUnsafe(0);
      var len;
      while (data.length) {
        if (self2._cache.length === 0) {
          self2._cache = self2._cipher.encryptBlock(self2._prev);
          self2._prev = Buffer4.allocUnsafe(0);
        }
        if (self2._cache.length <= data.length) {
          len = self2._cache.length;
          out = Buffer4.concat([out, encryptStart(self2, data.slice(0, len), decrypt2)]);
          data = data.slice(len);
        } else {
          out = Buffer4.concat([out, encryptStart(self2, data, decrypt2)]);
          break;
        }
      }
      return out;
    };
  }
});

// node_modules/browserify-aes/modes/cfb8.js
var require_cfb8 = __commonJS({
  "node_modules/browserify-aes/modes/cfb8.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    function encryptByte(self2, byteParam, decrypt2) {
      var pad2 = self2._cipher.encryptBlock(self2._prev);
      var out = pad2[0] ^ byteParam;
      self2._prev = Buffer4.concat([
        self2._prev.slice(1),
        Buffer4.from([decrypt2 ? byteParam : out])
      ]);
      return out;
    }
    exports.encrypt = function(self2, chunk, decrypt2) {
      var len = chunk.length;
      var out = Buffer4.allocUnsafe(len);
      var i5 = -1;
      while (++i5 < len) {
        out[i5] = encryptByte(self2, chunk[i5], decrypt2);
      }
      return out;
    };
  }
});

// node_modules/browserify-aes/modes/cfb1.js
var require_cfb1 = __commonJS({
  "node_modules/browserify-aes/modes/cfb1.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    function encryptByte(self2, byteParam, decrypt2) {
      var pad2;
      var i5 = -1;
      var len = 8;
      var out = 0;
      var bit, value;
      while (++i5 < len) {
        pad2 = self2._cipher.encryptBlock(self2._prev);
        bit = byteParam & 1 << 7 - i5 ? 128 : 0;
        value = pad2[0] ^ bit;
        out += (value & 128) >> i5 % 8;
        self2._prev = shiftIn(self2._prev, decrypt2 ? bit : value);
      }
      return out;
    }
    function shiftIn(buffer2, value) {
      var len = buffer2.length;
      var i5 = -1;
      var out = Buffer4.allocUnsafe(buffer2.length);
      buffer2 = Buffer4.concat([buffer2, Buffer4.from([value])]);
      while (++i5 < len) {
        out[i5] = buffer2[i5] << 1 | buffer2[i5 + 1] >> 7;
      }
      return out;
    }
    exports.encrypt = function(self2, chunk, decrypt2) {
      var len = chunk.length;
      var out = Buffer4.allocUnsafe(len);
      var i5 = -1;
      while (++i5 < len) {
        out[i5] = encryptByte(self2, chunk[i5], decrypt2);
      }
      return out;
    };
  }
});

// node_modules/browserify-aes/modes/ofb.js
var require_ofb = __commonJS({
  "node_modules/browserify-aes/modes/ofb.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var xor = require_buffer_xor();
    function getBlock(self2) {
      self2._prev = self2._cipher.encryptBlock(self2._prev);
      return self2._prev;
    }
    exports.encrypt = function(self2, chunk) {
      while (self2._cache.length < chunk.length) {
        self2._cache = Buffer2.concat([self2._cache, getBlock(self2)]);
      }
      var pad2 = self2._cache.slice(0, chunk.length);
      self2._cache = self2._cache.slice(chunk.length);
      return xor(chunk, pad2);
    };
  }
});

// node_modules/browserify-aes/incr32.js
var require_incr32 = __commonJS({
  "node_modules/browserify-aes/incr32.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function incr32(iv) {
      var len = iv.length;
      var item;
      while (len--) {
        item = iv.readUInt8(len);
        if (item === 255) {
          iv.writeUInt8(0, len);
        } else {
          item++;
          iv.writeUInt8(item, len);
          break;
        }
      }
    }
    module.exports = incr32;
  }
});

// node_modules/browserify-aes/modes/ctr.js
var require_ctr = __commonJS({
  "node_modules/browserify-aes/modes/ctr.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var xor = require_buffer_xor();
    var Buffer4 = require_safe_buffer().Buffer;
    var incr32 = require_incr32();
    function getBlock(self2) {
      var out = self2._cipher.encryptBlockRaw(self2._prev);
      incr32(self2._prev);
      return out;
    }
    var blockSize = 16;
    exports.encrypt = function(self2, chunk) {
      var chunkNum = Math.ceil(chunk.length / blockSize);
      var start = self2._cache.length;
      self2._cache = Buffer4.concat([
        self2._cache,
        Buffer4.allocUnsafe(chunkNum * blockSize)
      ]);
      for (var i5 = 0; i5 < chunkNum; i5++) {
        var out = getBlock(self2);
        var offset = start + i5 * blockSize;
        self2._cache.writeUInt32BE(out[0], offset + 0);
        self2._cache.writeUInt32BE(out[1], offset + 4);
        self2._cache.writeUInt32BE(out[2], offset + 8);
        self2._cache.writeUInt32BE(out[3], offset + 12);
      }
      var pad2 = self2._cache.slice(0, chunk.length);
      self2._cache = self2._cache.slice(chunk.length);
      return xor(chunk, pad2);
    };
  }
});

// node_modules/browserify-aes/modes/list.json
var require_list = __commonJS({
  "node_modules/browserify-aes/modes/list.json"(exports, module) {
    module.exports = {
      "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes128: {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes192: {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes256: {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
      },
      "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
      },
      "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
      }
    };
  }
});

// node_modules/browserify-aes/modes/index.js
var require_modes = __commonJS({
  "node_modules/browserify-aes/modes/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var modeModules = {
      ECB: require_ecb(),
      CBC: require_cbc2(),
      CFB: require_cfb(),
      CFB8: require_cfb8(),
      CFB1: require_cfb1(),
      OFB: require_ofb(),
      CTR: require_ctr(),
      GCM: require_ctr()
    };
    var modes = require_list();
    for (key in modes) {
      modes[key].module = modeModules[modes[key].mode];
    }
    var key;
    module.exports = modes;
  }
});

// node_modules/browserify-aes/aes.js
var require_aes = __commonJS({
  "node_modules/browserify-aes/aes.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    function asUInt32Array(buf) {
      if (!Buffer4.isBuffer(buf))
        buf = Buffer4.from(buf);
      var len = buf.length / 4 | 0;
      var out = new Array(len);
      for (var i5 = 0; i5 < len; i5++) {
        out[i5] = buf.readUInt32BE(i5 * 4);
      }
      return out;
    }
    function scrubVec(v5) {
      for (var i5 = 0; i5 < v5.length; v5++) {
        v5[i5] = 0;
      }
    }
    function cryptBlock(M4, keySchedule, SUB_MIX, SBOX, nRounds) {
      var SUB_MIX0 = SUB_MIX[0];
      var SUB_MIX1 = SUB_MIX[1];
      var SUB_MIX2 = SUB_MIX[2];
      var SUB_MIX3 = SUB_MIX[3];
      var s0 = M4[0] ^ keySchedule[0];
      var s1 = M4[1] ^ keySchedule[1];
      var s22 = M4[2] ^ keySchedule[2];
      var s32 = M4[3] ^ keySchedule[3];
      var t0, t1, t22, t32;
      var ksRow = 4;
      for (var round = 1; round < nRounds; round++) {
        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s22 >>> 8 & 255] ^ SUB_MIX3[s32 & 255] ^ keySchedule[ksRow++];
        t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s22 >>> 16 & 255] ^ SUB_MIX2[s32 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
        t22 = SUB_MIX0[s22 >>> 24] ^ SUB_MIX1[s32 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
        t32 = SUB_MIX0[s32 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s22 & 255] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s22 = t22;
        s32 = t32;
      }
      t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s22 >>> 8 & 255] << 8 | SBOX[s32 & 255]) ^ keySchedule[ksRow++];
      t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s22 >>> 16 & 255] << 16 | SBOX[s32 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
      t22 = (SBOX[s22 >>> 24] << 24 | SBOX[s32 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
      t32 = (SBOX[s32 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s22 & 255]) ^ keySchedule[ksRow++];
      t0 = t0 >>> 0;
      t1 = t1 >>> 0;
      t22 = t22 >>> 0;
      t32 = t32 >>> 0;
      return [t0, t1, t22, t32];
    }
    var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    var G2 = function() {
      var d5 = new Array(256);
      for (var j5 = 0; j5 < 256; j5++) {
        if (j5 < 128) {
          d5[j5] = j5 << 1;
        } else {
          d5[j5] = j5 << 1 ^ 283;
        }
      }
      var SBOX = [];
      var INV_SBOX = [];
      var SUB_MIX = [[], [], [], []];
      var INV_SUB_MIX = [[], [], [], []];
      var x5 = 0;
      var xi = 0;
      for (var i5 = 0; i5 < 256; ++i5) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 255 ^ 99;
        SBOX[x5] = sx;
        INV_SBOX[sx] = x5;
        var x22 = d5[x5];
        var x42 = d5[x22];
        var x8 = d5[x42];
        var t5 = d5[sx] * 257 ^ sx * 16843008;
        SUB_MIX[0][x5] = t5 << 24 | t5 >>> 8;
        SUB_MIX[1][x5] = t5 << 16 | t5 >>> 16;
        SUB_MIX[2][x5] = t5 << 8 | t5 >>> 24;
        SUB_MIX[3][x5] = t5;
        t5 = x8 * 16843009 ^ x42 * 65537 ^ x22 * 257 ^ x5 * 16843008;
        INV_SUB_MIX[0][sx] = t5 << 24 | t5 >>> 8;
        INV_SUB_MIX[1][sx] = t5 << 16 | t5 >>> 16;
        INV_SUB_MIX[2][sx] = t5 << 8 | t5 >>> 24;
        INV_SUB_MIX[3][sx] = t5;
        if (x5 === 0) {
          x5 = xi = 1;
        } else {
          x5 = x22 ^ d5[d5[d5[x8 ^ x22]]];
          xi ^= d5[d5[xi]];
        }
      }
      return {
        SBOX,
        INV_SBOX,
        SUB_MIX,
        INV_SUB_MIX
      };
    }();
    function AES(key) {
      this._key = asUInt32Array(key);
      this._reset();
    }
    AES.blockSize = 4 * 4;
    AES.keySize = 256 / 8;
    AES.prototype.blockSize = AES.blockSize;
    AES.prototype.keySize = AES.keySize;
    AES.prototype._reset = function() {
      var keyWords = this._key;
      var keySize = keyWords.length;
      var nRounds = keySize + 6;
      var ksRows = (nRounds + 1) * 4;
      var keySchedule = [];
      for (var k5 = 0; k5 < keySize; k5++) {
        keySchedule[k5] = keyWords[k5];
      }
      for (k5 = keySize; k5 < ksRows; k5++) {
        var t5 = keySchedule[k5 - 1];
        if (k5 % keySize === 0) {
          t5 = t5 << 8 | t5 >>> 24;
          t5 = G2.SBOX[t5 >>> 24] << 24 | G2.SBOX[t5 >>> 16 & 255] << 16 | G2.SBOX[t5 >>> 8 & 255] << 8 | G2.SBOX[t5 & 255];
          t5 ^= RCON[k5 / keySize | 0] << 24;
        } else if (keySize > 6 && k5 % keySize === 4) {
          t5 = G2.SBOX[t5 >>> 24] << 24 | G2.SBOX[t5 >>> 16 & 255] << 16 | G2.SBOX[t5 >>> 8 & 255] << 8 | G2.SBOX[t5 & 255];
        }
        keySchedule[k5] = keySchedule[k5 - keySize] ^ t5;
      }
      var invKeySchedule = [];
      for (var ik = 0; ik < ksRows; ik++) {
        var ksR = ksRows - ik;
        var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
        if (ik < 4 || ksR <= 4) {
          invKeySchedule[ik] = tt;
        } else {
          invKeySchedule[ik] = G2.INV_SUB_MIX[0][G2.SBOX[tt >>> 24]] ^ G2.INV_SUB_MIX[1][G2.SBOX[tt >>> 16 & 255]] ^ G2.INV_SUB_MIX[2][G2.SBOX[tt >>> 8 & 255]] ^ G2.INV_SUB_MIX[3][G2.SBOX[tt & 255]];
        }
      }
      this._nRounds = nRounds;
      this._keySchedule = keySchedule;
      this._invKeySchedule = invKeySchedule;
    };
    AES.prototype.encryptBlockRaw = function(M4) {
      M4 = asUInt32Array(M4);
      return cryptBlock(M4, this._keySchedule, G2.SUB_MIX, G2.SBOX, this._nRounds);
    };
    AES.prototype.encryptBlock = function(M4) {
      var out = this.encryptBlockRaw(M4);
      var buf = Buffer4.allocUnsafe(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[1], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[3], 12);
      return buf;
    };
    AES.prototype.decryptBlock = function(M4) {
      M4 = asUInt32Array(M4);
      var m1 = M4[1];
      M4[1] = M4[3];
      M4[3] = m1;
      var out = cryptBlock(M4, this._invKeySchedule, G2.INV_SUB_MIX, G2.INV_SBOX, this._nRounds);
      var buf = Buffer4.allocUnsafe(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[3], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[1], 12);
      return buf;
    };
    AES.prototype.scrub = function() {
      scrubVec(this._keySchedule);
      scrubVec(this._invKeySchedule);
      scrubVec(this._key);
    };
    module.exports.AES = AES;
  }
});

// node_modules/browserify-aes/ghash.js
var require_ghash = __commonJS({
  "node_modules/browserify-aes/ghash.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var ZEROES = Buffer4.alloc(16, 0);
    function toArray2(buf) {
      return [
        buf.readUInt32BE(0),
        buf.readUInt32BE(4),
        buf.readUInt32BE(8),
        buf.readUInt32BE(12)
      ];
    }
    function fromArray2(out) {
      var buf = Buffer4.allocUnsafe(16);
      buf.writeUInt32BE(out[0] >>> 0, 0);
      buf.writeUInt32BE(out[1] >>> 0, 4);
      buf.writeUInt32BE(out[2] >>> 0, 8);
      buf.writeUInt32BE(out[3] >>> 0, 12);
      return buf;
    }
    function GHASH(key) {
      this.h = key;
      this.state = Buffer4.alloc(16, 0);
      this.cache = Buffer4.allocUnsafe(0);
    }
    GHASH.prototype.ghash = function(block) {
      var i5 = -1;
      while (++i5 < block.length) {
        this.state[i5] ^= block[i5];
      }
      this._multiply();
    };
    GHASH.prototype._multiply = function() {
      var Vi = toArray2(this.h);
      var Zi = [0, 0, 0, 0];
      var j5, xi, lsbVi;
      var i5 = -1;
      while (++i5 < 128) {
        xi = (this.state[~~(i5 / 8)] & 1 << 7 - i5 % 8) !== 0;
        if (xi) {
          Zi[0] ^= Vi[0];
          Zi[1] ^= Vi[1];
          Zi[2] ^= Vi[2];
          Zi[3] ^= Vi[3];
        }
        lsbVi = (Vi[3] & 1) !== 0;
        for (j5 = 3; j5 > 0; j5--) {
          Vi[j5] = Vi[j5] >>> 1 | (Vi[j5 - 1] & 1) << 31;
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsbVi) {
          Vi[0] = Vi[0] ^ 225 << 24;
        }
      }
      this.state = fromArray2(Zi);
    };
    GHASH.prototype.update = function(buf) {
      this.cache = Buffer4.concat([this.cache, buf]);
      var chunk;
      while (this.cache.length >= 16) {
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
      }
    };
    GHASH.prototype.final = function(abl, bl) {
      if (this.cache.length) {
        this.ghash(Buffer4.concat([this.cache, ZEROES], 16));
      }
      this.ghash(fromArray2([0, abl, 0, bl]));
      return this.state;
    };
    module.exports = GHASH;
  }
});

// node_modules/browserify-aes/authCipher.js
var require_authCipher = __commonJS({
  "node_modules/browserify-aes/authCipher.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var aes = require_aes();
    var Buffer4 = require_safe_buffer().Buffer;
    var Transform2 = require_cipher_base();
    var inherits2 = require_inherits_browser();
    var GHASH = require_ghash();
    var xor = require_buffer_xor();
    var incr32 = require_incr32();
    function xorTest(a5, b4) {
      var out = 0;
      if (a5.length !== b4.length)
        out++;
      var len = Math.min(a5.length, b4.length);
      for (var i5 = 0; i5 < len; ++i5) {
        out += a5[i5] ^ b4[i5];
      }
      return out;
    }
    function calcIv(self2, iv, ck) {
      if (iv.length === 12) {
        self2._finID = Buffer4.concat([iv, Buffer4.from([0, 0, 0, 1])]);
        return Buffer4.concat([iv, Buffer4.from([0, 0, 0, 2])]);
      }
      var ghash = new GHASH(ck);
      var len = iv.length;
      var toPad = len % 16;
      ghash.update(iv);
      if (toPad) {
        toPad = 16 - toPad;
        ghash.update(Buffer4.alloc(toPad, 0));
      }
      ghash.update(Buffer4.alloc(8, 0));
      var ivBits = len * 8;
      var tail = Buffer4.alloc(8);
      tail.writeUIntBE(ivBits, 0, 8);
      ghash.update(tail);
      self2._finID = ghash.state;
      var out = Buffer4.from(self2._finID);
      incr32(out);
      return out;
    }
    function StreamCipher(mode, key, iv, decrypt2) {
      Transform2.call(this);
      var h5 = Buffer4.alloc(4, 0);
      this._cipher = new aes.AES(key);
      var ck = this._cipher.encryptBlock(h5);
      this._ghash = new GHASH(ck);
      iv = calcIv(this, iv, ck);
      this._prev = Buffer4.from(iv);
      this._cache = Buffer4.allocUnsafe(0);
      this._secCache = Buffer4.allocUnsafe(0);
      this._decrypt = decrypt2;
      this._alen = 0;
      this._len = 0;
      this._mode = mode;
      this._authTag = null;
      this._called = false;
    }
    inherits2(StreamCipher, Transform2);
    StreamCipher.prototype._update = function(chunk) {
      if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
          rump = Buffer4.alloc(rump, 0);
          this._ghash.update(rump);
        }
      }
      this._called = true;
      var out = this._mode.encrypt(this, chunk);
      if (this._decrypt) {
        this._ghash.update(chunk);
      } else {
        this._ghash.update(out);
      }
      this._len += chunk.length;
      return out;
    };
    StreamCipher.prototype._final = function() {
      if (this._decrypt && !this._authTag)
        throw new Error("Unsupported state or unable to authenticate data");
      var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && xorTest(tag, this._authTag))
        throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = tag;
      this._cipher.scrub();
    };
    StreamCipher.prototype.getAuthTag = function getAuthTag() {
      if (this._decrypt || !Buffer4.isBuffer(this._authTag))
        throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
      if (!this._decrypt)
        throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = tag;
    };
    StreamCipher.prototype.setAAD = function setAAD(buf) {
      if (this._called)
        throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(buf);
      this._alen += buf.length;
    };
    module.exports = StreamCipher;
  }
});

// node_modules/browserify-aes/streamCipher.js
var require_streamCipher = __commonJS({
  "node_modules/browserify-aes/streamCipher.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var aes = require_aes();
    var Buffer4 = require_safe_buffer().Buffer;
    var Transform2 = require_cipher_base();
    var inherits2 = require_inherits_browser();
    function StreamCipher(mode, key, iv, decrypt2) {
      Transform2.call(this);
      this._cipher = new aes.AES(key);
      this._prev = Buffer4.from(iv);
      this._cache = Buffer4.allocUnsafe(0);
      this._secCache = Buffer4.allocUnsafe(0);
      this._decrypt = decrypt2;
      this._mode = mode;
    }
    inherits2(StreamCipher, Transform2);
    StreamCipher.prototype._update = function(chunk) {
      return this._mode.encrypt(this, chunk, this._decrypt);
    };
    StreamCipher.prototype._final = function() {
      this._cipher.scrub();
    };
    module.exports = StreamCipher;
  }
});

// node_modules/evp_bytestokey/index.js
var require_evp_bytestokey = __commonJS({
  "node_modules/evp_bytestokey/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var MD5 = require_md5();
    function EVP_BytesToKey(password, salt, keyBits, ivLen) {
      if (!Buffer4.isBuffer(password))
        password = Buffer4.from(password, "binary");
      if (salt) {
        if (!Buffer4.isBuffer(salt))
          salt = Buffer4.from(salt, "binary");
        if (salt.length !== 8)
          throw new RangeError("salt should be Buffer with 8 byte length");
      }
      var keyLen = keyBits / 8;
      var key = Buffer4.alloc(keyLen);
      var iv = Buffer4.alloc(ivLen || 0);
      var tmp = Buffer4.alloc(0);
      while (keyLen > 0 || ivLen > 0) {
        var hash = new MD5();
        hash.update(tmp);
        hash.update(password);
        if (salt)
          hash.update(salt);
        tmp = hash.digest();
        var used = 0;
        if (keyLen > 0) {
          var keyStart = key.length - keyLen;
          used = Math.min(keyLen, tmp.length);
          tmp.copy(key, keyStart, 0, used);
          keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
          var ivStart = iv.length - ivLen;
          var length = Math.min(ivLen, tmp.length - used);
          tmp.copy(iv, ivStart, used, used + length);
          ivLen -= length;
        }
      }
      tmp.fill(0);
      return { key, iv };
    }
    module.exports = EVP_BytesToKey;
  }
});

// node_modules/browserify-aes/encrypter.js
var require_encrypter = __commonJS({
  "node_modules/browserify-aes/encrypter.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var MODES = require_modes();
    var AuthCipher = require_authCipher();
    var Buffer4 = require_safe_buffer().Buffer;
    var StreamCipher = require_streamCipher();
    var Transform2 = require_cipher_base();
    var aes = require_aes();
    var ebtk = require_evp_bytestokey();
    var inherits2 = require_inherits_browser();
    function Cipher(mode, key, iv) {
      Transform2.call(this);
      this._cache = new Splitter();
      this._cipher = new aes.AES(key);
      this._prev = Buffer4.from(iv);
      this._mode = mode;
      this._autopadding = true;
    }
    inherits2(Cipher, Transform2);
    Cipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get()) {
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
      }
      return Buffer4.concat(out);
    };
    var PADDING2 = Buffer4.alloc(16, 16);
    Cipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
      }
      if (!chunk.equals(PADDING2)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
      }
    };
    Cipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      this.cache = Buffer4.allocUnsafe(0);
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer4.concat([this.cache, data]);
    };
    Splitter.prototype.get = function() {
      if (this.cache.length > 15) {
        var out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      var len = 16 - this.cache.length;
      var padBuff = Buffer4.allocUnsafe(len);
      var i5 = -1;
      while (++i5 < len) {
        padBuff.writeUInt8(len, i5);
      }
      return Buffer4.concat([this.cache, padBuff]);
    };
    function createCipheriv(suite, password, iv) {
      var config4 = MODES[suite.toLowerCase()];
      if (!config4)
        throw new TypeError("invalid suite type");
      if (typeof password === "string")
        password = Buffer4.from(password);
      if (password.length !== config4.key / 8)
        throw new TypeError("invalid key length " + password.length);
      if (typeof iv === "string")
        iv = Buffer4.from(iv);
      if (config4.mode !== "GCM" && iv.length !== config4.iv)
        throw new TypeError("invalid iv length " + iv.length);
      if (config4.type === "stream") {
        return new StreamCipher(config4.module, password, iv);
      } else if (config4.type === "auth") {
        return new AuthCipher(config4.module, password, iv);
      }
      return new Cipher(config4.module, password, iv);
    }
    function createCipher(suite, password) {
      var config4 = MODES[suite.toLowerCase()];
      if (!config4)
        throw new TypeError("invalid suite type");
      var keys2 = ebtk(password, false, config4.key, config4.iv);
      return createCipheriv(suite, keys2.key, keys2.iv);
    }
    exports.createCipheriv = createCipheriv;
    exports.createCipher = createCipher;
  }
});

// node_modules/browserify-aes/decrypter.js
var require_decrypter = __commonJS({
  "node_modules/browserify-aes/decrypter.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var AuthCipher = require_authCipher();
    var Buffer4 = require_safe_buffer().Buffer;
    var MODES = require_modes();
    var StreamCipher = require_streamCipher();
    var Transform2 = require_cipher_base();
    var aes = require_aes();
    var ebtk = require_evp_bytestokey();
    var inherits2 = require_inherits_browser();
    function Decipher(mode, key, iv) {
      Transform2.call(this);
      this._cache = new Splitter();
      this._last = void 0;
      this._cipher = new aes.AES(key);
      this._prev = Buffer4.from(iv);
      this._mode = mode;
      this._autopadding = true;
    }
    inherits2(Decipher, Transform2);
    Decipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get(this._autopadding)) {
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
      }
      return Buffer4.concat(out);
    };
    Decipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
      } else if (chunk) {
        throw new Error("data not multiple of block length");
      }
    };
    Decipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      this.cache = Buffer4.allocUnsafe(0);
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer4.concat([this.cache, data]);
    };
    Splitter.prototype.get = function(autoPadding) {
      var out;
      if (autoPadding) {
        if (this.cache.length > 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      } else {
        if (this.cache.length >= 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      if (this.cache.length)
        return this.cache;
    };
    function unpad(last2) {
      var padded = last2[15];
      if (padded < 1 || padded > 16) {
        throw new Error("unable to decrypt data");
      }
      var i5 = -1;
      while (++i5 < padded) {
        if (last2[i5 + (16 - padded)] !== padded) {
          throw new Error("unable to decrypt data");
        }
      }
      if (padded === 16)
        return;
      return last2.slice(0, 16 - padded);
    }
    function createDecipheriv(suite, password, iv) {
      var config4 = MODES[suite.toLowerCase()];
      if (!config4)
        throw new TypeError("invalid suite type");
      if (typeof iv === "string")
        iv = Buffer4.from(iv);
      if (config4.mode !== "GCM" && iv.length !== config4.iv)
        throw new TypeError("invalid iv length " + iv.length);
      if (typeof password === "string")
        password = Buffer4.from(password);
      if (password.length !== config4.key / 8)
        throw new TypeError("invalid key length " + password.length);
      if (config4.type === "stream") {
        return new StreamCipher(config4.module, password, iv, true);
      } else if (config4.type === "auth") {
        return new AuthCipher(config4.module, password, iv, true);
      }
      return new Decipher(config4.module, password, iv);
    }
    function createDecipher(suite, password) {
      var config4 = MODES[suite.toLowerCase()];
      if (!config4)
        throw new TypeError("invalid suite type");
      var keys2 = ebtk(password, false, config4.key, config4.iv);
      return createDecipheriv(suite, keys2.key, keys2.iv);
    }
    exports.createDecipher = createDecipher;
    exports.createDecipheriv = createDecipheriv;
  }
});

// node_modules/browserify-aes/browser.js
var require_browser6 = __commonJS({
  "node_modules/browserify-aes/browser.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ciphers = require_encrypter();
    var deciphers = require_decrypter();
    var modes = require_list();
    function getCiphers() {
      return Object.keys(modes);
    }
    exports.createCipher = exports.Cipher = ciphers.createCipher;
    exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
    exports.createDecipher = exports.Decipher = deciphers.createDecipher;
    exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
    exports.listCiphers = exports.getCiphers = getCiphers;
  }
});

// node_modules/browserify-des/modes.js
var require_modes2 = __commonJS({
  "node_modules/browserify-des/modes.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports["des-ecb"] = {
      key: 8,
      iv: 0
    };
    exports["des-cbc"] = exports.des = {
      key: 8,
      iv: 8
    };
    exports["des-ede3-cbc"] = exports.des3 = {
      key: 24,
      iv: 8
    };
    exports["des-ede3"] = {
      key: 24,
      iv: 0
    };
    exports["des-ede-cbc"] = {
      key: 16,
      iv: 8
    };
    exports["des-ede"] = {
      key: 16,
      iv: 0
    };
  }
});

// node_modules/browserify-cipher/browser.js
var require_browser7 = __commonJS({
  "node_modules/browserify-cipher/browser.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var DES = require_browserify_des();
    var aes = require_browser6();
    var aesModes = require_modes();
    var desModes = require_modes2();
    var ebtk = require_evp_bytestokey();
    function createCipher(suite, password) {
      suite = suite.toLowerCase();
      var keyLen, ivLen;
      if (aesModes[suite]) {
        keyLen = aesModes[suite].key;
        ivLen = aesModes[suite].iv;
      } else if (desModes[suite]) {
        keyLen = desModes[suite].key * 8;
        ivLen = desModes[suite].iv;
      } else {
        throw new TypeError("invalid suite type");
      }
      var keys2 = ebtk(password, false, keyLen, ivLen);
      return createCipheriv(suite, keys2.key, keys2.iv);
    }
    function createDecipher(suite, password) {
      suite = suite.toLowerCase();
      var keyLen, ivLen;
      if (aesModes[suite]) {
        keyLen = aesModes[suite].key;
        ivLen = aesModes[suite].iv;
      } else if (desModes[suite]) {
        keyLen = desModes[suite].key * 8;
        ivLen = desModes[suite].iv;
      } else {
        throw new TypeError("invalid suite type");
      }
      var keys2 = ebtk(password, false, keyLen, ivLen);
      return createDecipheriv(suite, keys2.key, keys2.iv);
    }
    function createCipheriv(suite, key, iv) {
      suite = suite.toLowerCase();
      if (aesModes[suite])
        return aes.createCipheriv(suite, key, iv);
      if (desModes[suite])
        return new DES({ key, iv, mode: suite });
      throw new TypeError("invalid suite type");
    }
    function createDecipheriv(suite, key, iv) {
      suite = suite.toLowerCase();
      if (aesModes[suite])
        return aes.createDecipheriv(suite, key, iv);
      if (desModes[suite])
        return new DES({ key, iv, mode: suite, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function getCiphers() {
      return Object.keys(desModes).concat(aes.getCiphers());
    }
    exports.createCipher = exports.Cipher = createCipher;
    exports.createCipheriv = exports.Cipheriv = createCipheriv;
    exports.createDecipher = exports.Decipher = createDecipher;
    exports.createDecipheriv = exports.Decipheriv = createDecipheriv;
    exports.listCiphers = exports.getCiphers = getCiphers;
  }
});

// node_modules/diffie-hellman/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/diffie-hellman/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base2, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e5) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i5 = number.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number[i5] | number[i5 - 1] << 8 | number[i5 - 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number.length; i5 += 3) {
            w6 = number[i5] | number[i5 + 1] << 8 | number[i5 + 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off3 = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number.length; i5 += 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN2.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i5, number.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r6 = new BN2(null);
        this.copy(r6);
        return r6;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength3; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN2.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN2.prototype._countBits(N4) - 1;
        for (var i5 = 0; i5 < N4; i5++) {
          t5[i5] = this.revBin(i5, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i5 = 0; i5 < N4; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s5 = 1; s5 < N4; s5 <<= 1) {
          var l5 = s5 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s5; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s5];
              var io = itws[p5 + j5 + s5];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s5] = re - ro;
              itws[p5 + j5 + s5] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N4 = Math.max(m5, n3) | 1;
        var odd = N4 & 1;
        var i5 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N4 - i5 - 1];
          rws[N4 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N4 - i5 - 1];
          iws[N4 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N4) * 8192 + Math.round(ws[2 * i5] / N4) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N4; ++i5) {
          rws[i5] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i5 = 0; i5 < N4; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _6 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _6, rwst, iwst, N4, rbt);
        this.transform(nrws, _6, nrwst, niwst, N4, rbt);
        for (var i5 = 0; i5 < N4; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _6, N4, rbt);
        this.conjugate(rmws, _6, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN2(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s5 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s5] = this.words[i5];
          }
          for (i5 = 0; i5 < s5; i5++) {
            this.words[i5] = 0;
          }
          this.length += s5;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s5 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s5;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s5; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s5;
        }
        if (s5 === 0) {
        } else if (this.length > s5) {
          this.length -= s5;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s5];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5)
          return false;
        var w6 = this.words[s5];
        return !!(w6 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s5) {
          return this;
        }
        if (r6 !== 0) {
          s5++;
        }
        this.length = Math.min(s5, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN2(1);
        var B4 = new BN2(0);
        var C4 = new BN2(0);
        var D3 = new BN2(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B4.isOdd()) {
                A6.iadd(yp);
                B4.isub(xp);
              }
              A6.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D3.isOdd()) {
                C4.iadd(yp);
                D3.isub(xp);
              }
              C4.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B4.isub(D3);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D3.isub(B4);
          }
        }
        return {
          a: C4,
          b: D3,
          gcd: y5.iushln(g5)
        };
      };
      BN2.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5) {
          this._expand(s5 + 1);
          this.words[s5] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s5; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN2(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN2._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s5 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s5++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z5 = this.m.bitLength();
        z5 = new BN2(2 * z5 * z5).toRed(this);
        while (this.pow(z5, lpow).cmp(nOne) !== 0) {
          z5.redIAdd(nOne);
        }
        var c5 = this.pow(z5, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s5;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert3(i5 < m5);
          var b4 = this.pow(c5, new BN2(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/miller-rabin/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/miller-rabin/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base2, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e5) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i5 = number.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number[i5] | number[i5 - 1] << 8 | number[i5 - 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number.length; i5 += 3) {
            w6 = number[i5] | number[i5 + 1] << 8 | number[i5 + 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off3 = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number.length; i5 += 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN2.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i5, number.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r6 = new BN2(null);
        this.copy(r6);
        return r6;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength3; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN2.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN2.prototype._countBits(N4) - 1;
        for (var i5 = 0; i5 < N4; i5++) {
          t5[i5] = this.revBin(i5, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i5 = 0; i5 < N4; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s5 = 1; s5 < N4; s5 <<= 1) {
          var l5 = s5 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s5; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s5];
              var io = itws[p5 + j5 + s5];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s5] = re - ro;
              itws[p5 + j5 + s5] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N4 = Math.max(m5, n3) | 1;
        var odd = N4 & 1;
        var i5 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N4 - i5 - 1];
          rws[N4 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N4 - i5 - 1];
          iws[N4 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N4) * 8192 + Math.round(ws[2 * i5] / N4) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N4; ++i5) {
          rws[i5] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i5 = 0; i5 < N4; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _6 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _6, rwst, iwst, N4, rbt);
        this.transform(nrws, _6, nrwst, niwst, N4, rbt);
        for (var i5 = 0; i5 < N4; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _6, N4, rbt);
        this.conjugate(rmws, _6, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN2(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s5 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s5] = this.words[i5];
          }
          for (i5 = 0; i5 < s5; i5++) {
            this.words[i5] = 0;
          }
          this.length += s5;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s5 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s5;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s5; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s5;
        }
        if (s5 === 0) {
        } else if (this.length > s5) {
          this.length -= s5;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s5];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5)
          return false;
        var w6 = this.words[s5];
        return !!(w6 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s5) {
          return this;
        }
        if (r6 !== 0) {
          s5++;
        }
        this.length = Math.min(s5, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN2(1);
        var B4 = new BN2(0);
        var C4 = new BN2(0);
        var D3 = new BN2(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B4.isOdd()) {
                A6.iadd(yp);
                B4.isub(xp);
              }
              A6.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D3.isOdd()) {
                C4.iadd(yp);
                D3.isub(xp);
              }
              C4.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B4.isub(D3);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D3.isub(B4);
          }
        }
        return {
          a: C4,
          b: D3,
          gcd: y5.iushln(g5)
        };
      };
      BN2.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5) {
          this._expand(s5 + 1);
          this.words[s5] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s5; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN2(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN2._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s5 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s5++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z5 = this.m.bitLength();
        z5 = new BN2(2 * z5 * z5).toRed(this);
        while (this.pow(z5, lpow).cmp(nOne) !== 0) {
          z5.redIAdd(nOne);
        }
        var c5 = this.pow(z5, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s5;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert3(i5 < m5);
          var b4 = this.pow(c5, new BN2(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node-modules-polyfills:crypto
var crypto_exports = {};
__export(crypto_exports, {
  default: () => crypto_default
});
var crypto_default;
var init_crypto = __esm({
  "node-modules-polyfills:crypto"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    crypto_default = {};
  }
});

// node-modules-polyfills-commonjs:crypto
var require_crypto = __commonJS({
  "node-modules-polyfills-commonjs:crypto"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_crypto(), __toCommonJS(crypto_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var r6;
    module.exports = function rand(len) {
      if (!r6)
        r6 = new Rand(null);
      return r6.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate2(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n3) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n3);
      var res = new Uint8Array(n3);
      for (var i5 = 0; i5 < res.length; i5++)
        res[i5] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n3) {
          var arr = new Uint8Array(n3);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n3) {
          var arr = new Uint8Array(n3);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto3 = require_crypto();
        if (typeof crypto3.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n3) {
          return crypto3.randomBytes(n3);
        };
      } catch (e5) {
      }
    }
    var crypto3;
  }
});

// node_modules/miller-rabin/lib/mr.js
var require_mr = __commonJS({
  "node_modules/miller-rabin/lib/mr.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var bn = require_bn2();
    var brorand = require_brorand();
    function MillerRabin(rand) {
      this.rand = rand || new brorand.Rand();
    }
    module.exports = MillerRabin;
    MillerRabin.create = function create(rand) {
      return new MillerRabin(rand);
    };
    MillerRabin.prototype._randbelow = function _randbelow(n3) {
      var len = n3.bitLength();
      var min_bytes = Math.ceil(len / 8);
      do
        var a5 = new bn(this.rand.generate(min_bytes));
      while (a5.cmp(n3) >= 0);
      return a5;
    };
    MillerRabin.prototype._randrange = function _randrange(start, stop) {
      var size = stop.sub(start);
      return start.add(this._randbelow(size));
    };
    MillerRabin.prototype.test = function test(n3, k5, cb) {
      var len = n3.bitLength();
      var red = bn.mont(n3);
      var rone = new bn(1).toRed(red);
      if (!k5)
        k5 = Math.max(1, len / 48 | 0);
      var n1 = n3.subn(1);
      for (var s5 = 0; !n1.testn(s5); s5++) {
      }
      var d5 = n3.shrn(s5);
      var rn1 = n1.toRed(red);
      var prime = true;
      for (; k5 > 0; k5--) {
        var a5 = this._randrange(new bn(2), n1);
        if (cb)
          cb(a5);
        var x5 = a5.toRed(red).redPow(d5);
        if (x5.cmp(rone) === 0 || x5.cmp(rn1) === 0)
          continue;
        for (var i5 = 1; i5 < s5; i5++) {
          x5 = x5.redSqr();
          if (x5.cmp(rone) === 0)
            return false;
          if (x5.cmp(rn1) === 0)
            break;
        }
        if (i5 === s5)
          return false;
      }
      return prime;
    };
    MillerRabin.prototype.getDivisor = function getDivisor(n3, k5) {
      var len = n3.bitLength();
      var red = bn.mont(n3);
      var rone = new bn(1).toRed(red);
      if (!k5)
        k5 = Math.max(1, len / 48 | 0);
      var n1 = n3.subn(1);
      for (var s5 = 0; !n1.testn(s5); s5++) {
      }
      var d5 = n3.shrn(s5);
      var rn1 = n1.toRed(red);
      for (; k5 > 0; k5--) {
        var a5 = this._randrange(new bn(2), n1);
        var g5 = n3.gcd(a5);
        if (g5.cmpn(1) !== 0)
          return g5;
        var x5 = a5.toRed(red).redPow(d5);
        if (x5.cmp(rone) === 0 || x5.cmp(rn1) === 0)
          continue;
        for (var i5 = 1; i5 < s5; i5++) {
          x5 = x5.redSqr();
          if (x5.cmp(rone) === 0)
            return x5.fromRed().subn(1).gcd(n3);
          if (x5.cmp(rn1) === 0)
            break;
        }
        if (i5 === s5) {
          x5 = x5.redSqr();
          return x5.fromRed().subn(1).gcd(n3);
        }
      }
      return false;
    };
  }
});

// node_modules/diffie-hellman/lib/generatePrime.js
var require_generatePrime = __commonJS({
  "node_modules/diffie-hellman/lib/generatePrime.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var randomBytes2 = require_browser();
    module.exports = findPrime;
    findPrime.simpleSieve = simpleSieve;
    findPrime.fermatTest = fermatTest;
    var BN2 = require_bn();
    var TWENTYFOUR = new BN2(24);
    var MillerRabin = require_mr();
    var millerRabin = new MillerRabin();
    var ONE = new BN2(1);
    var TWO = new BN2(2);
    var FIVE = new BN2(5);
    var SIXTEEN = new BN2(16);
    var EIGHT = new BN2(8);
    var TEN = new BN2(10);
    var THREE = new BN2(3);
    var SEVEN = new BN2(7);
    var ELEVEN = new BN2(11);
    var FOUR = new BN2(4);
    var TWELVE = new BN2(12);
    var primes = null;
    function _getPrimes() {
      if (primes !== null)
        return primes;
      var limit = 1048576;
      var res = [];
      res[0] = 2;
      for (var i5 = 1, k5 = 3; k5 < limit; k5 += 2) {
        var sqrt = Math.ceil(Math.sqrt(k5));
        for (var j5 = 0; j5 < i5 && res[j5] <= sqrt; j5++)
          if (k5 % res[j5] === 0)
            break;
        if (i5 !== j5 && res[j5] <= sqrt)
          continue;
        res[i5++] = k5;
      }
      primes = res;
      return res;
    }
    function simpleSieve(p5) {
      var primes2 = _getPrimes();
      for (var i5 = 0; i5 < primes2.length; i5++)
        if (p5.modn(primes2[i5]) === 0) {
          if (p5.cmpn(primes2[i5]) === 0) {
            return true;
          } else {
            return false;
          }
        }
      return true;
    }
    function fermatTest(p5) {
      var red = BN2.mont(p5);
      return TWO.toRed(red).redPow(p5.subn(1)).fromRed().cmpn(1) === 0;
    }
    function findPrime(bits, gen) {
      if (bits < 16) {
        if (gen === 2 || gen === 5) {
          return new BN2([140, 123]);
        } else {
          return new BN2([140, 39]);
        }
      }
      gen = new BN2(gen);
      var num, n22;
      while (true) {
        num = new BN2(randomBytes2(Math.ceil(bits / 8)));
        while (num.bitLength() > bits) {
          num.ishrn(1);
        }
        if (num.isEven()) {
          num.iadd(ONE);
        }
        if (!num.testn(1)) {
          num.iadd(TWO);
        }
        if (!gen.cmp(TWO)) {
          while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
            num.iadd(FOUR);
          }
        } else if (!gen.cmp(FIVE)) {
          while (num.mod(TEN).cmp(THREE)) {
            num.iadd(FOUR);
          }
        }
        n22 = num.shrn(1);
        if (simpleSieve(n22) && simpleSieve(num) && fermatTest(n22) && fermatTest(num) && millerRabin.test(n22) && millerRabin.test(num)) {
          return num;
        }
      }
    }
  }
});

// node_modules/diffie-hellman/lib/primes.json
var require_primes = __commonJS({
  "node_modules/diffie-hellman/lib/primes.json"(exports, module) {
    module.exports = {
      modp1: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
      },
      modp2: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
      },
      modp5: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
      },
      modp14: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
      },
      modp15: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
      },
      modp16: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
      },
      modp17: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
      },
      modp18: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
      }
    };
  }
});

// node_modules/diffie-hellman/lib/dh.js
var require_dh = __commonJS({
  "node_modules/diffie-hellman/lib/dh.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BN2 = require_bn();
    var MillerRabin = require_mr();
    var millerRabin = new MillerRabin();
    var TWENTYFOUR = new BN2(24);
    var ELEVEN = new BN2(11);
    var TEN = new BN2(10);
    var THREE = new BN2(3);
    var SEVEN = new BN2(7);
    var primes = require_generatePrime();
    var randomBytes2 = require_browser();
    module.exports = DH;
    function setPublicKey(pub, enc) {
      enc = enc || "utf8";
      if (!Buffer2.isBuffer(pub)) {
        pub = new Buffer2(pub, enc);
      }
      this._pub = new BN2(pub);
      return this;
    }
    function setPrivateKey(priv, enc) {
      enc = enc || "utf8";
      if (!Buffer2.isBuffer(priv)) {
        priv = new Buffer2(priv, enc);
      }
      this._priv = new BN2(priv);
      return this;
    }
    var primeCache = {};
    function checkPrime(prime, generator) {
      var gen = generator.toString("hex");
      var hex = [gen, prime.toString(16)].join("_");
      if (hex in primeCache) {
        return primeCache[hex];
      }
      var error2 = 0;
      if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
        error2 += 1;
        if (gen === "02" || gen === "05") {
          error2 += 8;
        } else {
          error2 += 4;
        }
        primeCache[hex] = error2;
        return error2;
      }
      if (!millerRabin.test(prime.shrn(1))) {
        error2 += 2;
      }
      var rem;
      switch (gen) {
        case "02":
          if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
            error2 += 8;
          }
          break;
        case "05":
          rem = prime.mod(TEN);
          if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
            error2 += 8;
          }
          break;
        default:
          error2 += 4;
      }
      primeCache[hex] = error2;
      return error2;
    }
    function DH(prime, generator, malleable) {
      this.setGenerator(generator);
      this.__prime = new BN2(prime);
      this._prime = BN2.mont(this.__prime);
      this._primeLen = prime.length;
      this._pub = void 0;
      this._priv = void 0;
      this._primeCode = void 0;
      if (malleable) {
        this.setPublicKey = setPublicKey;
        this.setPrivateKey = setPrivateKey;
      } else {
        this._primeCode = 8;
      }
    }
    Object.defineProperty(DH.prototype, "verifyError", {
      enumerable: true,
      get: function() {
        if (typeof this._primeCode !== "number") {
          this._primeCode = checkPrime(this.__prime, this.__gen);
        }
        return this._primeCode;
      }
    });
    DH.prototype.generateKeys = function() {
      if (!this._priv) {
        this._priv = new BN2(randomBytes2(this._primeLen));
      }
      this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
      return this.getPublicKey();
    };
    DH.prototype.computeSecret = function(other) {
      other = new BN2(other);
      other = other.toRed(this._prime);
      var secret = other.redPow(this._priv).fromRed();
      var out = new Buffer2(secret.toArray());
      var prime = this.getPrime();
      if (out.length < prime.length) {
        var front = new Buffer2(prime.length - out.length);
        front.fill(0);
        out = Buffer2.concat([front, out]);
      }
      return out;
    };
    DH.prototype.getPublicKey = function getPublicKey(enc) {
      return formatReturnValue(this._pub, enc);
    };
    DH.prototype.getPrivateKey = function getPrivateKey(enc) {
      return formatReturnValue(this._priv, enc);
    };
    DH.prototype.getPrime = function(enc) {
      return formatReturnValue(this.__prime, enc);
    };
    DH.prototype.getGenerator = function(enc) {
      return formatReturnValue(this._gen, enc);
    };
    DH.prototype.setGenerator = function(gen, enc) {
      enc = enc || "utf8";
      if (!Buffer2.isBuffer(gen)) {
        gen = new Buffer2(gen, enc);
      }
      this.__gen = gen;
      this._gen = new BN2(gen);
      return this;
    };
    function formatReturnValue(bn, enc) {
      var buf = new Buffer2(bn.toArray());
      if (!enc) {
        return buf;
      } else {
        return buf.toString(enc);
      }
    }
  }
});

// node_modules/diffie-hellman/browser.js
var require_browser8 = __commonJS({
  "node_modules/diffie-hellman/browser.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var generatePrime = require_generatePrime();
    var primes = require_primes();
    var DH = require_dh();
    function getDiffieHellman(mod) {
      var prime = new Buffer2(primes[mod].prime, "hex");
      var gen = new Buffer2(primes[mod].gen, "hex");
      return new DH(prime, gen);
    }
    var ENCODINGS = {
      "binary": true,
      "hex": true,
      "base64": true
    };
    function createDiffieHellman(prime, enc, generator, genc) {
      if (Buffer2.isBuffer(enc) || ENCODINGS[enc] === void 0) {
        return createDiffieHellman(prime, "binary", enc, generator);
      }
      enc = enc || "binary";
      genc = genc || "binary";
      generator = generator || new Buffer2([2]);
      if (!Buffer2.isBuffer(generator)) {
        generator = new Buffer2(generator, genc);
      }
      if (typeof prime === "number") {
        return new DH(generatePrime(prime, generator), generator, true);
      }
      if (!Buffer2.isBuffer(prime)) {
        prime = new Buffer2(prime, enc);
      }
      return new DH(prime, generator, true);
    }
    exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
    exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        var source = arguments[i5] != null ? arguments[i5] : {};
        if (i5 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require_buffer();
    var Buffer4 = _require.Buffer;
    var _require2 = require_util();
    var inspect4 = _require2.inspect;
    var custom = inspect4 && inspect4.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer4.prototype.copy.call(src, target, offset);
    }
    module.exports = /* @__PURE__ */ function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList2, [{
        key: "push",
        value: function push(v5) {
          var entry = {
            data: v5,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v5) {
          var entry = {
            data: v5,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s5) {
          if (this.length === 0)
            return "";
          var p5 = this.head;
          var ret = "" + p5.data;
          while (p5 = p5.next) {
            ret += s5 + p5.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat5(n3) {
          if (this.length === 0)
            return Buffer4.alloc(0);
          var ret = Buffer4.allocUnsafe(n3 >>> 0);
          var p5 = this.head;
          var i5 = 0;
          while (p5) {
            copyBuffer(p5.data, ret, i5);
            i5 += p5.data.length;
            p5 = p5.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n3, hasStrings) {
          var ret;
          if (n3 < this.head.data.length) {
            ret = this.head.data.slice(0, n3);
            this.head.data = this.head.data.slice(n3);
          } else if (n3 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n3) : this._getBuffer(n3);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n3) {
          var p5 = this.head;
          var c5 = 1;
          var ret = p5.data;
          n3 -= ret.length;
          while (p5 = p5.next) {
            var str = p5.data;
            var nb = n3 > str.length ? str.length : n3;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n3);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === str.length) {
                ++c5;
                if (p5.next)
                  this.head = p5.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = str.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n3) {
          var ret = Buffer4.allocUnsafe(n3);
          var p5 = this.head;
          var c5 = 1;
          p5.data.copy(ret);
          n3 -= p5.data.length;
          while (p5 = p5.next) {
            var buf = p5.data;
            var nb = n3 > buf.length ? buf.length : n3;
            buf.copy(ret, ret.length - n3, 0, nb);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === buf.length) {
                ++c5;
                if (p5.next)
                  this.head = p5.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = buf.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_6, options) {
          return inspect4(this, _objectSpread({}, options, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList2;
    }();
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/errors-browser.js
var require_errors_browser2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage2(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage2(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i5) {
          return String(i5);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes3(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type2 = includes3(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ERR_INVALID_OPT_VALUE = require_errors_browser2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Writable2;
    function CorkedRequest2(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex2;
    Writable2.WritableState = WritableState2;
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream2 = require_stream_browser2();
    var Buffer4 = require_buffer().Buffer;
    var OurUint8Array = globalThis.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy2();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable2, Stream2);
    function nop2() {
    }
    function WritableState2(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite2(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest2(this);
    }
    WritableState2.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState2.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_6) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable2)
            return false;
          return object && object._writableState instanceof WritableState2;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable2(options) {
      Duplex2 = Duplex2 || require_stream_duplex2();
      var isDuplex = this instanceof Duplex2;
      if (!isDuplex && !realHasInstance.call(Writable2, this))
        return new Writable2(options);
      this._writableState = new WritableState2(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd2(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk2(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer4.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop2;
      if (state.ending)
        writeAfterEnd2(this, cb);
      else if (isBuf || validChunk2(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer2(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk2(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer4.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk2(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite2(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError2(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe2, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe2(stream, state);
      }
    }
    function onwriteStateUpdate2(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite2(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate2(state);
      if (er)
        onwriteError2(stream, state, sync, er, cb);
      else {
        var finished = needFinish2(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer2(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite2, stream, state, finished, cb);
        } else {
          afterWrite2(stream, state, finished, cb);
        }
      }
    }
    function afterWrite2(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain2(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe2(stream, state);
    }
    function onwriteDrain2(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer2(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l5 = state.bufferedRequestCount;
        var buffer2 = new Array(l5);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count2 = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count2] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count2 += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite2(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest2(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite2(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable2(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function needFinish2(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe2(stream, state);
      });
    }
    function prefinish2(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe2(stream, state) {
      var need = needFinish2(state);
      if (need) {
        prefinish2(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable2(stream, state, cb) {
      state.ending = true;
      finishMaybe2(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var objectKeys3 = Object.keys || function(obj) {
      var keys3 = [];
      for (var key in obj) {
        keys3.push(key);
      }
      return keys3;
    };
    module.exports = Duplex2;
    var Readable2 = require_stream_readable2();
    var Writable2 = require_stream_writable2();
    require_inherits_browser()(Duplex2, Readable2);
    {
      keys2 = objectKeys3(Writable2.prototype);
      for (v5 = 0; v5 < keys2.length; v5++) {
        method = keys2[v5];
        if (!Duplex2.prototype[method])
          Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    var keys2;
    var method;
    var v5;
    function Duplex2(options) {
      if (!(this instanceof Duplex2))
        return new Duplex2(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend2);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function onend2() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT2, this);
    }
    function onEndNT2(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once4(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop4() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once4(callback || noop4);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend2 = function onend3() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend2);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend2);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream2();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done2) {
      return {
        value,
        done: done2
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error2 = this[kError];
        if (error2 !== null) {
          return Promise.reject(error2);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator2[kStream].read();
          if (data) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator2[kLastResolve] = resolve;
            iterator2[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator2[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator2[kLastReject];
          if (reject !== null) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            reject(err);
          }
          iterator2[kError] = err;
          return;
        }
        var resolve = iterator2[kLastResolve];
        if (resolve !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator2[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator2));
      return iterator2;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Readable2;
    var Duplex2;
    Readable2.ReadableState = ReadableState2;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type2) {
      return emitter.listeners(type2).length;
    };
    var Stream2 = require_stream_browser2();
    var Buffer4 = require_buffer().Buffer;
    var OurUint8Array = globalThis.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug2;
    if (debugUtil && debugUtil.debuglog) {
      debug2 = debugUtil.debuglog("stream");
    } else {
      debug2 = function debug3() {
      };
    }
    var BufferList2 = require_buffer_list2();
    var destroyImpl = require_destroy2();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder2;
    var createReadableStreamAsyncIterator;
    var from4;
    require_inherits_browser()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener3(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState2(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList2();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder2(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex2 = Duplex2 || require_stream_duplex2();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      var isDuplex = this instanceof Duplex2;
      this._readableState = new ReadableState2(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer4.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk2(this, chunk, null, true, false);
    };
    function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug2("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk2(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid2(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore2(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore2(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable2(stream);
      }
      maybeReadMore2(stream, state);
    }
    function chunkInvalid2(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder2)
        StringDecoder2 = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder2(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p5 = this._readableState.buffer.head;
      var content = "";
      while (p5 !== null) {
        content += decoder.write(p5.data);
        p5 = p5.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM2 = 1073741824;
    function computeNewHighWaterMark2(n3) {
      if (n3 >= MAX_HWM2) {
        n3 = MAX_HWM2;
      } else {
        n3--;
        n3 |= n3 >>> 1;
        n3 |= n3 >>> 2;
        n3 |= n3 >>> 4;
        n3 |= n3 >>> 8;
        n3 |= n3 >>> 16;
        n3++;
      }
      return n3;
    }
    function howMuchToRead2(n3, state) {
      if (n3 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n3 !== n3) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n3 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark2(n3);
      if (n3 <= state.length)
        return n3;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n3) {
      debug2("read", n3);
      n3 = parseInt(n3, 10);
      var state = this._readableState;
      var nOrig = n3;
      if (n3 !== 0)
        state.emittedReadable = false;
      if (n3 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug2("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable2(this);
        else
          emitReadable2(this);
        return null;
      }
      n3 = howMuchToRead2(n3, state);
      if (n3 === 0 && state.ended) {
        if (state.length === 0)
          endReadable2(this);
        return null;
      }
      var doRead = state.needReadable;
      debug2("need readable", doRead);
      if (state.length === 0 || state.length - n3 < state.highWaterMark) {
        doRead = true;
        debug2("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug2("reading or ended", doRead);
      } else if (doRead) {
        debug2("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n3 = howMuchToRead2(nOrig, state);
      }
      var ret;
      if (n3 > 0)
        ret = fromList2(n3, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n3 = 0;
      } else {
        state.length -= n3;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n3 && state.ended)
          endReadable2(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk2(stream, state) {
      debug2("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable2(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_2(stream);
        }
      }
    }
    function emitReadable2(stream) {
      var state = stream._readableState;
      debug2("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug2("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_2, stream);
      }
    }
    function emitReadable_2(stream) {
      var state = stream._readableState;
      debug2("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow2(stream);
    }
    function maybeReadMore2(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_2, stream, state);
      }
    }
    function maybeReadMore_2(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug2("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n3) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend2 : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug2("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend2() {
        debug2("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain2(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug2("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        var ret = dest.write(chunk);
        debug2("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf4(state.pipes, dest) !== -1) && !cleanedUp) {
            debug2("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug2("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener3(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug2("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain2(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug2("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow2(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i5 = 0; i5 < len; i5++) {
          dests[i5].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf4(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug2("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable2(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick2, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick2(self2) {
      debug2("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug2("resume");
        state.flowing = !state.readableListening;
        resume2(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume2(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_2, stream, state);
      }
    }
    function resume_2(stream, state) {
      debug2("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow2(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug2("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug2("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow2(stream) {
      var state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug2("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug2("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i5 in stream) {
        if (this[i5] === void 0 && typeof stream[i5] === "function") {
          this[i5] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i5);
        }
      }
      for (var n3 = 0; n3 < kProxyEvents.length; n3++) {
        stream.on(kProxyEvents[n3], this.emit.bind(this, kProxyEvents[n3]));
      }
      this._read = function(n4) {
        debug2("wrapped _read", n4);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator2();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      enumerable: false,
      get: function get3() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList2;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      enumerable: false,
      get: function get3() {
        return this._readableState.length;
      }
    });
    function fromList2(n3, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n3 || n3 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n3, state.decoder);
      }
      return ret;
    }
    function endReadable2(stream) {
      var state = stream._readableState;
      debug2("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT2, state, stream);
      }
    }
    function endReadableNT2(state, stream) {
      debug2("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from4 === void 0) {
          from4 = require_from_browser2();
        }
        return from4(Readable2, iterable, opts);
      };
    }
    function indexOf4(xs, x5) {
      for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
        if (xs[i5] === x5)
          return i5;
      }
      return -1;
    }
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Transform2;
    var _require$codes = require_errors_browser2().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex2 = require_stream_duplex2();
    require_inherits_browser()(Transform2, Duplex2);
    function afterTransform2(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex2.call(this, options);
      this._transformState = {
        afterTransform: afterTransform2.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish2);
    }
    function prefinish2() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done2(_this, er, data);
        });
      } else {
        done2(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex2.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n3) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex2.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done2(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = PassThrough2;
    var Transform2 = require_stream_transform2();
    require_inherits_browser()(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var eos;
    function once4(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser2().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop4(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once4(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream2();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe2(from4, to) {
      return from4.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop4;
      if (typeof streams[streams.length - 1] !== "function")
        return noop4;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error2;
      var destroys = streams.map(function(stream, i5) {
        var reading = i5 < streams.length - 1;
        var writing = i5 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error2)
            error2 = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error2);
        });
      });
      return streams.reduce(pipe2);
    }
    module.exports = pipeline;
  }
});

// node_modules/browserify-sign/node_modules/readable-stream/readable-browser.js
var require_readable_browser2 = __commonJS({
  "node_modules/browserify-sign/node_modules/readable-stream/readable-browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports = module.exports = require_stream_readable2();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable2();
    exports.Duplex = require_stream_duplex2();
    exports.Transform = require_stream_transform2();
    exports.PassThrough = require_stream_passthrough2();
    exports.finished = require_end_of_stream2();
    exports.pipeline = require_pipeline2();
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base2, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e5) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i5 = number.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number[i5] | number[i5 - 1] << 8 | number[i5 - 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number.length; i5 += 3) {
            w6 = number[i5] | number[i5 + 1] << 8 | number[i5 + 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 48 && c5 <= 57) {
          return c5 - 48;
        } else if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          assert3(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off3 = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number.length; i5 += 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r6 = 0;
        var b4 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul;
          if (c5 >= 49) {
            b4 = c5 - 49 + 10;
          } else if (c5 >= 17) {
            b4 = c5 - 17 + 10;
          } else {
            b4 = c5;
          }
          assert3(c5 >= 0 && b4 < mul, "Invalid character");
          r6 += b4;
        }
        return r6;
      }
      BN2.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i5, number.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone() {
        var r6 = new BN2(null);
        this.copy(r6);
        return r6;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e5) {
          BN2.prototype.inspect = inspect4;
        }
      } else {
        BN2.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i5--;
            }
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modrn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON3() {
        return this.toString(16, 2);
      };
      if (Buffer4) {
        BN2.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer4, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength3);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength3) {
        var position = 0;
        var carry = 0;
        for (var i5 = 0, shift = 0; i5 < this.length; i5++) {
          var word = this.words[i5] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength3) {
        var position = res.length - 1;
        var carry = 0;
        for (var i5 = 0, shift = 0; i5 < this.length; i5++) {
          var word = this.words[i5] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = num.words[off3] >>> wbit & 1;
        }
        return w6;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN2.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN2.prototype._countBits(N4) - 1;
        for (var i5 = 0; i5 < N4; i5++) {
          t5[i5] = this.revBin(i5, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i5 = 0; i5 < N4; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s5 = 1; s5 < N4; s5 <<= 1) {
          var l5 = s5 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s5; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s5];
              var io = itws[p5 + j5 + s5];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s5] = re - ro;
              itws[p5 + j5 + s5] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N4 = Math.max(m5, n3) | 1;
        var odd = N4 & 1;
        var i5 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N4 - i5 - 1];
          rws[N4 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N4 - i5 - 1];
          iws[N4 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N4) * 8192 + Math.round(ws[2 * i5] / N4) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N4; ++i5) {
          rws[i5] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i5 = 0; i5 < N4; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _6 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _6, rwst, iwst, N4, rbt);
        this.transform(nrws, _6, nrwst, niwst, N4, rbt);
        for (var i5 = 0; i5 < N4; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _6, N4, rbt);
        this.conjugate(rmws, _6, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out._strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN2(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s5 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s5] = this.words[i5];
          }
          for (i5 = 0; i5 < s5; i5++) {
            this.words[i5] = 0;
          }
          this.length += s5;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s5 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s5;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s5; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s5;
        }
        if (s5 === 0) {
        } else if (this.length > s5) {
          this.length -= s5;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s5];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5)
          return false;
        var w6 = this.words[s5];
        return !!(w6 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s5) {
          return this;
        }
        if (r6 !== 0) {
          s5++;
        }
        this.length = Math.min(s5, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert3(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5._strip();
        }
        a5._strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN2(1);
        var B4 = new BN2(0);
        var C4 = new BN2(0);
        var D3 = new BN2(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B4.isOdd()) {
                A6.iadd(yp);
                B4.isub(xp);
              }
              A6.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D3.isOdd()) {
                C4.iadd(yp);
                D3.isub(xp);
              }
              C4.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B4.isub(D3);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D3.isub(B4);
          }
        }
        return {
          a: C4,
          b: D3,
          gcd: y5.iushln(g5)
        };
      };
      BN2.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5) {
          this._expand(s5 + 1);
          this.words[s5] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s5; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN2(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN2._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        move(a5, a5.umod(this.m)._forceRed(this));
        return a5;
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s5 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s5++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z5 = this.m.bitLength();
        z5 = new BN2(2 * z5 * z5).toRed(this);
        while (this.pow(z5, lpow).cmp(nOne) !== 0) {
          z5.redIAdd(nOne);
        }
        var c5 = this.pow(z5, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s5;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert3(i5 < m5);
          var b4 = this.pow(c5, new BN2(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/browserify-rsa/index.js
var require_browserify_rsa = __commonJS({
  "node_modules/browserify-rsa/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BN2 = require_bn3();
    var randomBytes2 = require_browser();
    function blind(priv) {
      var r6 = getr(priv);
      var blinder = r6.toRed(BN2.mont(priv.modulus)).redPow(new BN2(priv.publicExponent)).fromRed();
      return { blinder, unblinder: r6.invm(priv.modulus) };
    }
    function getr(priv) {
      var len = priv.modulus.byteLength();
      var r6;
      do {
        r6 = new BN2(randomBytes2(len));
      } while (r6.cmp(priv.modulus) >= 0 || !r6.umod(priv.prime1) || !r6.umod(priv.prime2));
      return r6;
    }
    function crt(msg, priv) {
      var blinds = blind(priv);
      var len = priv.modulus.byteLength();
      var blinded = new BN2(msg).mul(blinds.blinder).umod(priv.modulus);
      var c1 = blinded.toRed(BN2.mont(priv.prime1));
      var c22 = blinded.toRed(BN2.mont(priv.prime2));
      var qinv = priv.coefficient;
      var p5 = priv.prime1;
      var q5 = priv.prime2;
      var m1 = c1.redPow(priv.exponent1).fromRed();
      var m22 = c22.redPow(priv.exponent2).fromRed();
      var h5 = m1.isub(m22).imul(qinv).umod(p5).imul(q5);
      return m22.iadd(h5).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer2, "be", len);
    }
    crt.getr = getr;
    module.exports = crt;
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn4 = __commonJS({
  "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base2, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e5) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i5 = number.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number[i5] | number[i5 - 1] << 8 | number[i5 - 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number.length; i5 += 3) {
            w6 = number[i5] | number[i5 + 1] << 8 | number[i5 + 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off3 = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number.length; i5 += 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN2.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i5, number.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r6 = new BN2(null);
        this.copy(r6);
        return r6;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength3; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN2.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN2.prototype._countBits(N4) - 1;
        for (var i5 = 0; i5 < N4; i5++) {
          t5[i5] = this.revBin(i5, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i5 = 0; i5 < N4; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s5 = 1; s5 < N4; s5 <<= 1) {
          var l5 = s5 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s5; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s5];
              var io = itws[p5 + j5 + s5];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s5] = re - ro;
              itws[p5 + j5 + s5] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N4 = Math.max(m5, n3) | 1;
        var odd = N4 & 1;
        var i5 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N4 - i5 - 1];
          rws[N4 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N4 - i5 - 1];
          iws[N4 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N4) * 8192 + Math.round(ws[2 * i5] / N4) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N4; ++i5) {
          rws[i5] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i5 = 0; i5 < N4; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _6 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _6, rwst, iwst, N4, rbt);
        this.transform(nrws, _6, nrwst, niwst, N4, rbt);
        for (var i5 = 0; i5 < N4; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _6, N4, rbt);
        this.conjugate(rmws, _6, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN2(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s5 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s5] = this.words[i5];
          }
          for (i5 = 0; i5 < s5; i5++) {
            this.words[i5] = 0;
          }
          this.length += s5;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s5 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s5;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s5; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s5;
        }
        if (s5 === 0) {
        } else if (this.length > s5) {
          this.length -= s5;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s5];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5)
          return false;
        var w6 = this.words[s5];
        return !!(w6 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s5) {
          return this;
        }
        if (r6 !== 0) {
          s5++;
        }
        this.length = Math.min(s5, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN2(1);
        var B4 = new BN2(0);
        var C4 = new BN2(0);
        var D3 = new BN2(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B4.isOdd()) {
                A6.iadd(yp);
                B4.isub(xp);
              }
              A6.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D3.isOdd()) {
                C4.iadd(yp);
                D3.isub(xp);
              }
              C4.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B4.isub(D3);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D3.isub(B4);
          }
        }
        return {
          a: C4,
          b: D3,
          gcd: y5.iushln(g5)
        };
      };
      BN2.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5) {
          this._expand(s5 + 1);
          this.words[s5] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s5; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN2(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN2._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s5 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s5++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z5 = this.m.bitLength();
        z5 = new BN2(2 * z5 * z5).toRed(this);
        while (this.pow(z5, lpow).cmp(nOne) !== 0) {
          z5.redIAdd(nOne);
        }
        var c5 = this.pow(z5, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s5;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert3(i5 < m5);
          var b4 = this.pow(c5, new BN2(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = exports;
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i5 = 0; i5 < msg.length; i5++)
          res[i5] = msg[i5] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i5 = 0; i5 < msg.length; i5 += 2)
          res.push(parseInt(msg[i5] + msg[i5 + 1], 16));
      } else {
        for (var i5 = 0; i5 < msg.length; i5++) {
          var c5 = msg.charCodeAt(i5);
          var hi = c5 >> 8;
          var lo = c5 & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray2;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex3(msg) {
      var res = "";
      for (var i5 = 0; i5 < msg.length; i5++)
        res += zero2(msg[i5].toString(16));
      return res;
    }
    utils.toHex = toHex3;
    utils.encode = function encode2(arr, enc) {
      if (enc === "hex")
        return toHex3(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils3 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = exports;
    var BN2 = require_bn4();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w6, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w6 + 1;
      var k5 = num.clone();
      for (var i5 = 0; i5 < naf.length; i5++) {
        var z5;
        var mod = k5.andln(ws - 1);
        if (k5.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z5 = (ws >> 1) - mod;
          else
            z5 = mod;
          k5.isubn(z5);
        } else {
          z5 = 0;
        }
        naf[i5] = z5;
        k5.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN2(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BN2 = require_bn4();
    var utils = require_utils3();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert3 = utils.assert;
    function BaseCurve(type2, conf) {
      this.type = type2;
      this.p = new BN2(conf.p, 16);
      this.red = conf.prime ? BN2.red(conf.prime) : BN2.mont(this.p);
      this.zero = new BN2(0).toRed(this.red);
      this.one = new BN2(1).toRed(this.red);
      this.two = new BN2(2).toRed(this.red);
      this.n = conf.n && new BN2(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p5, k5) {
      assert3(p5.precomputed);
      var doubles = p5._getDoubles();
      var naf = getNAF(k5, 1, this._bitLength);
      var I4 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I4 /= 3;
      var repr = [];
      var j5;
      var nafW;
      for (j5 = 0; j5 < naf.length; j5 += doubles.step) {
        nafW = 0;
        for (var l5 = j5 + doubles.step - 1; l5 >= j5; l5--)
          nafW = (nafW << 1) + naf[l5];
        repr.push(nafW);
      }
      var a5 = this.jpoint(null, null, null);
      var b4 = this.jpoint(null, null, null);
      for (var i5 = I4; i5 > 0; i5--) {
        for (j5 = 0; j5 < repr.length; j5++) {
          nafW = repr[j5];
          if (nafW === i5)
            b4 = b4.mixedAdd(doubles.points[j5]);
          else if (nafW === -i5)
            b4 = b4.mixedAdd(doubles.points[j5].neg());
        }
        a5 = a5.add(b4);
      }
      return a5.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p5, k5) {
      var w6 = 4;
      var nafPoints = p5._getNAFPoints(w6);
      w6 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k5, w6, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i5 = naf.length - 1; i5 >= 0; i5--) {
        for (var l5 = 0; i5 >= 0 && naf[i5] === 0; i5--)
          l5++;
        if (i5 >= 0)
          l5++;
        acc = acc.dblp(l5);
        if (i5 < 0)
          break;
        var z5 = naf[i5];
        assert3(z5 !== 0);
        if (p5.type === "affine") {
          if (z5 > 0)
            acc = acc.mixedAdd(wnd[z5 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z5 - 1 >> 1].neg());
        } else {
          if (z5 > 0)
            acc = acc.add(wnd[z5 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z5 - 1 >> 1].neg());
        }
      }
      return p5.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max2 = 0;
      var i5;
      var j5;
      var p5;
      for (i5 = 0; i5 < len; i5++) {
        p5 = points[i5];
        var nafPoints = p5._getNAFPoints(defW);
        wndWidth[i5] = nafPoints.wnd;
        wnd[i5] = nafPoints.points;
      }
      for (i5 = len - 1; i5 >= 1; i5 -= 2) {
        var a5 = i5 - 1;
        var b4 = i5;
        if (wndWidth[a5] !== 1 || wndWidth[b4] !== 1) {
          naf[a5] = getNAF(coeffs[a5], wndWidth[a5], this._bitLength);
          naf[b4] = getNAF(coeffs[b4], wndWidth[b4], this._bitLength);
          max2 = Math.max(naf[a5].length, max2);
          max2 = Math.max(naf[b4].length, max2);
          continue;
        }
        var comb = [
          points[a5],
          null,
          null,
          points[b4]
        ];
        if (points[a5].y.cmp(points[b4].y) === 0) {
          comb[1] = points[a5].add(points[b4]);
          comb[2] = points[a5].toJ().mixedAdd(points[b4].neg());
        } else if (points[a5].y.cmp(points[b4].y.redNeg()) === 0) {
          comb[1] = points[a5].toJ().mixedAdd(points[b4]);
          comb[2] = points[a5].add(points[b4].neg());
        } else {
          comb[1] = points[a5].toJ().mixedAdd(points[b4]);
          comb[2] = points[a5].toJ().mixedAdd(points[b4].neg());
        }
        var index = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF(coeffs[a5], coeffs[b4]);
        max2 = Math.max(jsf[0].length, max2);
        naf[a5] = new Array(max2);
        naf[b4] = new Array(max2);
        for (j5 = 0; j5 < max2; j5++) {
          var ja = jsf[0][j5] | 0;
          var jb = jsf[1][j5] | 0;
          naf[a5][j5] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b4][j5] = 0;
          wnd[a5] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i5 = max2; i5 >= 0; i5--) {
        var k5 = 0;
        while (i5 >= 0) {
          var zero = true;
          for (j5 = 0; j5 < len; j5++) {
            tmp[j5] = naf[j5][i5] | 0;
            if (tmp[j5] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k5++;
          i5--;
        }
        if (i5 >= 0)
          k5++;
        acc = acc.dblp(k5);
        if (i5 < 0)
          break;
        for (j5 = 0; j5 < len; j5++) {
          var z5 = tmp[j5];
          p5;
          if (z5 === 0)
            continue;
          else if (z5 > 0)
            p5 = wnd[j5][z5 - 1 >> 1];
          else if (z5 < 0)
            p5 = wnd[j5][-z5 - 1 >> 1].neg();
          if (p5.type === "affine")
            acc = acc.mixedAdd(p5);
          else
            acc = acc.add(p5);
        }
      }
      for (i5 = 0; i5 < len; i5++)
        wnd[i5] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type2) {
      this.curve = curve;
      this.type = type2;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert3(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert3(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x5 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x5);
      return [4].concat(x5, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode2(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k5) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k5.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i5 = 0; i5 < power; i5 += step) {
        for (var j5 = 0; j5 < step; j5++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max2 = (1 << wnd) - 1;
      var dbl = max2 === 1 ? null : this.dbl();
      for (var i5 = 1; i5 < max2; i5++)
        res[i5] = res[i5 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k5) {
      var r6 = this;
      for (var i5 = 0; i5 < k5; i5++)
        r6 = r6.dbl();
      return r6;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils3();
    var BN2 = require_bn4();
    var inherits2 = require_inherits_browser();
    var Base = require_base();
    var assert3 = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN2(conf.a, 16).toRed(this.red);
      this.b = new BN2(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits2(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN2(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN2(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert3(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN2(vec.a, 16),
            b: new BN2(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN2.mont(num);
      var tinv = new BN2(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s5 = new BN2(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s5).fromRed();
      var l22 = ntinv.redSub(s5).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u5 = lambda;
      var v5 = this.n.clone();
      var x1 = new BN2(1);
      var y1 = new BN2(0);
      var x22 = new BN2(0);
      var y22 = new BN2(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i5 = 0;
      var r6;
      var x5;
      while (u5.cmpn(0) !== 0) {
        var q5 = v5.div(u5);
        r6 = v5.sub(q5.mul(u5));
        x5 = x22.sub(q5.mul(x1));
        var y5 = y22.sub(q5.mul(y1));
        if (!a1 && r6.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r6.neg();
          b1 = x5;
        } else if (a1 && ++i5 === 2) {
          break;
        }
        prevR = r6;
        v5 = u5;
        u5 = r6;
        x22 = x1;
        x1 = x5;
        y22 = y1;
        y1 = y5;
      }
      a22 = r6.neg();
      b22 = x5;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k5) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v22 = basis[1];
      var c1 = v22.b.mul(k5).divRound(this.n);
      var c22 = v1.b.neg().mul(k5).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p22 = c22.mul(v22.a);
      var q1 = c1.mul(v1.b);
      var q22 = c22.mul(v22.b);
      var k1 = k5.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x5, odd) {
      x5 = new BN2(x5, 16);
      if (!x5.red)
        x5 = x5.toRed(this.red);
      var y22 = x5.redSqr().redMul(x5).redIAdd(x5.redMul(this.a)).redIAdd(this.b);
      var y5 = y22.redSqrt();
      if (y5.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y5.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y5 = y5.redNeg();
      return this.point(x5, y5);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x5 = point.x;
      var y5 = point.y;
      var ax = this.a.redMul(x5);
      var rhs = x5.redSqr().redMul(x5).redIAdd(ax).redIAdd(this.b);
      return y5.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i5 = 0; i5 < points.length; i5++) {
        var split = this._endoSplit(coeffs[i5]);
        var p5 = points[i5];
        var beta = p5._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p5 = p5.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i5 * 2] = p5;
        npoints[i5 * 2 + 1] = beta;
        ncoeffs[i5 * 2] = split.k1;
        ncoeffs[i5 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i5 * 2, jacobianResult);
      for (var j5 = 0; j5 < i5 * 2; j5++) {
        npoints[j5] = null;
        ncoeffs[j5] = null;
      }
      return res;
    };
    function Point(curve, x5, y5, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x5 === null && y5 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN2(x5, 16);
        this.y = new BN2(y5, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits2(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x5, y5, isRed) {
      return new Point(this, x5, y5, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p5) {
          return curve.point(p5.x.redMul(curve.endo.beta), p5.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON3() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p5) {
      if (this.inf)
        return p5;
      if (p5.inf)
        return this;
      if (this.eq(p5))
        return this.dbl();
      if (this.neg().eq(p5))
        return this.curve.point(null, null);
      if (this.x.cmp(p5.x) === 0)
        return this.curve.point(null, null);
      var c5 = this.y.redSub(p5.y);
      if (c5.cmpn(0) !== 0)
        c5 = c5.redMul(this.x.redSub(p5.x).redInvm());
      var nx = c5.redSqr().redISub(this.x).redISub(p5.x);
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a5 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c5 = x22.redAdd(x22).redIAdd(x22).redIAdd(a5).redMul(dyinv);
      var nx = c5.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k5) {
      k5 = new BN2(k5, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k5]);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p5) {
      return this === p5 || this.inf === p5.inf && (this.inf || this.x.cmp(p5.x) === 0 && this.y.cmp(p5.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p5) {
          return p5.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x5, y5, z5) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x5 === null && y5 === null && z5 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN2(0);
      } else {
        this.x = new BN2(x5, 16);
        this.y = new BN2(y5, 16);
        this.z = new BN2(z5, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits2(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x5, y5, z5) {
      return new JPoint(this, x5, y5, z5);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      var pz2 = p5.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p5.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p5.z));
      var s22 = p5.y.redMul(z22.redMul(this.z));
      var h5 = u1.redSub(u22);
      var r6 = s1.redSub(s22);
      if (h5.cmpn(0) === 0) {
        if (r6.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h5.redSqr();
      var h32 = h22.redMul(h5);
      var v5 = u1.redMul(h22);
      var nx = r6.redSqr().redIAdd(h32).redISub(v5).redISub(v5);
      var ny = r6.redMul(v5.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p5.z).redMul(h5);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p5) {
      if (this.isInfinity())
        return p5.toJ();
      if (p5.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p5.x.redMul(z22);
      var s1 = this.y;
      var s22 = p5.y.redMul(z22).redMul(this.z);
      var h5 = u1.redSub(u22);
      var r6 = s1.redSub(s22);
      if (h5.cmpn(0) === 0) {
        if (r6.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h5.redSqr();
      var h32 = h22.redMul(h5);
      var v5 = u1.redMul(h22);
      var nx = r6.redSqr().redIAdd(h32).redISub(v5).redISub(v5);
      var ny = r6.redMul(v5.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h5);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i5;
      if (this.curve.zeroA || this.curve.threeA) {
        var r6 = this;
        for (i5 = 0; i5 < pow; i5++)
          r6 = r6.dbl();
        return r6;
      }
      var a5 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i5 = 0; i5 < pow; i5++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c5.redSqr().redISub(t1.redAdd(t1));
        var t22 = t1.redISub(nx);
        var dny = c5.redMul(t22);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i5 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s5 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s5 = s5.redIAdd(s5);
        var m5 = xx.redAdd(xx).redIAdd(xx);
        var t5 = m5.redSqr().redISub(s5).redISub(s5);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t5;
        ny = m5.redMul(s5.redISub(t5)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a5 = this.x.redSqr();
        var b4 = this.y.redSqr();
        var c5 = b4.redSqr();
        var d5 = this.x.redAdd(b4).redSqr().redISub(a5).redISub(c5);
        d5 = d5.redIAdd(d5);
        var e5 = a5.redAdd(a5).redIAdd(a5);
        var f5 = e5.redSqr();
        var c8 = c5.redIAdd(c5);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f5.redISub(d5).redISub(d5);
        ny = e5.redMul(d5.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s5 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s5 = s5.redIAdd(s5);
        var m5 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t5 = m5.redSqr().redISub(s5).redISub(s5);
        nx = t5;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m5.redMul(s5.redISub(t5)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a5 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c5.redSqr().redISub(t1.redAdd(t1));
      var t22 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c5.redMul(t22).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m5 = xx.redAdd(xx).redIAdd(xx);
      var mm = m5.redSqr();
      var e5 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e5 = e5.redIAdd(e5);
      e5 = e5.redAdd(e5).redIAdd(e5);
      e5 = e5.redISub(mm);
      var ee = e5.redSqr();
      var t5 = yyyy.redIAdd(yyyy);
      t5 = t5.redIAdd(t5);
      t5 = t5.redIAdd(t5);
      t5 = t5.redIAdd(t5);
      var u5 = m5.redIAdd(e5).redSqr().redISub(mm).redISub(ee).redISub(t5);
      var yyu4 = yy.redMul(u5);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u5.redMul(t5.redISub(u5)).redISub(e5.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e5).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k5, kbase) {
      k5 = new BN2(k5, kbase);
      return this.curve._wnafMul(this, k5);
    };
    JPoint.prototype.eq = function eq(p5) {
      if (p5.type === "affine")
        return this.eq(p5.toJ());
      if (this === p5)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p5.z.redSqr();
      if (this.x.redMul(pz2).redISub(p5.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p5.z);
      return this.y.redMul(pz3).redISub(p5.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x5) {
      var zs = this.z.redSqr();
      var rx = x5.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x5.clone();
      var t5 = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t5);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BN2 = require_bn4();
    var inherits2 = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils3();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN2(conf.a, 16).toRed(this.red);
      this.b = new BN2(conf.b, 16).toRed(this.red);
      this.i4 = new BN2(4).toRed(this.red).redInvm();
      this.two = new BN2(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits2(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x5 = point.normalize().x;
      var x22 = x5.redSqr();
      var rhs = x22.redMul(x5).redAdd(x22.redMul(this.a)).redAdd(x5);
      var y5 = rhs.redSqrt();
      return y5.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x5, z5) {
      Base.BasePoint.call(this, curve, "projective");
      if (x5 === null && z5 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN2(x5, 16);
        this.z = new BN2(z5, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits2(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x5, z5) {
      return new Point(this, x5, z5);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a5 = this.x.redAdd(this.z);
      var aa = a5.redSqr();
      var b4 = this.x.redSub(this.z);
      var bb = b4.redSqr();
      var c5 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c5.redMul(bb.redAdd(this.curve.a24.redMul(c5)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p5, diff) {
      var a5 = this.x.redAdd(this.z);
      var b4 = this.x.redSub(this.z);
      var c5 = p5.x.redAdd(p5.z);
      var d5 = p5.x.redSub(p5.z);
      var da = d5.redMul(a5);
      var cb = c5.redMul(b4);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k5) {
      var t5 = k5.clone();
      var a5 = this;
      var b4 = this.curve.point(null, null);
      var c5 = this;
      for (var bits = []; t5.cmpn(0) !== 0; t5.iushrn(1))
        bits.push(t5.andln(1));
      for (var i5 = bits.length - 1; i5 >= 0; i5--) {
        if (bits[i5] === 0) {
          a5 = a5.diffAdd(b4, c5);
          b4 = b4.dbl();
        } else {
          b4 = a5.diffAdd(b4, c5);
          a5 = a5.dbl();
        }
      }
      return b4;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils3();
    var BN2 = require_bn4();
    var inherits2 = require_inherits_browser();
    var Base = require_base();
    var assert3 = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN2(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN2(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN2(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert3(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits2(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x5, y5, z5, t5) {
      return this.point(x5, y5, z5, t5);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x5, odd) {
      x5 = new BN2(x5, 16);
      if (!x5.red)
        x5 = x5.toRed(this.red);
      var x22 = x5.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y5 = y22.redSqrt();
      if (y5.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y5.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y5 = y5.redNeg();
      return this.point(x5, y5);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y5, odd) {
      y5 = new BN2(y5, 16);
      if (!y5.red)
        y5 = y5.toRed(this.red);
      var y22 = y5.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y5);
      }
      var x5 = x22.redSqrt();
      if (x5.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x5.fromRed().isOdd() !== odd)
        x5 = x5.redNeg();
      return this.point(x5, y5);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y22 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x5, y5, z5, t5) {
      Base.BasePoint.call(this, curve, "projective");
      if (x5 === null && y5 === null && z5 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN2(x5, 16);
        this.y = new BN2(y5, 16);
        this.z = z5 ? new BN2(z5, 16) : this.curve.one;
        this.t = t5 && new BN2(t5, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits2(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x5, y5, z5, t5) {
      return new Point(this, x5, y5, z5, t5);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a5 = this.x.redSqr();
      var b4 = this.y.redSqr();
      var c5 = this.z.redSqr();
      c5 = c5.redIAdd(c5);
      var d5 = this.curve._mulA(a5);
      var e5 = this.x.redAdd(this.y).redSqr().redISub(a5).redISub(b4);
      var g5 = d5.redAdd(b4);
      var f5 = g5.redSub(c5);
      var h5 = d5.redSub(b4);
      var nx = e5.redMul(f5);
      var ny = g5.redMul(h5);
      var nt = e5.redMul(h5);
      var nz = f5.redMul(g5);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b4 = this.x.redAdd(this.y).redSqr();
      var c5 = this.x.redSqr();
      var d5 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e5;
      var h5;
      var j5;
      if (this.curve.twisted) {
        e5 = this.curve._mulA(c5);
        var f5 = e5.redAdd(d5);
        if (this.zOne) {
          nx = b4.redSub(c5).redSub(d5).redMul(f5.redSub(this.curve.two));
          ny = f5.redMul(e5.redSub(d5));
          nz = f5.redSqr().redSub(f5).redSub(f5);
        } else {
          h5 = this.z.redSqr();
          j5 = f5.redSub(h5).redISub(h5);
          nx = b4.redSub(c5).redISub(d5).redMul(j5);
          ny = f5.redMul(e5.redSub(d5));
          nz = f5.redMul(j5);
        }
      } else {
        e5 = c5.redAdd(d5);
        h5 = this.curve._mulC(this.z).redSqr();
        j5 = e5.redSub(h5).redSub(h5);
        nx = this.curve._mulC(b4.redISub(e5)).redMul(j5);
        ny = this.curve._mulC(e5).redMul(c5.redISub(d5));
        nz = e5.redMul(j5);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p5) {
      var a5 = this.y.redSub(this.x).redMul(p5.y.redSub(p5.x));
      var b4 = this.y.redAdd(this.x).redMul(p5.y.redAdd(p5.x));
      var c5 = this.t.redMul(this.curve.dd).redMul(p5.t);
      var d5 = this.z.redMul(p5.z.redAdd(p5.z));
      var e5 = b4.redSub(a5);
      var f5 = d5.redSub(c5);
      var g5 = d5.redAdd(c5);
      var h5 = b4.redAdd(a5);
      var nx = e5.redMul(f5);
      var ny = g5.redMul(h5);
      var nt = e5.redMul(h5);
      var nz = f5.redMul(g5);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p5) {
      var a5 = this.z.redMul(p5.z);
      var b4 = a5.redSqr();
      var c5 = this.x.redMul(p5.x);
      var d5 = this.y.redMul(p5.y);
      var e5 = this.curve.d.redMul(c5).redMul(d5);
      var f5 = b4.redSub(e5);
      var g5 = b4.redAdd(e5);
      var tmp = this.x.redAdd(this.y).redMul(p5.x.redAdd(p5.y)).redISub(c5).redISub(d5);
      var nx = a5.redMul(f5).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a5.redMul(g5).redMul(d5.redSub(this.curve._mulA(c5)));
        nz = f5.redMul(g5);
      } else {
        ny = a5.redMul(g5).redMul(d5.redSub(c5));
        nz = this.curve._mulC(f5).redMul(g5);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p5);
      else
        return this._projAdd(p5);
    };
    Point.prototype.mul = function mul(k5) {
      if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k1, k22], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k1, k22], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x5) {
      var rx = x5.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x5.clone();
      var t5 = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t5);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils4 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var assert3 = require_minimalistic_assert();
    var inherits2 = require_inherits_browser();
    exports.inherits = inherits2;
    function isSurrogatePair(msg, i5) {
      if ((msg.charCodeAt(i5) & 64512) !== 55296) {
        return false;
      }
      if (i5 < 0 || i5 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i5 + 1) & 64512) === 56320;
    }
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p5 = 0;
          for (var i5 = 0; i5 < msg.length; i5++) {
            var c5 = msg.charCodeAt(i5);
            if (c5 < 128) {
              res[p5++] = c5;
            } else if (c5 < 2048) {
              res[p5++] = c5 >> 6 | 192;
              res[p5++] = c5 & 63 | 128;
            } else if (isSurrogatePair(msg, i5)) {
              c5 = 65536 + ((c5 & 1023) << 10) + (msg.charCodeAt(++i5) & 1023);
              res[p5++] = c5 >> 18 | 240;
              res[p5++] = c5 >> 12 & 63 | 128;
              res[p5++] = c5 >> 6 & 63 | 128;
              res[p5++] = c5 & 63 | 128;
            } else {
              res[p5++] = c5 >> 12 | 224;
              res[p5++] = c5 >> 6 & 63 | 128;
              res[p5++] = c5 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i5 = 0; i5 < msg.length; i5 += 2)
            res.push(parseInt(msg[i5] + msg[i5 + 1], 16));
        }
      } else {
        for (i5 = 0; i5 < msg.length; i5++)
          res[i5] = msg[i5] | 0;
      }
      return res;
    }
    exports.toArray = toArray2;
    function toHex3(msg) {
      var res = "";
      for (var i5 = 0; i5 < msg.length; i5++)
        res += zero2(msg[i5].toString(16));
      return res;
    }
    exports.toHex = toHex3;
    function htonl(w6) {
      var res = w6 >>> 24 | w6 >>> 8 & 65280 | w6 << 8 & 16711680 | (w6 & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i5 = 0; i5 < msg.length; i5++) {
        var w6 = msg[i5];
        if (endian === "little")
          w6 = htonl(w6);
        res += zero8(w6.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert3(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i5 = 0, k5 = start; i5 < res.length; i5++, k5 += 4) {
        var w6;
        if (endian === "big")
          w6 = msg[k5] << 24 | msg[k5 + 1] << 16 | msg[k5 + 2] << 8 | msg[k5 + 3];
        else
          w6 = msg[k5 + 3] << 24 | msg[k5 + 2] << 16 | msg[k5 + 1] << 8 | msg[k5];
        res[i5] = w6 >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i5 = 0, k5 = 0; i5 < msg.length; i5++, k5 += 4) {
        var m5 = msg[i5];
        if (endian === "big") {
          res[k5] = m5 >>> 24;
          res[k5 + 1] = m5 >>> 16 & 255;
          res[k5 + 2] = m5 >>> 8 & 255;
          res[k5 + 3] = m5 & 255;
        } else {
          res[k5 + 3] = m5 >>> 24;
          res[k5 + 2] = m5 >>> 16 & 255;
          res[k5 + 1] = m5 >>> 8 & 255;
          res[k5] = m5 & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w6, b4) {
      return w6 >>> b4 | w6 << 32 - b4;
    }
    exports.rotr32 = rotr32;
    function rotl32(w6, b4) {
      return w6 << b4 | w6 >>> 32 - b4;
    }
    exports.rotl32 = rotl32;
    function sum32(a5, b4) {
      return a5 + b4 >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a5, b4, c5) {
      return a5 + b4 + c5 >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a5, b4, c5, d5) {
      return a5 + b4 + c5 + d5 >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a5, b4, c5, d5, e5) {
      return a5 + b4 + c5 + d5 + e5 >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r6 = al << 32 - num | ah >>> num;
      return r6 >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r6 = ah << 32 - num | al >>> num;
      return r6 >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r6 = ah << 32 - num | al >>> num;
      return r6 >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var assert3 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r6 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r6, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r6, this.endian);
        for (var i5 = 0; i5 < msg.length; i5 += this._delta32)
          this._update(msg, i5, i5 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert3(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad2() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k5 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k5 + this.padLength);
      res[0] = 128;
      for (var i5 = 1; i5 < k5; i5++)
        res[i5] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t5 = 8; t5 < this.padLength; t5++)
          res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = len >>> 24 & 255;
        res[i5++] = len >>> 16 & 255;
        res[i5++] = len >>> 8 & 255;
        res[i5++] = len & 255;
      } else {
        res[i5++] = len & 255;
        res[i5++] = len >>> 8 & 255;
        res[i5++] = len >>> 16 & 255;
        res[i5++] = len >>> 24 & 255;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        for (t5 = 8; t5 < this.padLength; t5++)
          res[i5++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var rotr32 = utils.rotr32;
    function ft_1(s5, x5, y5, z5) {
      if (s5 === 0)
        return ch32(x5, y5, z5);
      if (s5 === 1 || s5 === 3)
        return p32(x5, y5, z5);
      if (s5 === 2)
        return maj32(x5, y5, z5);
    }
    exports.ft_1 = ft_1;
    function ch32(x5, y5, z5) {
      return x5 & y5 ^ ~x5 & z5;
    }
    exports.ch32 = ch32;
    function maj32(x5, y5, z5) {
      return x5 & y5 ^ x5 & z5 ^ y5 & z5;
    }
    exports.maj32 = maj32;
    function p32(x5, y5, z5) {
      return x5 ^ y5 ^ z5;
    }
    exports.p32 = p32;
    function s0_256(x5) {
      return rotr32(x5, 2) ^ rotr32(x5, 13) ^ rotr32(x5, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x5) {
      return rotr32(x5, 6) ^ rotr32(x5, 11) ^ rotr32(x5, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x5) {
      return rotr32(x5, 7) ^ rotr32(x5, 18) ^ x5 >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x5) {
      return rotr32(x5, 17) ^ rotr32(x5, 19) ^ x5 >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W2 = this.W;
      for (var i5 = 0; i5 < 16; i5++)
        W2[i5] = msg[start + i5];
      for (; i5 < W2.length; i5++)
        W2[i5] = rotl32(W2[i5 - 3] ^ W2[i5 - 8] ^ W2[i5 - 14] ^ W2[i5 - 16], 1);
      var a5 = this.h[0];
      var b4 = this.h[1];
      var c5 = this.h[2];
      var d5 = this.h[3];
      var e5 = this.h[4];
      for (i5 = 0; i5 < W2.length; i5++) {
        var s5 = ~~(i5 / 20);
        var t5 = sum32_5(rotl32(a5, 5), ft_1(s5, b4, c5, d5), e5, W2[i5], sha1_K[s5]);
        e5 = d5;
        d5 = c5;
        c5 = rotl32(b4, 30);
        b4 = a5;
        a5 = t5;
      }
      this.h[0] = sum32(this.h[0], a5);
      this.h[1] = sum32(this.h[1], b4);
      this.h[2] = sum32(this.h[2], c5);
      this.h[3] = sum32(this.h[3], d5);
      this.h[4] = sum32(this.h[4], e5);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var common = require_common();
    var shaCommon = require_common2();
    var assert3 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W2 = this.W;
      for (var i5 = 0; i5 < 16; i5++)
        W2[i5] = msg[start + i5];
      for (; i5 < W2.length; i5++)
        W2[i5] = sum32_4(g1_256(W2[i5 - 2]), W2[i5 - 7], g0_256(W2[i5 - 15]), W2[i5 - 16]);
      var a5 = this.h[0];
      var b4 = this.h[1];
      var c5 = this.h[2];
      var d5 = this.h[3];
      var e5 = this.h[4];
      var f5 = this.h[5];
      var g5 = this.h[6];
      var h5 = this.h[7];
      assert3(this.k.length === W2.length);
      for (i5 = 0; i5 < W2.length; i5++) {
        var T1 = sum32_5(h5, s1_256(e5), ch32(e5, f5, g5), this.k[i5], W2[i5]);
        var T22 = sum32(s0_256(a5), maj32(a5, b4, c5));
        h5 = g5;
        g5 = f5;
        f5 = e5;
        e5 = sum32(d5, T1);
        d5 = c5;
        c5 = b4;
        b4 = a5;
        a5 = sum32(T1, T22);
      }
      this.h[0] = sum32(this.h[0], a5);
      this.h[1] = sum32(this.h[1], b4);
      this.h[2] = sum32(this.h[2], c5);
      this.h[3] = sum32(this.h[3], d5);
      this.h[4] = sum32(this.h[4], e5);
      this.h[5] = sum32(this.h[5], f5);
      this.h[6] = sum32(this.h[6], g5);
      this.h[7] = sum32(this.h[7], h5);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var common = require_common();
    var assert3 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W2 = this.W;
      for (var i5 = 0; i5 < 32; i5++)
        W2[i5] = msg[start + i5];
      for (; i5 < W2.length; i5 += 2) {
        var c0_hi = g1_512_hi(W2[i5 - 4], W2[i5 - 3]);
        var c0_lo = g1_512_lo(W2[i5 - 4], W2[i5 - 3]);
        var c1_hi = W2[i5 - 14];
        var c1_lo = W2[i5 - 13];
        var c2_hi = g0_512_hi(W2[i5 - 30], W2[i5 - 29]);
        var c2_lo = g0_512_lo(W2[i5 - 30], W2[i5 - 29]);
        var c3_hi = W2[i5 - 32];
        var c3_lo = W2[i5 - 31];
        W2[i5] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W2[i5 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W2 = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert3(this.k.length === W2.length);
      for (var i5 = 0; i5 < W2.length; i5 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i5];
        var c3_lo = this.k[i5 + 1];
        var c4_hi = W2[i5];
        var c4_lo = W2[i5 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r6 = xh & yh ^ ~xh & zh;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r6 = xl & yl ^ ~xl & zl;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r6 = xh & yh ^ xh & zh ^ yh & zh;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r6 = xl & yl ^ xl & zl ^ yl & zl;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r6 = c0_hi ^ c1_hi ^ c2_hi;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r6 = c0_lo ^ c1_lo ^ c2_lo;
      if (r6 < 0)
        r6 += 4294967296;
      return r6;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A6 = this.h[0];
      var B4 = this.h[1];
      var C4 = this.h[2];
      var D3 = this.h[3];
      var E4 = this.h[4];
      var Ah = A6;
      var Bh = B4;
      var Ch = C4;
      var Dh = D3;
      var Eh = E4;
      for (var j5 = 0; j5 < 80; j5++) {
        var T6 = sum32(
          rotl32(
            sum32_4(A6, f5(j5, B4, C4, D3), msg[r6[j5] + start], K2(j5)),
            s5[j5]
          ),
          E4
        );
        A6 = E4;
        E4 = D3;
        D3 = rotl32(C4, 10);
        C4 = B4;
        B4 = T6;
        T6 = sum32(
          rotl32(
            sum32_4(Ah, f5(79 - j5, Bh, Ch, Dh), msg[rh[j5] + start], Kh(j5)),
            sh[j5]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T6;
      }
      T6 = sum32_3(this.h[1], C4, Dh);
      this.h[1] = sum32_3(this.h[2], D3, Eh);
      this.h[2] = sum32_3(this.h[3], E4, Ah);
      this.h[3] = sum32_3(this.h[4], A6, Bh);
      this.h[4] = sum32_3(this.h[0], B4, Ch);
      this.h[0] = T6;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f5(j5, x5, y5, z5) {
      if (j5 <= 15)
        return x5 ^ y5 ^ z5;
      else if (j5 <= 31)
        return x5 & y5 | ~x5 & z5;
      else if (j5 <= 47)
        return (x5 | ~y5) ^ z5;
      else if (j5 <= 63)
        return x5 & z5 | y5 & ~z5;
      else
        return x5 ^ (y5 | ~z5);
    }
    function K2(j5) {
      if (j5 <= 15)
        return 0;
      else if (j5 <= 31)
        return 1518500249;
      else if (j5 <= 47)
        return 1859775393;
      else if (j5 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j5) {
      if (j5 <= 15)
        return 1352829926;
      else if (j5 <= 31)
        return 1548603684;
      else if (j5 <= 47)
        return 1836072691;
      else if (j5 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r6 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s5 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var assert3 = require_minimalistic_assert();
    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init3(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert3(key.length <= this.blockSize);
      for (var i5 = key.length; i5 < this.blockSize; i5++)
        key.push(0);
      for (i5 = 0; i5 < key.length; i5++)
        key[i5] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i5 = 0; i5 < key.length; i5++)
        key[i5] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash2 = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var hash = exports;
    hash.utils = require_utils4();
    hash.common = require_common();
    hash.sha = require_sha3();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var curves = exports;
    var hash = require_hash2();
    var curve = require_curve();
    var utils = require_utils3();
    var assert3 = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert3(this.g.validate(), "Invalid curve");
      assert3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e5) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var hash = require_hash2();
    var utils = require_utils2();
    var assert3 = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert3(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init3(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i5 = 0; i5 < this.V.length; i5++) {
        this.K[i5] = 0;
        this.V[i5] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert3(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate2(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BN2 = require_bn4();
    var utils = require_utils3();
    var assert3 = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN2(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert3(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert3(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert3(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect4() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BN2 = require_bn4();
    var utils = require_utils3();
    var assert3 = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert3(options.r && options.s, "Signature without r or s");
      this.r = new BN2(options.r, 16);
      this.s = new BN2(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p5) {
      var initial = buf[p5.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i5 = 0, off3 = p5.place; i5 < octetLen; i5++, off3++) {
        val <<= 8;
        val |= buf[off3];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p5.place = off3;
      return val;
    }
    function rmPadding(buf) {
      var i5 = 0;
      var len = buf.length - 1;
      while (!buf[i5] && !(buf[i5 + 1] & 128) && i5 < len) {
        i5++;
      }
      if (i5 === 0) {
        return buf;
      }
      return buf.slice(i5);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p5 = new Position();
      if (data[p5.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p5);
      if (len === false) {
        return false;
      }
      if (len + p5.place !== data.length) {
        return false;
      }
      if (data[p5.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p5);
      if (rlen === false) {
        return false;
      }
      var r6 = data.slice(p5.place, rlen + p5.place);
      p5.place += rlen;
      if (data[p5.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p5);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p5.place) {
        return false;
      }
      var s5 = data.slice(p5.place, slen + p5.place);
      if (r6[0] === 0) {
        if (r6[1] & 128) {
          r6 = r6.slice(1);
        } else {
          return false;
        }
      }
      if (s5[0] === 0) {
        if (s5[1] & 128) {
          s5 = s5.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN2(r6);
      this.s = new BN2(s5);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r6 = this.r.toArray();
      var s5 = this.s.toArray();
      if (r6[0] & 128)
        r6 = [0].concat(r6);
      if (s5[0] & 128)
        s5 = [0].concat(s5);
      r6 = rmPadding(r6);
      s5 = rmPadding(s5);
      while (!s5[0] && !(s5[1] & 128)) {
        s5 = s5.slice(1);
      }
      var arr = [2];
      constructLength(arr, r6.length);
      arr = arr.concat(r6);
      arr.push(2);
      constructLength(arr, s5.length);
      var backHalf = arr.concat(s5);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BN2 = require_bn4();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils3();
    var curves = require_curves();
    var rand = require_brorand();
    var assert3 = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert3(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN2(2));
      for (; ; ) {
        var priv = new BN2(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN2(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN2(1));
      for (var iter = 0; ; iter++) {
        var k5 = options.k ? options.k(iter) : new BN2(drbg.generate(this.n.byteLength()));
        k5 = this._truncateToN(k5, true);
        if (k5.cmpn(1) <= 0 || k5.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k5);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r6 = kpX.umod(this.n);
        if (r6.cmpn(0) === 0)
          continue;
        var s5 = k5.invm(this.n).mul(r6.mul(key.getPrivate()).iadd(msg));
        s5 = s5.umod(this.n);
        if (s5.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r6) !== 0 ? 2 : 0);
        if (options.canonical && s5.cmp(this.nh) > 0) {
          s5 = this.n.sub(s5);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r6, s: s5, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
      msg = this._truncateToN(new BN2(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r6 = signature.r;
      var s5 = signature.s;
      if (r6.cmpn(1) < 0 || r6.cmp(this.n) >= 0)
        return false;
      if (s5.cmpn(1) < 0 || s5.cmp(this.n) >= 0)
        return false;
      var sinv = s5.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r6).umod(this.n);
      var p5;
      if (!this.curve._maxwellTrick) {
        p5 = this.g.mulAdd(u1, key.getPublic(), u22);
        if (p5.isInfinity())
          return false;
        return p5.getX().umod(this.n).cmp(r6) === 0;
      }
      p5 = this.g.jmulAdd(u1, key.getPublic(), u22);
      if (p5.isInfinity())
        return false;
      return p5.eqXToP(r6);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j5, enc) {
      assert3((3 & j5) === j5, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n3 = this.n;
      var e5 = new BN2(msg);
      var r6 = signature.r;
      var s5 = signature.s;
      var isYOdd = j5 & 1;
      var isSecondKey = j5 >> 1;
      if (r6.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r6 = this.curve.pointFromX(r6.add(this.curve.n), isYOdd);
      else
        r6 = this.curve.pointFromX(r6, isYOdd);
      var rInv = signature.r.invm(n3);
      var s1 = n3.sub(e5).mul(rInv).umod(n3);
      var s22 = s5.mul(rInv).umod(n3);
      return this.g.mulAdd(s1, r6, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e5, signature, Q2, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i5 = 0; i5 < 4; i5++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e5, signature, i5);
        } catch (e6) {
          continue;
        }
        if (Qprime.eq(Q2))
          return i5;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils3();
    var assert3 = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a5 = hash.slice(0, eddsa.encodingLength);
      a5[0] &= 248;
      a5[lastIx] &= 127;
      a5[lastIx] |= 64;
      return a5;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert3(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert3(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BN2 = require_bn4();
    var utils = require_utils3();
    var assert3 = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert3(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN2)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S3() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R2() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex3() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var hash = require_hash2();
    var curves = require_curves();
    var utils = require_utils3();
    var assert3 = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert3(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r6 = this.hashInt(key.messagePrefix(), message);
      var R2 = this.g.mul(r6);
      var Rencoded = this.encodePoint(R2);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S3 = r6.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R2, S: S3, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h5 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h5));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i5 = 0; i5 < arguments.length; i5++)
        hash2.update(arguments[i5]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y5 = utils.intFromLE(normed);
      return this.curve.pointFromY(y5, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils3();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/asn1.js/node_modules/bn.js/lib/bn.js
var require_bn5 = __commonJS({
  "node_modules/asn1.js/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base2, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e5) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i5 = number.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number[i5] | number[i5 - 1] << 8 | number[i5 - 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number.length; i5 += 3) {
            w6 = number[i5] | number[i5 + 1] << 8 | number[i5 + 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off3 = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number.length; i5 += 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN2.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i5, number.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r6 = new BN2(null);
        this.copy(r6);
        return r6;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength3; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN2.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN2.prototype._countBits(N4) - 1;
        for (var i5 = 0; i5 < N4; i5++) {
          t5[i5] = this.revBin(i5, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i5 = 0; i5 < N4; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s5 = 1; s5 < N4; s5 <<= 1) {
          var l5 = s5 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s5; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s5];
              var io = itws[p5 + j5 + s5];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s5] = re - ro;
              itws[p5 + j5 + s5] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N4 = Math.max(m5, n3) | 1;
        var odd = N4 & 1;
        var i5 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N4 - i5 - 1];
          rws[N4 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N4 - i5 - 1];
          iws[N4 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N4) * 8192 + Math.round(ws[2 * i5] / N4) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N4; ++i5) {
          rws[i5] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i5 = 0; i5 < N4; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _6 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _6, rwst, iwst, N4, rbt);
        this.transform(nrws, _6, nrwst, niwst, N4, rbt);
        for (var i5 = 0; i5 < N4; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _6, N4, rbt);
        this.conjugate(rmws, _6, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN2(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s5 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s5] = this.words[i5];
          }
          for (i5 = 0; i5 < s5; i5++) {
            this.words[i5] = 0;
          }
          this.length += s5;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s5 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s5;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s5; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s5;
        }
        if (s5 === 0) {
        } else if (this.length > s5) {
          this.length -= s5;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s5];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5)
          return false;
        var w6 = this.words[s5];
        return !!(w6 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s5) {
          return this;
        }
        if (r6 !== 0) {
          s5++;
        }
        this.length = Math.min(s5, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN2(1);
        var B4 = new BN2(0);
        var C4 = new BN2(0);
        var D3 = new BN2(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B4.isOdd()) {
                A6.iadd(yp);
                B4.isub(xp);
              }
              A6.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D3.isOdd()) {
                C4.iadd(yp);
                D3.isub(xp);
              }
              C4.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B4.isub(D3);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D3.isub(B4);
          }
        }
        return {
          a: C4,
          b: D3,
          gcd: y5.iushln(g5)
        };
      };
      BN2.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5) {
          this._expand(s5 + 1);
          this.words[s5] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s5; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN2(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN2._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s5 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s5++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z5 = this.m.bitLength();
        z5 = new BN2(2 * z5 * z5).toRed(this);
        while (this.pow(z5, lpow).cmp(nOne) !== 0) {
          z5.redIAdd(nOne);
        }
        var c5 = this.pow(z5, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s5;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert3(i5 < m5);
          var b4 = this.pow(c5, new BN2(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var buffer2 = require_buffer();
    var Buffer4 = buffer2.Buffer;
    var safer = {};
    var key;
    for (key in buffer2) {
      if (!buffer2.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer2[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer4) {
      if (!Buffer4.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer4[key];
    }
    safer.Buffer.prototype = Buffer4.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer4(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill3, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer4(size);
        if (!fill3 || fill3.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill3, encoding);
        } else {
          buf.fill(fill3);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e5) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module.exports = safer;
  }
});

// node_modules/asn1.js/lib/asn1/base/reporter.js
var require_reporter = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/reporter.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    function Reporter(options) {
      this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
      };
    }
    exports.Reporter = Reporter;
    Reporter.prototype.isError = function isError2(obj) {
      return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
      const state = this._reporterState;
      return { obj: state.obj, pathLen: state.path.length };
    };
    Reporter.prototype.restore = function restore(data) {
      const state = this._reporterState;
      state.obj = data.obj;
      state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key) {
      return this._reporterState.path.push(key);
    };
    Reporter.prototype.exitKey = function exitKey(index) {
      const state = this._reporterState;
      state.path = state.path.slice(0, index - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
      const state = this._reporterState;
      this.exitKey(index);
      if (state.obj !== null)
        state.obj[key] = value;
    };
    Reporter.prototype.path = function path() {
      return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
      const state = this._reporterState;
      const prev = state.obj;
      state.obj = {};
      return prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      const state = this._reporterState;
      const now = state.obj;
      state.obj = prev;
      return now;
    };
    Reporter.prototype.error = function error2(msg) {
      let err;
      const state = this._reporterState;
      const inherited = msg instanceof ReporterError;
      if (inherited) {
        err = msg;
      } else {
        err = new ReporterError(state.path.map(function(elem) {
          return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
      }
      if (!state.options.partial)
        throw err;
      if (!inherited)
        state.errors.push(err);
      return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
      const state = this._reporterState;
      if (!state.options.partial)
        return result;
      return {
        result: this.isError(result) ? null : result,
        errors: state.errors
      };
    };
    function ReporterError(path, msg) {
      this.path = path;
      this.rethrow(msg);
    }
    inherits2(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
      this.message = msg + " at: " + (this.path || "(shallow)");
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ReporterError);
      if (!this.stack) {
        try {
          throw new Error(this.message);
        } catch (e5) {
          this.stack = e5.stack;
        }
      }
      return this;
    };
  }
});

// node_modules/asn1.js/lib/asn1/base/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/buffer.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Reporter = require_reporter().Reporter;
    var Buffer4 = require_safer().Buffer;
    function DecoderBuffer(base2, options) {
      Reporter.call(this, options);
      if (!Buffer4.isBuffer(base2)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = base2;
      this.offset = 0;
      this.length = base2.length;
    }
    inherits2(DecoderBuffer, Reporter);
    exports.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
      if (data instanceof DecoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" && Buffer4.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
      return isCompatible;
    };
    DecoderBuffer.prototype.save = function save() {
      return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      const res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty2() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt83(fail2) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail2 || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip2(bytes, fail2) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail2 || "DecoderBuffer overrun");
      const res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
          if (!EncoderBuffer.isEncoderBuffer(item))
            item = new EncoderBuffer(item, reporter);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === "number") {
        if (!(0 <= value && value <= 255))
          return reporter.error("non-byte EncoderBuffer value");
        this.value = value;
        this.length = 1;
      } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer4.byteLength(value);
      } else if (Buffer4.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter.error("Unsupported type: " + typeof value);
      }
    }
    exports.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
      if (data instanceof EncoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
      return isCompatible;
    };
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out)
        out = Buffer4.alloc(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === "number")
          out[offset] = this.value;
        else if (typeof this.value === "string")
          out.write(this.value, offset);
        else if (Buffer4.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  }
});

// node_modules/asn1.js/lib/asn1/base/node.js
var require_node = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/node.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Reporter = require_reporter().Reporter;
    var EncoderBuffer = require_buffer2().EncoderBuffer;
    var DecoderBuffer = require_buffer2().DecoderBuffer;
    var assert3 = require_minimalistic_assert();
    var tags = [
      "seq",
      "seqof",
      "set",
      "setof",
      "objid",
      "bool",
      "gentime",
      "utctime",
      "null_",
      "enum",
      "int",
      "objDesc",
      "bitstr",
      "bmpstr",
      "charstr",
      "genstr",
      "graphstr",
      "ia5str",
      "iso646str",
      "numstr",
      "octstr",
      "printstr",
      "t61str",
      "unistr",
      "utf8str",
      "videostr"
    ];
    var methods = [
      "key",
      "obj",
      "use",
      "optional",
      "explicit",
      "implicit",
      "def",
      "choice",
      "any",
      "contains"
    ].concat(tags);
    var overrided = [
      "_peekTag",
      "_decodeTag",
      "_use",
      "_decodeStr",
      "_decodeObjid",
      "_decodeTime",
      "_decodeNull",
      "_decodeInt",
      "_decodeBool",
      "_decodeList",
      "_encodeComposite",
      "_encodeStr",
      "_encodeObjid",
      "_encodeTime",
      "_encodeNull",
      "_encodeInt",
      "_encodeBool"
    ];
    function Node(enc, parent, name) {
      const state = {};
      this._baseState = state;
      state.name = name;
      state.enc = enc;
      state.parent = parent || null;
      state.children = null;
      state.tag = null;
      state.args = null;
      state.reverseArgs = null;
      state.choice = null;
      state.optional = false;
      state.any = false;
      state.obj = false;
      state.use = null;
      state.useDecoder = null;
      state.key = null;
      state["default"] = null;
      state.explicit = null;
      state.implicit = null;
      state.contains = null;
      if (!state.parent) {
        state.children = [];
        this._wrap();
      }
    }
    module.exports = Node;
    var stateProps = [
      "enc",
      "parent",
      "children",
      "tag",
      "args",
      "reverseArgs",
      "choice",
      "optional",
      "any",
      "obj",
      "use",
      "alteredUse",
      "key",
      "default",
      "explicit",
      "implicit",
      "contains"
    ];
    Node.prototype.clone = function clone() {
      const state = this._baseState;
      const cstate = {};
      stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
      });
      const res = new this.constructor(cstate.parent);
      res._baseState = cstate;
      return res;
    };
    Node.prototype._wrap = function wrap() {
      const state = this._baseState;
      methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
          const clone = new this.constructor(this);
          state.children.push(clone);
          return clone[method].apply(clone, arguments);
        };
      }, this);
    };
    Node.prototype._init = function init3(body) {
      const state = this._baseState;
      assert3(state.parent === null);
      body.call(this);
      state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
      }, this);
      assert3.equal(state.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
      const state = this._baseState;
      const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
      }, this);
      args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
      }, this);
      if (children.length !== 0) {
        assert3(state.children === null);
        state.children = children;
        children.forEach(function(child) {
          child._baseState.parent = this;
        }, this);
      }
      if (args.length !== 0) {
        assert3(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
          if (typeof arg !== "object" || arg.constructor !== Object)
            return arg;
          const res = {};
          Object.keys(arg).forEach(function(key) {
            if (key == (key | 0))
              key |= 0;
            const value = arg[key];
            res[value] = key;
          });
          return res;
        });
      }
    };
    overrided.forEach(function(method) {
      Node.prototype[method] = function _overrided() {
        const state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
      };
    });
    tags.forEach(function(tag) {
      Node.prototype[tag] = function _tagMethod() {
        const state = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert3(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
      };
    });
    Node.prototype.use = function use(item) {
      assert3(item);
      const state = this._baseState;
      assert3(state.use === null);
      state.use = item;
      return this;
    };
    Node.prototype.optional = function optional() {
      const state = this._baseState;
      state.optional = true;
      return this;
    };
    Node.prototype.def = function def(val) {
      const state = this._baseState;
      assert3(state["default"] === null);
      state["default"] = val;
      state.optional = true;
      return this;
    };
    Node.prototype.explicit = function explicit(num) {
      const state = this._baseState;
      assert3(state.explicit === null && state.implicit === null);
      state.explicit = num;
      return this;
    };
    Node.prototype.implicit = function implicit(num) {
      const state = this._baseState;
      assert3(state.explicit === null && state.implicit === null);
      state.implicit = num;
      return this;
    };
    Node.prototype.obj = function obj() {
      const state = this._baseState;
      const args = Array.prototype.slice.call(arguments);
      state.obj = true;
      if (args.length !== 0)
        this._useArgs(args);
      return this;
    };
    Node.prototype.key = function key(newKey) {
      const state = this._baseState;
      assert3(state.key === null);
      state.key = newKey;
      return this;
    };
    Node.prototype.any = function any() {
      const state = this._baseState;
      state.any = true;
      return this;
    };
    Node.prototype.choice = function choice(obj) {
      const state = this._baseState;
      assert3(state.choice === null);
      state.choice = obj;
      this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
      }));
      return this;
    };
    Node.prototype.contains = function contains(item) {
      const state = this._baseState;
      assert3(state.use === null);
      state.contains = item;
      return this;
    };
    Node.prototype._decode = function decode(input, options) {
      const state = this._baseState;
      if (state.parent === null)
        return input.wrapResult(state.children[0]._decode(input, options));
      let result = state["default"];
      let present = true;
      let prevKey = null;
      if (state.key !== null)
        prevKey = input.enterKey(state.key);
      if (state.optional) {
        let tag = null;
        if (state.explicit !== null)
          tag = state.explicit;
        else if (state.implicit !== null)
          tag = state.implicit;
        else if (state.tag !== null)
          tag = state.tag;
        if (tag === null && !state.any) {
          const save = input.save();
          try {
            if (state.choice === null)
              this._decodeGeneric(state.tag, input, options);
            else
              this._decodeChoice(input, options);
            present = true;
          } catch (e5) {
            present = false;
          }
          input.restore(save);
        } else {
          present = this._peekTag(input, tag, state.any);
          if (input.isError(present))
            return present;
        }
      }
      let prevObj;
      if (state.obj && present)
        prevObj = input.enterObject();
      if (present) {
        if (state.explicit !== null) {
          const explicit = this._decodeTag(input, state.explicit);
          if (input.isError(explicit))
            return explicit;
          input = explicit;
        }
        const start = input.offset;
        if (state.use === null && state.choice === null) {
          let save;
          if (state.any)
            save = input.save();
          const body = this._decodeTag(
            input,
            state.implicit !== null ? state.implicit : state.tag,
            state.any
          );
          if (input.isError(body))
            return body;
          if (state.any)
            result = input.raw(save);
          else
            input = body;
        }
        if (options && options.track && state.tag !== null)
          options.track(input.path(), start, input.length, "tagged");
        if (options && options.track && state.tag !== null)
          options.track(input.path(), input.offset, input.length, "content");
        if (state.any) {
        } else if (state.choice === null) {
          result = this._decodeGeneric(state.tag, input, options);
        } else {
          result = this._decodeChoice(input, options);
        }
        if (input.isError(result))
          return result;
        if (!state.any && state.choice === null && state.children !== null) {
          state.children.forEach(function decodeChildren(child) {
            child._decode(input, options);
          });
        }
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
          const data = new DecoderBuffer(result);
          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
      }
      if (state.obj && present)
        result = input.leaveObject(prevObj);
      if (state.key !== null && (result !== null || present === true))
        input.leaveKey(prevKey, state.key, result);
      else if (prevKey !== null)
        input.exitKey(prevKey);
      return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
      const state = this._baseState;
      if (tag === "seq" || tag === "set")
        return null;
      if (tag === "seqof" || tag === "setof")
        return this._decodeList(input, tag, state.args[0], options);
      else if (/str$/.test(tag))
        return this._decodeStr(input, tag, options);
      else if (tag === "objid" && state.args)
        return this._decodeObjid(input, state.args[0], state.args[1], options);
      else if (tag === "objid")
        return this._decodeObjid(input, null, null, options);
      else if (tag === "gentime" || tag === "utctime")
        return this._decodeTime(input, tag, options);
      else if (tag === "null_")
        return this._decodeNull(input, options);
      else if (tag === "bool")
        return this._decodeBool(input, options);
      else if (tag === "objDesc")
        return this._decodeStr(input, tag, options);
      else if (tag === "int" || tag === "enum")
        return this._decodeInt(input, state.args && state.args[0], options);
      if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
      } else {
        return input.error("unknown tag: " + tag);
      }
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
      const state = this._baseState;
      state.useDecoder = this._use(entity, obj);
      assert3(state.useDecoder._baseState.parent === null);
      state.useDecoder = state.useDecoder._baseState.children[0];
      if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
      }
      return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options) {
      const state = this._baseState;
      let result = null;
      let match = false;
      Object.keys(state.choice).some(function(key) {
        const save = input.save();
        const node = state.choice[key];
        try {
          const value = node._decode(input, options);
          if (input.isError(value))
            return false;
          result = { type: key, value };
          match = true;
        } catch (e5) {
          input.restore(save);
          return false;
        }
        return true;
      }, this);
      if (!match)
        return input.error("Choice not matched");
      return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode2(data, reporter, parent) {
      const state = this._baseState;
      if (state["default"] !== null && state["default"] === data)
        return;
      const result = this._encodeValue(data, reporter, parent);
      if (result === void 0)
        return;
      if (this._skipDefault(result, reporter, parent))
        return;
      return result;
    };
    Node.prototype._encodeValue = function encode2(data, reporter, parent) {
      const state = this._baseState;
      if (state.parent === null)
        return state.children[0]._encode(data, reporter || new Reporter());
      let result = null;
      this.reporter = reporter;
      if (state.optional && data === void 0) {
        if (state["default"] !== null)
          data = state["default"];
        else
          return;
      }
      let content = null;
      let primitive = false;
      if (state.any) {
        result = this._createEncoderBuffer(data);
      } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
      } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
      } else if (state.children) {
        content = state.children.map(function(child) {
          if (child._baseState.tag === "null_")
            return child._encode(null, reporter, data);
          if (child._baseState.key === null)
            return reporter.error("Child should have a key");
          const prevKey = reporter.enterKey(child._baseState.key);
          if (typeof data !== "object")
            return reporter.error("Child expected, but input is not object");
          const res = child._encode(data[child._baseState.key], reporter, data);
          reporter.leaveKey(prevKey);
          return res;
        }, this).filter(function(child) {
          return child;
        });
        content = this._createEncoderBuffer(content);
      } else {
        if (state.tag === "seqof" || state.tag === "setof") {
          if (!(state.args && state.args.length === 1))
            return reporter.error("Too many args for : " + state.tag);
          if (!Array.isArray(data))
            return reporter.error("seqof/setof, but data is not Array");
          const child = this.clone();
          child._baseState.implicit = null;
          content = this._createEncoderBuffer(data.map(function(item) {
            const state2 = this._baseState;
            return this._getUse(state2.args[0], data)._encode(item, reporter);
          }, child));
        } else if (state.use !== null) {
          result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
          content = this._encodePrimitive(state.tag, data);
          primitive = true;
        }
      }
      if (!state.any && state.choice === null) {
        const tag = state.implicit !== null ? state.implicit : state.tag;
        const cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
          if (state.use === null)
            reporter.error("Tag could be omitted only for .use()");
        } else {
          if (state.use === null)
            result = this._encodeComposite(tag, primitive, cls, content);
        }
      }
      if (state.explicit !== null)
        result = this._encodeComposite(state.explicit, false, "context", result);
      return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
      const state = this._baseState;
      const node = state.choice[data.type];
      if (!node) {
        assert3(
          false,
          data.type + " not found in " + JSON.stringify(Object.keys(state.choice))
        );
      }
      return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
      const state = this._baseState;
      if (/str$/.test(tag))
        return this._encodeStr(data, tag);
      else if (tag === "objid" && state.args)
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
      else if (tag === "objid")
        return this._encodeObjid(data, null, null);
      else if (tag === "gentime" || tag === "utctime")
        return this._encodeTime(data, tag);
      else if (tag === "null_")
        return this._encodeNull();
      else if (tag === "int" || tag === "enum")
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
      else if (tag === "bool")
        return this._encodeBool(data);
      else if (tag === "objDesc")
        return this._encodeStr(data, tag);
      else
        throw new Error("Unsupported tag: " + tag);
    };
    Node.prototype._isNumstr = function isNumstr(str) {
      return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
    };
  }
});

// node_modules/asn1.js/lib/asn1/constants/der.js
var require_der = __commonJS({
  "node_modules/asn1.js/lib/asn1/constants/der.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function reverse(map4) {
      const res = {};
      Object.keys(map4).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        const value = map4[key];
        res[value] = key;
      });
      return res;
    }
    exports.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    };
    exports.tagClassByName = reverse(exports.tagClass);
    exports.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    };
    exports.tagByName = reverse(exports.tag);
  }
});

// node_modules/asn1.js/lib/asn1/encoders/der.js
var require_der2 = __commonJS({
  "node_modules/asn1.js/lib/asn1/encoders/der.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Buffer4 = require_safer().Buffer;
    var Node = require_node();
    var der = require_der();
    function DEREncoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode2(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits2(DERNode, Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 128) {
        const header2 = Buffer4.alloc(2);
        header2[0] = encodedTag;
        header2[1] = content.length;
        return this._createEncoderBuffer([header2, content]);
      }
      let lenOctets = 1;
      for (let i5 = content.length; i5 >= 256; i5 >>= 8)
        lenOctets++;
      const header = Buffer4.alloc(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 128 | lenOctets;
      for (let i5 = 1 + lenOctets, j5 = content.length; j5 > 0; i5--, j5 >>= 8)
        header[i5] = j5 & 255;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === "bitstr") {
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      } else if (tag === "bmpstr") {
        const buf = Buffer4.alloc(str.length * 2);
        for (let i5 = 0; i5 < str.length; i5++) {
          buf.writeUInt16BE(str.charCodeAt(i5), i5 * 2);
        }
        return this._createEncoderBuffer(buf);
      } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
          return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        }
        return this._createEncoderBuffer(str);
      } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
          return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        }
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
      } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
      } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
      if (typeof id === "string") {
        if (!values)
          return this.reporter.error("string objid given, but no values map found");
        if (!values.hasOwnProperty(id))
          return this.reporter.error("objid not found in values map");
        id = values[id].split(/[\s.]+/g);
        for (let i5 = 0; i5 < id.length; i5++)
          id[i5] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
        for (let i5 = 0; i5 < id.length; i5++)
          id[i5] |= 0;
      }
      if (!Array.isArray(id)) {
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
      }
      if (!relative) {
        if (id[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      let size = 0;
      for (let i5 = 0; i5 < id.length; i5++) {
        let ident = id[i5];
        for (size++; ident >= 128; ident >>= 7)
          size++;
      }
      const objid = Buffer4.alloc(size);
      let offset = objid.length - 1;
      for (let i5 = id.length - 1; i5 >= 0; i5--) {
        let ident = id[i5];
        objid[offset--] = ident & 127;
        while ((ident >>= 7) > 0)
          objid[offset--] = 128 | ident & 127;
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10)
        return "0" + num;
      else
        return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      let str;
      const date = new Date(time);
      if (tag === "gentime") {
        str = [
          two(date.getUTCFullYear()),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else if (tag === "utctime") {
        str = [
          two(date.getUTCFullYear() % 100),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
      }
      return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === "string") {
        if (!values)
          return this.reporter.error("String int or enum given, but no values map");
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
      }
      if (typeof num !== "number" && !Buffer4.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 128) {
          numArray.unshift(0);
        }
        num = Buffer4.from(numArray);
      }
      if (Buffer4.isBuffer(num)) {
        let size2 = num.length;
        if (num.length === 0)
          size2++;
        const out2 = Buffer4.alloc(size2);
        num.copy(out2);
        if (num.length === 0)
          out2[0] = 0;
        return this._createEncoderBuffer(out2);
      }
      if (num < 128)
        return this._createEncoderBuffer(num);
      if (num < 256)
        return this._createEncoderBuffer([0, num]);
      let size = 1;
      for (let i5 = num; i5 >= 256; i5 >>= 8)
        size++;
      const out = new Array(size);
      for (let i5 = out.length - 1; i5 >= 0; i5--) {
        out[i5] = num & 255;
        num >>= 8;
      }
      if (out[0] & 128) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(Buffer4.from(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      const state = this._baseState;
      let i5;
      if (state["default"] === null)
        return false;
      const data = dataBuffer.join();
      if (state.defaultBuffer === void 0)
        state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
      if (data.length !== state.defaultBuffer.length)
        return false;
      for (i5 = 0; i5 < data.length; i5++)
        if (data[i5] !== state.defaultBuffer[i5])
          return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
      let res;
      if (tag === "seqof")
        tag = "seq";
      else if (tag === "setof")
        tag = "set";
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === "number" && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error("Unknown tag: " + tag);
      if (res >= 31)
        return reporter.error("Multi-octet tag encoding unsupported");
      if (!primitive)
        res |= 32;
      res |= der.tagClassByName[cls || "universal"] << 6;
      return res;
    }
  }
});

// node_modules/asn1.js/lib/asn1/encoders/pem.js
var require_pem = __commonJS({
  "node_modules/asn1.js/lib/asn1/encoders/pem.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var DEREncoder = require_der2();
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity);
      this.enc = "pem";
    }
    inherits2(PEMEncoder, DEREncoder);
    module.exports = PEMEncoder;
    PEMEncoder.prototype.encode = function encode2(data, options) {
      const buf = DEREncoder.prototype.encode.call(this, data);
      const p5 = buf.toString("base64");
      const out = ["-----BEGIN " + options.label + "-----"];
      for (let i5 = 0; i5 < p5.length; i5 += 64)
        out.push(p5.slice(i5, i5 + 64));
      out.push("-----END " + options.label + "-----");
      return out.join("\n");
    };
  }
});

// node_modules/asn1.js/lib/asn1/encoders/index.js
var require_encoders = __commonJS({
  "node_modules/asn1.js/lib/asn1/encoders/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var encoders = exports;
    encoders.der = require_der2();
    encoders.pem = require_pem();
  }
});

// node_modules/asn1.js/lib/asn1/decoders/der.js
var require_der3 = __commonJS({
  "node_modules/asn1.js/lib/asn1/decoders/der.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var bignum = require_bn5();
    var DecoderBuffer = require_buffer2().DecoderBuffer;
    var Node = require_node();
    var der = require_der();
    function DERDecoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module.exports = DERDecoder;
    DERDecoder.prototype.decode = function decode(data, options) {
      if (!DecoderBuffer.isDecoderBuffer(data)) {
        data = new DecoderBuffer(data, options);
      }
      return this.tree._decode(data, options);
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits2(DERNode, Node);
    DERNode.prototype._peekTag = function peekTag(buffer2, tag, any) {
      if (buffer2.isEmpty())
        return false;
      const state = buffer2.save();
      const decodedTag = derDecodeTag(buffer2, 'Failed to peek tag: "' + tag + '"');
      if (buffer2.isError(decodedTag))
        return decodedTag;
      buffer2.restore(state);
      return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer2, tag, any) {
      const decodedTag = derDecodeTag(
        buffer2,
        'Failed to decode tag of "' + tag + '"'
      );
      if (buffer2.isError(decodedTag))
        return decodedTag;
      let len = derDecodeLen(
        buffer2,
        decodedTag.primitive,
        'Failed to get length of "' + tag + '"'
      );
      if (buffer2.isError(len))
        return len;
      if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer2.error('Failed to match tag: "' + tag + '"');
      }
      if (decodedTag.primitive || len !== null)
        return buffer2.skip(len, 'Failed to match body of: "' + tag + '"');
      const state = buffer2.save();
      const res = this._skipUntilEnd(
        buffer2,
        'Failed to skip indefinite length body: "' + this.tag + '"'
      );
      if (buffer2.isError(res))
        return res;
      len = buffer2.offset - state.offset;
      buffer2.restore(state);
      return buffer2.skip(len, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer2, fail2) {
      for (; ; ) {
        const tag = derDecodeTag(buffer2, fail2);
        if (buffer2.isError(tag))
          return tag;
        const len = derDecodeLen(buffer2, tag.primitive, fail2);
        if (buffer2.isError(len))
          return len;
        let res;
        if (tag.primitive || len !== null)
          res = buffer2.skip(len);
        else
          res = this._skipUntilEnd(buffer2, fail2);
        if (buffer2.isError(res))
          return res;
        if (tag.tagStr === "end")
          break;
      }
    };
    DERNode.prototype._decodeList = function decodeList(buffer2, tag, decoder, options) {
      const result = [];
      while (!buffer2.isEmpty()) {
        const possibleEnd = this._peekTag(buffer2, "end");
        if (buffer2.isError(possibleEnd))
          return possibleEnd;
        const res = decoder.decode(buffer2, "der", options);
        if (buffer2.isError(res) && possibleEnd)
          break;
        result.push(res);
      }
      return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer2, tag) {
      if (tag === "bitstr") {
        const unused = buffer2.readUInt8();
        if (buffer2.isError(unused))
          return unused;
        return { unused, data: buffer2.raw() };
      } else if (tag === "bmpstr") {
        const raw = buffer2.raw();
        if (raw.length % 2 === 1)
          return buffer2.error("Decoding of string type: bmpstr length mismatch");
        let str = "";
        for (let i5 = 0; i5 < raw.length / 2; i5++) {
          str += String.fromCharCode(raw.readUInt16BE(i5 * 2));
        }
        return str;
      } else if (tag === "numstr") {
        const numstr = buffer2.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
          return buffer2.error("Decoding of string type: numstr unsupported characters");
        }
        return numstr;
      } else if (tag === "octstr") {
        return buffer2.raw();
      } else if (tag === "objDesc") {
        return buffer2.raw();
      } else if (tag === "printstr") {
        const printstr = buffer2.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
          return buffer2.error("Decoding of string type: printstr unsupported characters");
        }
        return printstr;
      } else if (/str$/.test(tag)) {
        return buffer2.raw().toString();
      } else {
        return buffer2.error("Decoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer2, values, relative) {
      let result;
      const identifiers = [];
      let ident = 0;
      let subident = 0;
      while (!buffer2.isEmpty()) {
        subident = buffer2.readUInt8();
        ident <<= 7;
        ident |= subident & 127;
        if ((subident & 128) === 0) {
          identifiers.push(ident);
          ident = 0;
        }
      }
      if (subident & 128)
        identifiers.push(ident);
      const first2 = identifiers[0] / 40 | 0;
      const second = identifiers[0] % 40;
      if (relative)
        result = identifiers;
      else
        result = [first2, second].concat(identifiers.slice(1));
      if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === void 0)
          tmp = values[result.join(".")];
        if (tmp !== void 0)
          result = tmp;
      }
      return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer2, tag) {
      const str = buffer2.raw().toString();
      let year;
      let mon;
      let day;
      let hour;
      let min2;
      let sec;
      if (tag === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min2 = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
      } else if (tag === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min2 = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70)
          year = 2e3 + year;
        else
          year = 1900 + year;
      } else {
        return buffer2.error("Decoding " + tag + " time is not supported yet");
      }
      return Date.UTC(year, mon - 1, day, hour, min2, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull() {
      return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer2) {
      const res = buffer2.readUInt8();
      if (buffer2.isError(res))
        return res;
      else
        return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer2, values) {
      const raw = buffer2.raw();
      let res = new bignum(raw);
      if (values)
        res = values[res.toString(10)] || res;
      return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail2) {
      let tag = buf.readUInt8(fail2);
      if (buf.isError(tag))
        return tag;
      const cls = der.tagClass[tag >> 6];
      const primitive = (tag & 32) === 0;
      if ((tag & 31) === 31) {
        let oct = tag;
        tag = 0;
        while ((oct & 128) === 128) {
          oct = buf.readUInt8(fail2);
          if (buf.isError(oct))
            return oct;
          tag <<= 7;
          tag |= oct & 127;
        }
      } else {
        tag &= 31;
      }
      const tagStr = der.tag[tag];
      return {
        cls,
        primitive,
        tag,
        tagStr
      };
    }
    function derDecodeLen(buf, primitive, fail2) {
      let len = buf.readUInt8(fail2);
      if (buf.isError(len))
        return len;
      if (!primitive && len === 128)
        return null;
      if ((len & 128) === 0) {
        return len;
      }
      const num = len & 127;
      if (num > 4)
        return buf.error("length octect is too long");
      len = 0;
      for (let i5 = 0; i5 < num; i5++) {
        len <<= 8;
        const j5 = buf.readUInt8(fail2);
        if (buf.isError(j5))
          return j5;
        len |= j5;
      }
      return len;
    }
  }
});

// node_modules/asn1.js/lib/asn1/decoders/pem.js
var require_pem2 = __commonJS({
  "node_modules/asn1.js/lib/asn1/decoders/pem.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Buffer4 = require_safer().Buffer;
    var DERDecoder = require_der3();
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = "pem";
    }
    inherits2(PEMDecoder, DERDecoder);
    module.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode(data, options) {
      const lines = data.toString().split(/[\r\n]+/g);
      const label = options.label.toUpperCase();
      const re = /^-----(BEGIN|END) ([^-]+)-----$/;
      let start = -1;
      let end = -1;
      for (let i5 = 0; i5 < lines.length; i5++) {
        const match = lines[i5].match(re);
        if (match === null)
          continue;
        if (match[2] !== label)
          continue;
        if (start === -1) {
          if (match[1] !== "BEGIN")
            break;
          start = i5;
        } else {
          if (match[1] !== "END")
            break;
          end = i5;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error("PEM section not found for: " + label);
      const base64 = lines.slice(start + 1, end).join("");
      base64.replace(/[^a-z0-9+/=]+/gi, "");
      const input = Buffer4.from(base64, "base64");
      return DERDecoder.prototype.decode.call(this, input, options);
    };
  }
});

// node_modules/asn1.js/lib/asn1/decoders/index.js
var require_decoders = __commonJS({
  "node_modules/asn1.js/lib/asn1/decoders/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var decoders = exports;
    decoders.der = require_der3();
    decoders.pem = require_pem2();
  }
});

// node_modules/asn1.js/lib/asn1/api.js
var require_api = __commonJS({
  "node_modules/asn1.js/lib/asn1/api.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var encoders = require_encoders();
    var decoders = require_decoders();
    var inherits2 = require_inherits_browser();
    var api = exports;
    api.define = function define2(name, body) {
      return new Entity(name, body);
    };
    function Entity(name, body) {
      this.name = name;
      this.body = body;
      this.decoders = {};
      this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(Base) {
      const name = this.name;
      function Generated(entity) {
        this._initNamed(entity, name);
      }
      inherits2(Generated, Base);
      Generated.prototype._initNamed = function _initNamed(entity, name2) {
        Base.call(this, entity, name2);
      };
      return new Generated(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      enc = enc || "der";
      if (!this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(decoders[enc]);
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode(data, enc, options) {
      return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      enc = enc || "der";
      if (!this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(encoders[enc]);
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode2(data, enc, reporter) {
      return this._getEncoder(enc).encode(data, reporter);
    };
  }
});

// node_modules/asn1.js/lib/asn1/base/index.js
var require_base2 = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var base2 = exports;
    base2.Reporter = require_reporter().Reporter;
    base2.DecoderBuffer = require_buffer2().DecoderBuffer;
    base2.EncoderBuffer = require_buffer2().EncoderBuffer;
    base2.Node = require_node();
  }
});

// node_modules/asn1.js/lib/asn1/constants/index.js
var require_constants = __commonJS({
  "node_modules/asn1.js/lib/asn1/constants/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var constants = exports;
    constants._reverse = function reverse(map4) {
      const res = {};
      Object.keys(map4).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        const value = map4[key];
        res[value] = key;
      });
      return res;
    };
    constants.der = require_der();
  }
});

// node_modules/asn1.js/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/asn1.js/lib/asn1.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var asn1 = exports;
    asn1.bignum = require_bn5();
    asn1.define = require_api().define;
    asn1.base = require_base2();
    asn1.constants = require_constants();
    asn1.decoders = require_decoders();
    asn1.encoders = require_encoders();
  }
});

// node_modules/parse-asn1/certificate.js
var require_certificate = __commonJS({
  "node_modules/parse-asn1/certificate.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var asn = require_asn1();
    var Time = asn.define("Time", function() {
      this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
      });
    });
    var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
      this.seq().obj(
        this.key("type").objid(),
        this.key("value").any()
      );
    });
    var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
      this.seq().obj(
        this.key("algorithm").objid(),
        this.key("parameters").optional(),
        this.key("curve").objid().optional()
      );
    });
    var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPublicKey").bitstr()
      );
    });
    var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
      this.setof(AttributeTypeValue);
    });
    var RDNSequence = asn.define("RDNSequence", function() {
      this.seqof(RelativeDistinguishedName);
    });
    var Name = asn.define("Name", function() {
      this.choice({
        rdnSequence: this.use(RDNSequence)
      });
    });
    var Validity = asn.define("Validity", function() {
      this.seq().obj(
        this.key("notBefore").use(Time),
        this.key("notAfter").use(Time)
      );
    });
    var Extension = asn.define("Extension", function() {
      this.seq().obj(
        this.key("extnID").objid(),
        this.key("critical").bool().def(false),
        this.key("extnValue").octstr()
      );
    });
    var TBSCertificate = asn.define("TBSCertificate", function() {
      this.seq().obj(
        this.key("version").explicit(0).int().optional(),
        this.key("serialNumber").int(),
        this.key("signature").use(AlgorithmIdentifier),
        this.key("issuer").use(Name),
        this.key("validity").use(Validity),
        this.key("subject").use(Name),
        this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
        this.key("issuerUniqueID").implicit(1).bitstr().optional(),
        this.key("subjectUniqueID").implicit(2).bitstr().optional(),
        this.key("extensions").explicit(3).seqof(Extension).optional()
      );
    });
    var X509Certificate = asn.define("X509Certificate", function() {
      this.seq().obj(
        this.key("tbsCertificate").use(TBSCertificate),
        this.key("signatureAlgorithm").use(AlgorithmIdentifier),
        this.key("signatureValue").bitstr()
      );
    });
    module.exports = X509Certificate;
  }
});

// node_modules/parse-asn1/asn1.js
var require_asn12 = __commonJS({
  "node_modules/parse-asn1/asn1.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var asn1 = require_asn1();
    exports.certificate = require_certificate();
    var RSAPrivateKey = asn1.define("RSAPrivateKey", function() {
      this.seq().obj(
        this.key("version").int(),
        this.key("modulus").int(),
        this.key("publicExponent").int(),
        this.key("privateExponent").int(),
        this.key("prime1").int(),
        this.key("prime2").int(),
        this.key("exponent1").int(),
        this.key("exponent2").int(),
        this.key("coefficient").int()
      );
    });
    exports.RSAPrivateKey = RSAPrivateKey;
    var RSAPublicKey = asn1.define("RSAPublicKey", function() {
      this.seq().obj(
        this.key("modulus").int(),
        this.key("publicExponent").int()
      );
    });
    exports.RSAPublicKey = RSAPublicKey;
    var PublicKey = asn1.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPublicKey").bitstr()
      );
    });
    exports.PublicKey = PublicKey;
    var AlgorithmIdentifier = asn1.define("AlgorithmIdentifier", function() {
      this.seq().obj(
        this.key("algorithm").objid(),
        this.key("none").null_().optional(),
        this.key("curve").objid().optional(),
        this.key("params").seq().obj(
          this.key("p").int(),
          this.key("q").int(),
          this.key("g").int()
        ).optional()
      );
    });
    var PrivateKeyInfo = asn1.define("PrivateKeyInfo", function() {
      this.seq().obj(
        this.key("version").int(),
        this.key("algorithm").use(AlgorithmIdentifier),
        this.key("subjectPrivateKey").octstr()
      );
    });
    exports.PrivateKey = PrivateKeyInfo;
    var EncryptedPrivateKeyInfo = asn1.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(
        this.key("algorithm").seq().obj(
          this.key("id").objid(),
          this.key("decrypt").seq().obj(
            this.key("kde").seq().obj(
              this.key("id").objid(),
              this.key("kdeparams").seq().obj(
                this.key("salt").octstr(),
                this.key("iters").int()
              )
            ),
            this.key("cipher").seq().obj(
              this.key("algo").objid(),
              this.key("iv").octstr()
            )
          )
        ),
        this.key("subjectPrivateKey").octstr()
      );
    });
    exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
    var DSAPrivateKey = asn1.define("DSAPrivateKey", function() {
      this.seq().obj(
        this.key("version").int(),
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int(),
        this.key("pub_key").int(),
        this.key("priv_key").int()
      );
    });
    exports.DSAPrivateKey = DSAPrivateKey;
    exports.DSAparam = asn1.define("DSAparam", function() {
      this.int();
    });
    var ECPrivateKey = asn1.define("ECPrivateKey", function() {
      this.seq().obj(
        this.key("version").int(),
        this.key("privateKey").octstr(),
        this.key("parameters").optional().explicit(0).use(ECParameters),
        this.key("publicKey").optional().explicit(1).bitstr()
      );
    });
    exports.ECPrivateKey = ECPrivateKey;
    var ECParameters = asn1.define("ECParameters", function() {
      this.choice({
        namedCurve: this.objid()
      });
    });
    exports.signature = asn1.define("signature", function() {
      this.seq().obj(
        this.key("r").int(),
        this.key("s").int()
      );
    });
  }
});

// node_modules/parse-asn1/aesid.json
var require_aesid = __commonJS({
  "node_modules/parse-asn1/aesid.json"(exports, module) {
    module.exports = {
      "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
      "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
      "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
      "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
      "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
      "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
      "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
      "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
      "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
      "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
      "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
      "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
    };
  }
});

// node_modules/parse-asn1/fixProc.js
var require_fixProc = __commonJS({
  "node_modules/parse-asn1/fixProc.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
    var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
    var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
    var evp = require_evp_bytestokey();
    var ciphers = require_browser6();
    var Buffer4 = require_safe_buffer().Buffer;
    module.exports = function(okey, password) {
      var key = okey.toString();
      var match = key.match(findProc);
      var decrypted;
      if (!match) {
        var match2 = key.match(fullRegex);
        decrypted = Buffer4.from(match2[2].replace(/[\r\n]/g, ""), "base64");
      } else {
        var suite = "aes" + match[1];
        var iv = Buffer4.from(match[2], "hex");
        var cipherText = Buffer4.from(match[3].replace(/[\r\n]/g, ""), "base64");
        var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
        var out = [];
        var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer4.concat(out);
      }
      var tag = key.match(startRegex)[1];
      return {
        tag,
        data: decrypted
      };
    };
  }
});

// node_modules/parse-asn1/index.js
var require_parse_asn1 = __commonJS({
  "node_modules/parse-asn1/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var asn1 = require_asn12();
    var aesid = require_aesid();
    var fixProc = require_fixProc();
    var ciphers = require_browser6();
    var compat = require_browser5();
    var Buffer4 = require_safe_buffer().Buffer;
    module.exports = parseKeys;
    function parseKeys(buffer2) {
      var password;
      if (typeof buffer2 === "object" && !Buffer4.isBuffer(buffer2)) {
        password = buffer2.passphrase;
        buffer2 = buffer2.key;
      }
      if (typeof buffer2 === "string") {
        buffer2 = Buffer4.from(buffer2);
      }
      var stripped = fixProc(buffer2, password);
      var type2 = stripped.tag;
      var data = stripped.data;
      var subtype, ndata;
      switch (type2) {
        case "CERTIFICATE":
          ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          if (!ndata) {
            ndata = asn1.PublicKey.decode(data, "der");
          }
          subtype = ndata.algorithm.algorithm.join(".");
          switch (subtype) {
            case "1.2.840.113549.1.1.1":
              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              ndata.subjectPrivateKey = ndata.subjectPublicKey;
              return {
                type: "ec",
                data: ndata
              };
            case "1.2.840.10040.4.1":
              ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der");
              return {
                type: "dsa",
                data: ndata.algorithm.params
              };
            default:
              throw new Error("unknown key id " + subtype);
          }
        case "ENCRYPTED PRIVATE KEY":
          data = asn1.EncryptedPrivateKey.decode(data, "der");
          data = decrypt2(data, password);
        case "PRIVATE KEY":
          ndata = asn1.PrivateKey.decode(data, "der");
          subtype = ndata.algorithm.algorithm.join(".");
          switch (subtype) {
            case "1.2.840.113549.1.1.1":
              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return {
                curve: ndata.algorithm.curve,
                privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
              };
            case "1.2.840.10040.4.1":
              ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der");
              return {
                type: "dsa",
                params: ndata.algorithm.params
              };
            default:
              throw new Error("unknown key id " + subtype);
          }
        case "RSA PUBLIC KEY":
          return asn1.RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
          return asn1.RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
          return {
            type: "dsa",
            params: asn1.DSAPrivateKey.decode(data, "der")
          };
        case "EC PRIVATE KEY":
          data = asn1.ECPrivateKey.decode(data, "der");
          return {
            curve: data.parameters.value,
            privateKey: data.privateKey
          };
        default:
          throw new Error("unknown key type " + type2);
      }
    }
    parseKeys.signature = asn1.signature;
    function decrypt2(data, password) {
      var salt = data.algorithm.decrypt.kde.kdeparams.salt;
      var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
      var algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
      var iv = data.algorithm.decrypt.cipher.iv;
      var cipherText = data.subjectPrivateKey;
      var keylen = parseInt(algo.split("-")[1], 10) / 8;
      var key = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1");
      var cipher = ciphers.createDecipheriv(algo, key, iv);
      var out = [];
      out.push(cipher.update(cipherText));
      out.push(cipher.final());
      return Buffer4.concat(out);
    }
  }
});

// node_modules/browserify-sign/browser/curves.json
var require_curves2 = __commonJS({
  "node_modules/browserify-sign/browser/curves.json"(exports, module) {
    module.exports = {
      "1.3.132.0.10": "secp256k1",
      "1.3.132.0.33": "p224",
      "1.2.840.10045.3.1.1": "p192",
      "1.2.840.10045.3.1.7": "p256",
      "1.3.132.0.34": "p384",
      "1.3.132.0.35": "p521"
    };
  }
});

// node_modules/browserify-sign/browser/sign.js
var require_sign = __commonJS({
  "node_modules/browserify-sign/browser/sign.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var createHmac = require_browser4();
    var crt = require_browserify_rsa();
    var EC = require_elliptic().ec;
    var BN2 = require_bn3();
    var parseKeys = require_parse_asn1();
    var curves = require_curves2();
    function sign(hash, key, hashType, signType, tag) {
      var priv = parseKeys(key);
      if (priv.curve) {
        if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
          throw new Error("wrong private key type");
        return ecSign(hash, priv);
      } else if (priv.type === "dsa") {
        if (signType !== "dsa")
          throw new Error("wrong private key type");
        return dsaSign(hash, priv, hashType);
      } else {
        if (signType !== "rsa" && signType !== "ecdsa/rsa")
          throw new Error("wrong private key type");
      }
      hash = Buffer4.concat([tag, hash]);
      var len = priv.modulus.byteLength();
      var pad2 = [0, 1];
      while (hash.length + pad2.length + 1 < len)
        pad2.push(255);
      pad2.push(0);
      var i5 = -1;
      while (++i5 < hash.length)
        pad2.push(hash[i5]);
      var out = crt(pad2, priv);
      return out;
    }
    function ecSign(hash, priv) {
      var curveId = curves[priv.curve.join(".")];
      if (!curveId)
        throw new Error("unknown curve " + priv.curve.join("."));
      var curve = new EC(curveId);
      var key = curve.keyFromPrivate(priv.privateKey);
      var out = key.sign(hash);
      return Buffer4.from(out.toDER());
    }
    function dsaSign(hash, priv, algo) {
      var x5 = priv.params.priv_key;
      var p5 = priv.params.p;
      var q5 = priv.params.q;
      var g5 = priv.params.g;
      var r6 = new BN2(0);
      var k5;
      var H4 = bits2int(hash, q5).mod(q5);
      var s5 = false;
      var kv = getKey(x5, q5, hash, algo);
      while (s5 === false) {
        k5 = makeKey(q5, kv, algo);
        r6 = makeR(g5, k5, p5, q5);
        s5 = k5.invm(q5).imul(H4.add(x5.mul(r6))).mod(q5);
        if (s5.cmpn(0) === 0) {
          s5 = false;
          r6 = new BN2(0);
        }
      }
      return toDER(r6, s5);
    }
    function toDER(r6, s5) {
      r6 = r6.toArray();
      s5 = s5.toArray();
      if (r6[0] & 128)
        r6 = [0].concat(r6);
      if (s5[0] & 128)
        s5 = [0].concat(s5);
      var total = r6.length + s5.length + 4;
      var res = [48, total, 2, r6.length];
      res = res.concat(r6, [2, s5.length], s5);
      return Buffer4.from(res);
    }
    function getKey(x5, q5, hash, algo) {
      x5 = Buffer4.from(x5.toArray());
      if (x5.length < q5.byteLength()) {
        var zeros = Buffer4.alloc(q5.byteLength() - x5.length);
        x5 = Buffer4.concat([zeros, x5]);
      }
      var hlen = hash.length;
      var hbits = bits2octets(hash, q5);
      var v5 = Buffer4.alloc(hlen);
      v5.fill(1);
      var k5 = Buffer4.alloc(hlen);
      k5 = createHmac(algo, k5).update(v5).update(Buffer4.from([0])).update(x5).update(hbits).digest();
      v5 = createHmac(algo, k5).update(v5).digest();
      k5 = createHmac(algo, k5).update(v5).update(Buffer4.from([1])).update(x5).update(hbits).digest();
      v5 = createHmac(algo, k5).update(v5).digest();
      return { k: k5, v: v5 };
    }
    function bits2int(obits, q5) {
      var bits = new BN2(obits);
      var shift = (obits.length << 3) - q5.bitLength();
      if (shift > 0)
        bits.ishrn(shift);
      return bits;
    }
    function bits2octets(bits, q5) {
      bits = bits2int(bits, q5);
      bits = bits.mod(q5);
      var out = Buffer4.from(bits.toArray());
      if (out.length < q5.byteLength()) {
        var zeros = Buffer4.alloc(q5.byteLength() - out.length);
        out = Buffer4.concat([zeros, out]);
      }
      return out;
    }
    function makeKey(q5, kv, algo) {
      var t5;
      var k5;
      do {
        t5 = Buffer4.alloc(0);
        while (t5.length * 8 < q5.bitLength()) {
          kv.v = createHmac(algo, kv.k).update(kv.v).digest();
          t5 = Buffer4.concat([t5, kv.v]);
        }
        k5 = bits2int(t5, q5);
        kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer4.from([0])).digest();
        kv.v = createHmac(algo, kv.k).update(kv.v).digest();
      } while (k5.cmp(q5) !== -1);
      return k5;
    }
    function makeR(g5, k5, p5, q5) {
      return g5.toRed(BN2.mont(p5)).redPow(k5).fromRed().mod(q5);
    }
    module.exports = sign;
    module.exports.getKey = getKey;
    module.exports.makeKey = makeKey;
  }
});

// node_modules/browserify-sign/browser/verify.js
var require_verify = __commonJS({
  "node_modules/browserify-sign/browser/verify.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var BN2 = require_bn3();
    var EC = require_elliptic().ec;
    var parseKeys = require_parse_asn1();
    var curves = require_curves2();
    function verify(sig, hash, key, signType, tag) {
      var pub = parseKeys(key);
      if (pub.type === "ec") {
        if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
          throw new Error("wrong public key type");
        return ecVerify(sig, hash, pub);
      } else if (pub.type === "dsa") {
        if (signType !== "dsa")
          throw new Error("wrong public key type");
        return dsaVerify(sig, hash, pub);
      } else {
        if (signType !== "rsa" && signType !== "ecdsa/rsa")
          throw new Error("wrong public key type");
      }
      hash = Buffer4.concat([tag, hash]);
      var len = pub.modulus.byteLength();
      var pad2 = [1];
      var padNum = 0;
      while (hash.length + pad2.length + 2 < len) {
        pad2.push(255);
        padNum++;
      }
      pad2.push(0);
      var i5 = -1;
      while (++i5 < hash.length) {
        pad2.push(hash[i5]);
      }
      pad2 = Buffer4.from(pad2);
      var red = BN2.mont(pub.modulus);
      sig = new BN2(sig).toRed(red);
      sig = sig.redPow(new BN2(pub.publicExponent));
      sig = Buffer4.from(sig.fromRed().toArray());
      var out = padNum < 8 ? 1 : 0;
      len = Math.min(sig.length, pad2.length);
      if (sig.length !== pad2.length)
        out = 1;
      i5 = -1;
      while (++i5 < len)
        out |= sig[i5] ^ pad2[i5];
      return out === 0;
    }
    function ecVerify(sig, hash, pub) {
      var curveId = curves[pub.data.algorithm.curve.join(".")];
      if (!curveId)
        throw new Error("unknown curve " + pub.data.algorithm.curve.join("."));
      var curve = new EC(curveId);
      var pubkey = pub.data.subjectPrivateKey.data;
      return curve.verify(hash, sig, pubkey);
    }
    function dsaVerify(sig, hash, pub) {
      var p5 = pub.data.p;
      var q5 = pub.data.q;
      var g5 = pub.data.g;
      var y5 = pub.data.pub_key;
      var unpacked = parseKeys.signature.decode(sig, "der");
      var s5 = unpacked.s;
      var r6 = unpacked.r;
      checkValue(s5, q5);
      checkValue(r6, q5);
      var montp = BN2.mont(p5);
      var w6 = s5.invm(q5);
      var v5 = g5.toRed(montp).redPow(new BN2(hash).mul(w6).mod(q5)).fromRed().mul(y5.toRed(montp).redPow(r6.mul(w6).mod(q5)).fromRed()).mod(p5).mod(q5);
      return v5.cmp(r6) === 0;
    }
    function checkValue(b4, q5) {
      if (b4.cmpn(0) <= 0)
        throw new Error("invalid sig");
      if (b4.cmp(q5) >= q5)
        throw new Error("invalid sig");
    }
    module.exports = verify;
  }
});

// node_modules/browserify-sign/browser/index.js
var require_browser9 = __commonJS({
  "node_modules/browserify-sign/browser/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var createHash = require_browser3();
    var stream = require_readable_browser2();
    var inherits2 = require_inherits_browser();
    var sign = require_sign();
    var verify = require_verify();
    var algorithms = require_algorithms();
    Object.keys(algorithms).forEach(function(key) {
      algorithms[key].id = Buffer4.from(algorithms[key].id, "hex");
      algorithms[key.toLowerCase()] = algorithms[key];
    });
    function Sign(algorithm) {
      stream.Writable.call(this);
      var data = algorithms[algorithm];
      if (!data)
        throw new Error("Unknown message digest");
      this._hashType = data.hash;
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    inherits2(Sign, stream.Writable);
    Sign.prototype._write = function _write(data, _6, done2) {
      this._hash.update(data);
      done2();
    };
    Sign.prototype.update = function update(data, enc) {
      if (typeof data === "string")
        data = Buffer4.from(data, enc);
      this._hash.update(data);
      return this;
    };
    Sign.prototype.sign = function signMethod(key, enc) {
      this.end();
      var hash = this._hash.digest();
      var sig = sign(hash, key, this._hashType, this._signType, this._tag);
      return enc ? sig.toString(enc) : sig;
    };
    function Verify(algorithm) {
      stream.Writable.call(this);
      var data = algorithms[algorithm];
      if (!data)
        throw new Error("Unknown message digest");
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    inherits2(Verify, stream.Writable);
    Verify.prototype._write = function _write(data, _6, done2) {
      this._hash.update(data);
      done2();
    };
    Verify.prototype.update = function update(data, enc) {
      if (typeof data === "string")
        data = Buffer4.from(data, enc);
      this._hash.update(data);
      return this;
    };
    Verify.prototype.verify = function verifyMethod(key, sig, enc) {
      if (typeof sig === "string")
        sig = Buffer4.from(sig, enc);
      this.end();
      var hash = this._hash.digest();
      return verify(sig, hash, key, this._signType, this._tag);
    };
    function createSign(algorithm) {
      return new Sign(algorithm);
    }
    function createVerify(algorithm) {
      return new Verify(algorithm);
    }
    module.exports = {
      Sign: createSign,
      Verify: createVerify,
      createSign,
      createVerify
    };
  }
});

// node_modules/create-ecdh/node_modules/bn.js/lib/bn.js
var require_bn6 = __commonJS({
  "node_modules/create-ecdh/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base2, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e5) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i5 = number.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number[i5] | number[i5 - 1] << 8 | number[i5 - 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number.length; i5 += 3) {
            w6 = number[i5] | number[i5 + 1] << 8 | number[i5 + 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off3 = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number.length; i5 += 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN2.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i5, number.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r6 = new BN2(null);
        this.copy(r6);
        return r6;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength3; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN2.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN2.prototype._countBits(N4) - 1;
        for (var i5 = 0; i5 < N4; i5++) {
          t5[i5] = this.revBin(i5, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i5 = 0; i5 < N4; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s5 = 1; s5 < N4; s5 <<= 1) {
          var l5 = s5 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s5; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s5];
              var io = itws[p5 + j5 + s5];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s5] = re - ro;
              itws[p5 + j5 + s5] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N4 = Math.max(m5, n3) | 1;
        var odd = N4 & 1;
        var i5 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N4 - i5 - 1];
          rws[N4 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N4 - i5 - 1];
          iws[N4 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N4) * 8192 + Math.round(ws[2 * i5] / N4) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N4; ++i5) {
          rws[i5] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i5 = 0; i5 < N4; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _6 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _6, rwst, iwst, N4, rbt);
        this.transform(nrws, _6, nrwst, niwst, N4, rbt);
        for (var i5 = 0; i5 < N4; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _6, N4, rbt);
        this.conjugate(rmws, _6, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN2(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s5 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s5] = this.words[i5];
          }
          for (i5 = 0; i5 < s5; i5++) {
            this.words[i5] = 0;
          }
          this.length += s5;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s5 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s5;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s5; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s5;
        }
        if (s5 === 0) {
        } else if (this.length > s5) {
          this.length -= s5;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s5];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5)
          return false;
        var w6 = this.words[s5];
        return !!(w6 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s5) {
          return this;
        }
        if (r6 !== 0) {
          s5++;
        }
        this.length = Math.min(s5, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN2(1);
        var B4 = new BN2(0);
        var C4 = new BN2(0);
        var D3 = new BN2(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B4.isOdd()) {
                A6.iadd(yp);
                B4.isub(xp);
              }
              A6.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D3.isOdd()) {
                C4.iadd(yp);
                D3.isub(xp);
              }
              C4.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B4.isub(D3);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D3.isub(B4);
          }
        }
        return {
          a: C4,
          b: D3,
          gcd: y5.iushln(g5)
        };
      };
      BN2.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5) {
          this._expand(s5 + 1);
          this.words[s5] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s5; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN2(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN2._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s5 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s5++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z5 = this.m.bitLength();
        z5 = new BN2(2 * z5 * z5).toRed(this);
        while (this.pow(z5, lpow).cmp(nOne) !== 0) {
          z5.redIAdd(nOne);
        }
        var c5 = this.pow(z5, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s5;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert3(i5 < m5);
          var b4 = this.pow(c5, new BN2(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/create-ecdh/browser.js
var require_browser10 = __commonJS({
  "node_modules/create-ecdh/browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var elliptic = require_elliptic();
    var BN2 = require_bn6();
    module.exports = function createECDH(curve) {
      return new ECDH(curve);
    };
    var aliases = {
      secp256k1: {
        name: "secp256k1",
        byteLength: 32
      },
      secp224r1: {
        name: "p224",
        byteLength: 28
      },
      prime256v1: {
        name: "p256",
        byteLength: 32
      },
      prime192v1: {
        name: "p192",
        byteLength: 24
      },
      ed25519: {
        name: "ed25519",
        byteLength: 32
      },
      secp384r1: {
        name: "p384",
        byteLength: 48
      },
      secp521r1: {
        name: "p521",
        byteLength: 66
      }
    };
    aliases.p224 = aliases.secp224r1;
    aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
    aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
    aliases.p384 = aliases.secp384r1;
    aliases.p521 = aliases.secp521r1;
    function ECDH(curve) {
      this.curveType = aliases[curve];
      if (!this.curveType) {
        this.curveType = {
          name: curve
        };
      }
      this.curve = new elliptic.ec(this.curveType.name);
      this.keys = void 0;
    }
    ECDH.prototype.generateKeys = function(enc, format3) {
      this.keys = this.curve.genKeyPair();
      return this.getPublicKey(enc, format3);
    };
    ECDH.prototype.computeSecret = function(other, inenc, enc) {
      inenc = inenc || "utf8";
      if (!Buffer2.isBuffer(other)) {
        other = new Buffer2(other, inenc);
      }
      var otherPub = this.curve.keyFromPublic(other).getPublic();
      var out = otherPub.mul(this.keys.getPrivate()).getX();
      return formatReturnValue(out, enc, this.curveType.byteLength);
    };
    ECDH.prototype.getPublicKey = function(enc, format3) {
      var key = this.keys.getPublic(format3 === "compressed", true);
      if (format3 === "hybrid") {
        if (key[key.length - 1] % 2) {
          key[0] = 7;
        } else {
          key[0] = 6;
        }
      }
      return formatReturnValue(key, enc);
    };
    ECDH.prototype.getPrivateKey = function(enc) {
      return formatReturnValue(this.keys.getPrivate(), enc);
    };
    ECDH.prototype.setPublicKey = function(pub, enc) {
      enc = enc || "utf8";
      if (!Buffer2.isBuffer(pub)) {
        pub = new Buffer2(pub, enc);
      }
      this.keys._importPublic(pub);
      return this;
    };
    ECDH.prototype.setPrivateKey = function(priv, enc) {
      enc = enc || "utf8";
      if (!Buffer2.isBuffer(priv)) {
        priv = new Buffer2(priv, enc);
      }
      var _priv = new BN2(priv);
      _priv = _priv.toString(16);
      this.keys = this.curve.genKeyPair();
      this.keys._importPrivate(_priv);
      return this;
    };
    function formatReturnValue(bn, enc, len) {
      if (!Array.isArray(bn)) {
        bn = bn.toArray();
      }
      var buf = new Buffer2(bn);
      if (len && buf.length < len) {
        var zeros = new Buffer2(len - buf.length);
        zeros.fill(0);
        buf = Buffer2.concat([zeros, buf]);
      }
      if (!enc) {
        return buf;
      } else {
        return buf.toString(enc);
      }
    }
  }
});

// node_modules/public-encrypt/mgf.js
var require_mgf = __commonJS({
  "node_modules/public-encrypt/mgf.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var createHash = require_browser3();
    var Buffer4 = require_safe_buffer().Buffer;
    module.exports = function(seed, len) {
      var t5 = Buffer4.alloc(0);
      var i5 = 0;
      var c5;
      while (t5.length < len) {
        c5 = i2ops(i5++);
        t5 = Buffer4.concat([t5, createHash("sha1").update(seed).update(c5).digest()]);
      }
      return t5.slice(0, len);
    };
    function i2ops(c5) {
      var out = Buffer4.allocUnsafe(4);
      out.writeUInt32BE(c5, 0);
      return out;
    }
  }
});

// node_modules/public-encrypt/xor.js
var require_xor = __commonJS({
  "node_modules/public-encrypt/xor.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function xor(a5, b4) {
      var len = a5.length;
      var i5 = -1;
      while (++i5 < len) {
        a5[i5] ^= b4[i5];
      }
      return a5;
    };
  }
});

// node_modules/public-encrypt/node_modules/bn.js/lib/bn.js
var require_bn7 = __commonJS({
  "node_modules/public-encrypt/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base2, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e5) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i5 = number.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number[i5] | number[i5 - 1] << 8 | number[i5 - 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number.length; i5 += 3) {
            w6 = number[i5] | number[i5 + 1] << 8 | number[i5 + 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off3 = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number.length; i5 += 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN2.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i5, number.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r6 = new BN2(null);
        this.copy(r6);
        return r6;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength3; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN2.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN2.prototype._countBits(N4) - 1;
        for (var i5 = 0; i5 < N4; i5++) {
          t5[i5] = this.revBin(i5, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i5 = 0; i5 < N4; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s5 = 1; s5 < N4; s5 <<= 1) {
          var l5 = s5 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s5; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s5];
              var io = itws[p5 + j5 + s5];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s5] = re - ro;
              itws[p5 + j5 + s5] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N4 = Math.max(m5, n3) | 1;
        var odd = N4 & 1;
        var i5 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N4 - i5 - 1];
          rws[N4 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N4 - i5 - 1];
          iws[N4 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N4) * 8192 + Math.round(ws[2 * i5] / N4) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N4; ++i5) {
          rws[i5] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i5 = 0; i5 < N4; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _6 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _6, rwst, iwst, N4, rbt);
        this.transform(nrws, _6, nrwst, niwst, N4, rbt);
        for (var i5 = 0; i5 < N4; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _6, N4, rbt);
        this.conjugate(rmws, _6, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN2(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s5 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s5] = this.words[i5];
          }
          for (i5 = 0; i5 < s5; i5++) {
            this.words[i5] = 0;
          }
          this.length += s5;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s5 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s5;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s5; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s5;
        }
        if (s5 === 0) {
        } else if (this.length > s5) {
          this.length -= s5;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s5];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5)
          return false;
        var w6 = this.words[s5];
        return !!(w6 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s5) {
          return this;
        }
        if (r6 !== 0) {
          s5++;
        }
        this.length = Math.min(s5, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN2(1);
        var B4 = new BN2(0);
        var C4 = new BN2(0);
        var D3 = new BN2(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B4.isOdd()) {
                A6.iadd(yp);
                B4.isub(xp);
              }
              A6.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D3.isOdd()) {
                C4.iadd(yp);
                D3.isub(xp);
              }
              C4.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B4.isub(D3);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D3.isub(B4);
          }
        }
        return {
          a: C4,
          b: D3,
          gcd: y5.iushln(g5)
        };
      };
      BN2.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5) {
          this._expand(s5 + 1);
          this.words[s5] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s5; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN2(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN2._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s5 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s5++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z5 = this.m.bitLength();
        z5 = new BN2(2 * z5 * z5).toRed(this);
        while (this.pow(z5, lpow).cmp(nOne) !== 0) {
          z5.redIAdd(nOne);
        }
        var c5 = this.pow(z5, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s5;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert3(i5 < m5);
          var b4 = this.pow(c5, new BN2(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/public-encrypt/withPublic.js
var require_withPublic = __commonJS({
  "node_modules/public-encrypt/withPublic.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BN2 = require_bn7();
    var Buffer4 = require_safe_buffer().Buffer;
    function withPublic(paddedMsg, key) {
      return Buffer4.from(paddedMsg.toRed(BN2.mont(key.modulus)).redPow(new BN2(key.publicExponent)).fromRed().toArray());
    }
    module.exports = withPublic;
  }
});

// node_modules/public-encrypt/publicEncrypt.js
var require_publicEncrypt = __commonJS({
  "node_modules/public-encrypt/publicEncrypt.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var parseKeys = require_parse_asn1();
    var randomBytes2 = require_browser();
    var createHash = require_browser3();
    var mgf = require_mgf();
    var xor = require_xor();
    var BN2 = require_bn7();
    var withPublic = require_withPublic();
    var crt = require_browserify_rsa();
    var Buffer4 = require_safe_buffer().Buffer;
    module.exports = function publicEncrypt(publicKey, msg, reverse) {
      var padding;
      if (publicKey.padding) {
        padding = publicKey.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(publicKey);
      var paddedMsg;
      if (padding === 4) {
        paddedMsg = oaep(key, msg);
      } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        paddedMsg = new BN2(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
          throw new Error("data too long for modulus");
        }
      } else {
        throw new Error("unknown padding");
      }
      if (reverse) {
        return crt(paddedMsg, key);
      } else {
        return withPublic(paddedMsg, key);
      }
    };
    function oaep(key, msg) {
      var k5 = key.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash("sha1").update(Buffer4.alloc(0)).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (mLen > k5 - hLen2 - 2) {
        throw new Error("message too long");
      }
      var ps = Buffer4.alloc(k5 - mLen - hLen2 - 2);
      var dblen = k5 - hLen - 1;
      var seed = randomBytes2(hLen);
      var maskedDb = xor(Buffer4.concat([iHash, ps, Buffer4.alloc(1, 1), msg], dblen), mgf(seed, dblen));
      var maskedSeed = xor(seed, mgf(maskedDb, hLen));
      return new BN2(Buffer4.concat([Buffer4.alloc(1), maskedSeed, maskedDb], k5));
    }
    function pkcs1(key, msg, reverse) {
      var mLen = msg.length;
      var k5 = key.modulus.byteLength();
      if (mLen > k5 - 11) {
        throw new Error("message too long");
      }
      var ps;
      if (reverse) {
        ps = Buffer4.alloc(k5 - mLen - 3, 255);
      } else {
        ps = nonZero(k5 - mLen - 3);
      }
      return new BN2(Buffer4.concat([Buffer4.from([0, reverse ? 1 : 2]), ps, Buffer4.alloc(1), msg], k5));
    }
    function nonZero(len) {
      var out = Buffer4.allocUnsafe(len);
      var i5 = 0;
      var cache = randomBytes2(len * 2);
      var cur = 0;
      var num;
      while (i5 < len) {
        if (cur === cache.length) {
          cache = randomBytes2(len * 2);
          cur = 0;
        }
        num = cache[cur++];
        if (num) {
          out[i5++] = num;
        }
      }
      return out;
    }
  }
});

// node_modules/public-encrypt/privateDecrypt.js
var require_privateDecrypt = __commonJS({
  "node_modules/public-encrypt/privateDecrypt.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var parseKeys = require_parse_asn1();
    var mgf = require_mgf();
    var xor = require_xor();
    var BN2 = require_bn7();
    var crt = require_browserify_rsa();
    var createHash = require_browser3();
    var withPublic = require_withPublic();
    var Buffer4 = require_safe_buffer().Buffer;
    module.exports = function privateDecrypt(privateKey, enc, reverse) {
      var padding;
      if (privateKey.padding) {
        padding = privateKey.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(privateKey);
      var k5 = key.modulus.byteLength();
      if (enc.length > k5 || new BN2(enc).cmp(key.modulus) >= 0) {
        throw new Error("decryption error");
      }
      var msg;
      if (reverse) {
        msg = withPublic(new BN2(enc), key);
      } else {
        msg = crt(enc, key);
      }
      var zBuffer = Buffer4.alloc(k5 - msg.length);
      msg = Buffer4.concat([zBuffer, msg], k5);
      if (padding === 4) {
        return oaep(key, msg);
      } else if (padding === 1) {
        return pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        return msg;
      } else {
        throw new Error("unknown padding");
      }
    };
    function oaep(key, msg) {
      var k5 = key.modulus.byteLength();
      var iHash = createHash("sha1").update(Buffer4.alloc(0)).digest();
      var hLen = iHash.length;
      if (msg[0] !== 0) {
        throw new Error("decryption error");
      }
      var maskedSeed = msg.slice(1, hLen + 1);
      var maskedDb = msg.slice(hLen + 1);
      var seed = xor(maskedSeed, mgf(maskedDb, hLen));
      var db = xor(maskedDb, mgf(seed, k5 - hLen - 1));
      if (compare6(iHash, db.slice(0, hLen))) {
        throw new Error("decryption error");
      }
      var i5 = hLen;
      while (db[i5] === 0) {
        i5++;
      }
      if (db[i5++] !== 1) {
        throw new Error("decryption error");
      }
      return db.slice(i5);
    }
    function pkcs1(key, msg, reverse) {
      var p1 = msg.slice(0, 2);
      var i5 = 2;
      var status = 0;
      while (msg[i5++] !== 0) {
        if (i5 >= msg.length) {
          status++;
          break;
        }
      }
      var ps = msg.slice(2, i5 - 1);
      if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
        status++;
      }
      if (ps.length < 8) {
        status++;
      }
      if (status) {
        throw new Error("decryption error");
      }
      return msg.slice(i5);
    }
    function compare6(a5, b4) {
      a5 = Buffer4.from(a5);
      b4 = Buffer4.from(b4);
      var dif = 0;
      var len = a5.length;
      if (a5.length !== b4.length) {
        dif++;
        len = Math.min(a5.length, b4.length);
      }
      var i5 = -1;
      while (++i5 < len) {
        dif += a5[i5] ^ b4[i5];
      }
      return dif;
    }
  }
});

// node_modules/public-encrypt/browser.js
var require_browser11 = __commonJS({
  "node_modules/public-encrypt/browser.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports.publicEncrypt = require_publicEncrypt();
    exports.privateDecrypt = require_privateDecrypt();
    exports.privateEncrypt = function privateEncrypt(key, buf) {
      return exports.publicEncrypt(key, buf, true);
    };
    exports.publicDecrypt = function publicDecrypt(key, buf) {
      return exports.privateDecrypt(key, buf, true);
    };
  }
});

// node_modules/randomfill/browser.js
var require_browser12 = __commonJS({
  "node_modules/randomfill/browser.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function oldBrowser() {
      throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
    }
    var safeBuffer = require_safe_buffer();
    var randombytes = require_browser();
    var Buffer4 = safeBuffer.Buffer;
    var kBufferMaxLength = safeBuffer.kMaxLength;
    var crypto3 = globalThis.crypto || globalThis.msCrypto;
    var kMaxUint32 = Math.pow(2, 32) - 1;
    function assertOffset(offset, length) {
      if (typeof offset !== "number" || offset !== offset) {
        throw new TypeError("offset must be a number");
      }
      if (offset > kMaxUint32 || offset < 0) {
        throw new TypeError("offset must be a uint32");
      }
      if (offset > kBufferMaxLength || offset > length) {
        throw new RangeError("offset out of range");
      }
    }
    function assertSize3(size, offset, length) {
      if (typeof size !== "number" || size !== size) {
        throw new TypeError("size must be a number");
      }
      if (size > kMaxUint32 || size < 0) {
        throw new TypeError("size must be a uint32");
      }
      if (size + offset > length || size > kBufferMaxLength) {
        throw new RangeError("buffer too small");
      }
    }
    if (crypto3 && crypto3.getRandomValues || !process.browser) {
      exports.randomFill = randomFill;
      exports.randomFillSync = randomFillSync;
    } else {
      exports.randomFill = oldBrowser;
      exports.randomFillSync = oldBrowser;
    }
    function randomFill(buf, offset, size, cb) {
      if (!Buffer4.isBuffer(buf) && !(buf instanceof globalThis.Uint8Array)) {
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      }
      if (typeof offset === "function") {
        cb = offset;
        offset = 0;
        size = buf.length;
      } else if (typeof size === "function") {
        cb = size;
        size = buf.length - offset;
      } else if (typeof cb !== "function") {
        throw new TypeError('"cb" argument must be a function');
      }
      assertOffset(offset, buf.length);
      assertSize3(size, offset, buf.length);
      return actualFill(buf, offset, size, cb);
    }
    function actualFill(buf, offset, size, cb) {
      if (process.browser) {
        var ourBuf = buf.buffer;
        var uint = new Uint8Array(ourBuf, offset, size);
        crypto3.getRandomValues(uint);
        if (cb) {
          process.nextTick(function() {
            cb(null, buf);
          });
          return;
        }
        return buf;
      }
      if (cb) {
        randombytes(size, function(err, bytes2) {
          if (err) {
            return cb(err);
          }
          bytes2.copy(buf, offset);
          cb(null, buf);
        });
        return;
      }
      var bytes = randombytes(size);
      bytes.copy(buf, offset);
      return buf;
    }
    function randomFillSync(buf, offset, size) {
      if (typeof offset === "undefined") {
        offset = 0;
      }
      if (!Buffer4.isBuffer(buf) && !(buf instanceof globalThis.Uint8Array)) {
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      }
      assertOffset(offset, buf.length);
      if (size === void 0)
        size = buf.length - offset;
      assertSize3(size, offset, buf.length);
      return actualFill(buf, offset, size);
    }
  }
});

// node_modules/crypto-browserify/index.js
var require_crypto_browserify = __commonJS({
  "node_modules/crypto-browserify/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require_browser();
    exports.createHash = exports.Hash = require_browser3();
    exports.createHmac = exports.Hmac = require_browser4();
    var algos = require_algos();
    var algoKeys = Object.keys(algos);
    var hashes = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(algoKeys);
    exports.getHashes = function() {
      return hashes;
    };
    var p5 = require_browser5();
    exports.pbkdf2 = p5.pbkdf2;
    exports.pbkdf2Sync = p5.pbkdf2Sync;
    var aes = require_browser7();
    exports.Cipher = aes.Cipher;
    exports.createCipher = aes.createCipher;
    exports.Cipheriv = aes.Cipheriv;
    exports.createCipheriv = aes.createCipheriv;
    exports.Decipher = aes.Decipher;
    exports.createDecipher = aes.createDecipher;
    exports.Decipheriv = aes.Decipheriv;
    exports.createDecipheriv = aes.createDecipheriv;
    exports.getCiphers = aes.getCiphers;
    exports.listCiphers = aes.listCiphers;
    var dh = require_browser8();
    exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
    exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
    exports.getDiffieHellman = dh.getDiffieHellman;
    exports.createDiffieHellman = dh.createDiffieHellman;
    exports.DiffieHellman = dh.DiffieHellman;
    var sign = require_browser9();
    exports.createSign = sign.createSign;
    exports.Sign = sign.Sign;
    exports.createVerify = sign.createVerify;
    exports.Verify = sign.Verify;
    exports.createECDH = require_browser10();
    var publicEncrypt = require_browser11();
    exports.publicEncrypt = publicEncrypt.publicEncrypt;
    exports.privateEncrypt = publicEncrypt.privateEncrypt;
    exports.publicDecrypt = publicEncrypt.publicDecrypt;
    exports.privateDecrypt = publicEncrypt.privateDecrypt;
    var rf = require_browser12();
    exports.randomFill = rf.randomFill;
    exports.randomFillSync = rf.randomFillSync;
    exports.createCredentials = function() {
      throw new Error([
        "sorry, createCredentials is not implemented yet",
        "we accept pull requests",
        "https://github.com/crypto-browserify/crypto-browserify"
      ].join("\n"));
    };
    exports.constants = {
      "DH_CHECK_P_NOT_SAFE_PRIME": 2,
      "DH_CHECK_P_NOT_PRIME": 1,
      "DH_UNABLE_TO_CHECK_GENERATOR": 4,
      "DH_NOT_SUITABLE_GENERATOR": 8,
      "NPN_ENABLED": 1,
      "ALPN_ENABLED": 1,
      "RSA_PKCS1_PADDING": 1,
      "RSA_SSLV23_PADDING": 2,
      "RSA_NO_PADDING": 3,
      "RSA_PKCS1_OAEP_PADDING": 4,
      "RSA_X931_PADDING": 5,
      "RSA_PKCS1_PSS_PADDING": 6,
      "POINT_CONVERSION_COMPRESSED": 2,
      "POINT_CONVERSION_UNCOMPRESSED": 4,
      "POINT_CONVERSION_HYBRID": 6
    };
  }
});

// build/node-globals.js
var crypto2;
var init_node_globals = __esm({
  "build/node-globals.js"() {
    "use strict";
    crypto2 = Object.assign({}, window.crypto || {});
    delete window.crypto;
    window.crypto = Object.assign(crypto2, require_crypto_browserify());
  }
});

// node_modules/@coinbase/wallet-sdk/dist/assets/wallet-logo.js
var require_wallet_logo = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/assets/wallet-logo.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.walletLogo = void 0;
    var walletLogo = (type2, width) => {
      let height;
      switch (type2) {
        case "standard":
          height = width;
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
        case "circle":
          height = width;
          return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
        case "text":
          height = (0.1 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
        case "textWithLogo":
          height = (0.25 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
        case "textLight":
          height = (0.1 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
        case "textWithLogoLight":
          height = (0.25 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
        default:
          height = width;
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
      }
    };
    exports.walletLogo = walletLogo;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/ScopedLocalStorage.js
var require_ScopedLocalStorage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/ScopedLocalStorage.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScopedLocalStorage = void 0;
    var ScopedLocalStorage = class {
      constructor(scope) {
        this.scope = scope;
      }
      setItem(key, value) {
        localStorage.setItem(this.scopedKey(key), value);
      }
      getItem(key) {
        return localStorage.getItem(this.scopedKey(key));
      }
      removeItem(key) {
        localStorage.removeItem(this.scopedKey(key));
      }
      clear() {
        const prefix = this.scopedKey("");
        const keysToRemove = [];
        for (let i5 = 0; i5 < localStorage.length; i5++) {
          const key = localStorage.key(i5);
          if (typeof key === "string" && key.startsWith(prefix)) {
            keysToRemove.push(key);
          }
        }
        keysToRemove.forEach((key) => localStorage.removeItem(key));
      }
      scopedKey(key) {
        return `${this.scope}:${key}`;
      }
    };
    exports.ScopedLocalStorage = ScopedLocalStorage;
  }
});

// node_modules/@metamask/safe-event-emitter/index.js
var require_safe_event_emitter = __commonJS({
  "node_modules/@metamask/safe-event-emitter/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require_events();
    function safeApply(handler, context, args) {
      try {
        Reflect.apply(handler, context, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone2(arr) {
      const n3 = arr.length;
      const copy3 = new Array(n3);
      for (let i5 = 0; i5 < n3; i5 += 1) {
        copy3[i5] = arr[i5];
      }
      return copy3;
    }
    var SafeEventEmitter = class extends events_1.EventEmitter {
      emit(type2, ...args) {
        let doError = type2 === "error";
        const events = this._events;
        if (events !== void 0) {
          doError = doError && events.error === void 0;
        } else if (!doError) {
          return false;
        }
        if (doError) {
          let er;
          if (args.length > 0) {
            [er] = args;
          }
          if (er instanceof Error) {
            throw er;
          }
          const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ""}`);
          err.context = er;
          throw err;
        }
        const handler = events[type2];
        if (handler === void 0) {
          return false;
        }
        if (typeof handler === "function") {
          safeApply(handler, this, args);
        } else {
          const len = handler.length;
          const listeners2 = arrayClone2(handler);
          for (let i5 = 0; i5 < len; i5 += 1) {
            safeApply(listeners2[i5], this, args);
          }
        }
        return true;
      }
    };
    exports.default = SafeEventEmitter;
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = stringify3;
    stringify3.default = stringify3;
    stringify3.stable = deterministicStringify;
    stringify3.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify3(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_6) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k5, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k5);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k5, { value: replace });
          arr.push([parent, k5, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k5, replace]);
        }
      } else {
        parent[k5] = replace;
        arr.push([parent, k5, val]);
      }
    }
    function decirc(val, k5, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i5;
      if (typeof val === "object" && val !== null) {
        for (i5 = 0; i5 < stack.length; i5++) {
          if (stack[i5] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k5, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i5 = 0; i5 < val.length; i5++) {
            decirc(val[i5], i5, i5, stack, val, depth, options);
          }
        } else {
          var keys2 = Object.keys(val);
          for (i5 = 0; i5 < keys2.length; i5++) {
            var key = keys2[i5];
            decirc(val[key], key, i5, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a5, b4) {
      if (a5 < b4) {
        return -1;
      }
      if (a5 > b4) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_6) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k5, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i5;
      if (typeof val === "object" && val !== null) {
        for (i5 = 0; i5 < stack.length; i5++) {
          if (stack[i5] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k5, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_6) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i5 = 0; i5 < val.length; i5++) {
            deterministicDecirc(val[i5], i5, i5, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys2 = Object.keys(val).sort(compareFunction);
          for (i5 = 0; i5 < keys2.length; i5++) {
            var key = keys2[i5];
            deterministicDecirc(val[key], key, i5, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k5, val]);
            parent[k5] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k5, v5) {
        return v5;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i5 = 0; i5 < replacerStack.length; i5++) {
            var part = replacerStack[i5];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i5, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/@coinbase/wallet-sdk/node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/@coinbase/wallet-sdk/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_6, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/@coinbase/wallet-sdk/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/@coinbase/wallet-sdk/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/@coinbase/wallet-sdk/node_modules/eth-rpc-errors/dist/utils.js
var require_utils5 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError(error2, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error2 instanceof classes_1.EthereumRpcError) {
        return error2.serialize();
      }
      const serialized = {};
      if (error2 && typeof error2 === "object" && !Array.isArray(error2) && hasKey(error2, "code") && isValidCode(error2.code)) {
        const _error = error2;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error2) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error2) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error2) };
      }
      const stack = (_b = error2) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error2 && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error2) {
      if (error2 && typeof error2 === "object" && !Array.isArray(error2)) {
        return Object.assign({}, error2);
      }
      return error2;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/@coinbase/wallet-sdk/node_modules/eth-rpc-errors/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@coinbase/wallet-sdk/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_1 = require_utils5();
    var error_constants_1 = require_error_constants();
    exports.ethErrors = {
      rpc: {
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/@coinbase/wallet-sdk/node_modules/eth-rpc-errors/dist/index.js
var require_dist = __commonJS({
  "node_modules/@coinbase/wallet-sdk/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils5();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/DiagnosticLogger.js
var require_DiagnosticLogger = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/DiagnosticLogger.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EVENTS = void 0;
    exports.EVENTS = {
      STARTED_CONNECTING: "walletlink_sdk.started.connecting",
      CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
      DISCONNECTED: "walletlink_sdk.disconnected",
      METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
      LINKED: "walletlink_sdk.linked",
      FAILURE: "walletlink_sdk.generic_failure",
      SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
      ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
      SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
      UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
      SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
      GENERAL_ERROR: "walletlink_sdk.general_error",
      WEB3_REQUEST: "walletlink_sdk.web3.request",
      WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
      WEB3_RESPONSE: "walletlink_sdk.web3.response",
      UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
    };
  }
});

// node_modules/rxjs/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/rxjs/node_modules/tslib/tslib.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays3;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding2;
    (function(factory) {
      var root = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v5) {
          return exports2[id] = previous ? previous(id, v5) : v5;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b4) {
        d5.__proto__ = b4;
      } || function(d5, b4) {
        for (var p5 in b4)
          if (b4.hasOwnProperty(p5))
            d5[p5] = b4[p5];
      };
      __extends2 = function(d5, b4) {
        extendStatics(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
      __assign2 = Object.assign || function(t5) {
        for (var s5, i5 = 1, n3 = arguments.length; i5 < n3; i5++) {
          s5 = arguments[i5];
          for (var p5 in s5)
            if (Object.prototype.hasOwnProperty.call(s5, p5))
              t5[p5] = s5[p5];
        }
        return t5;
      };
      __rest2 = function(s5, e5) {
        var t5 = {};
        for (var p5 in s5)
          if (Object.prototype.hasOwnProperty.call(s5, p5) && e5.indexOf(p5) < 0)
            t5[p5] = s5[p5];
        if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i5 = 0, p5 = Object.getOwnPropertySymbols(s5); i5 < p5.length; i5++) {
            if (e5.indexOf(p5[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p5[i5]))
              t5[p5[i5]] = s5[p5[i5]];
          }
        return t5;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d5;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r6 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i5 = decorators.length - 1; i5 >= 0; i5--)
            if (d5 = decorators[i5])
              r6 = (c5 < 3 ? d5(r6) : c5 > 3 ? d5(target, key, r6) : d5(target, key)) || r6;
        return c5 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P5, generator) {
        function adopt(value) {
          return value instanceof P5 ? value : new P5(function(resolve) {
            resolve(value);
          });
        }
        return new (P5 || (P5 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e5) {
              reject(e5);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e5) {
              reject(e5);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _6 = { label: 0, sent: function() {
          if (t5[0] & 1)
            throw t5[1];
          return t5[1];
        }, trys: [], ops: [] }, f5, y5, t5, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n3) {
          return function(v5) {
            return step([n3, v5]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (_6)
            try {
              if (f5 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
                return t5;
              if (y5 = 0, t5)
                op = [op[0] & 2, t5.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t5 = op;
                  break;
                case 4:
                  _6.label++;
                  return { value: op[1], done: false };
                case 5:
                  _6.label++;
                  y5 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _6.ops.pop();
                  _6.trys.pop();
                  continue;
                default:
                  if (!(t5 = _6.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _6 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                    _6.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _6.label < t5[1]) {
                    _6.label = t5[1];
                    t5 = op;
                    break;
                  }
                  if (t5 && _6.label < t5[2]) {
                    _6.label = t5[2];
                    _6.ops.push(op);
                    break;
                  }
                  if (t5[2])
                    _6.ops.pop();
                  _6.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _6);
            } catch (e5) {
              op = [6, e5];
              y5 = 0;
            } finally {
              f5 = t5 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding2 = function(o5, m5, k5, k22) {
        if (k22 === void 0)
          k22 = k5;
        o5[k22] = m5[k5];
      };
      __exportStar2 = function(m5, exports2) {
        for (var p5 in m5)
          if (p5 !== "default" && !exports2.hasOwnProperty(p5))
            exports2[p5] = m5[p5];
      };
      __values2 = function(o5) {
        var s5 = typeof Symbol === "function" && Symbol.iterator, m5 = s5 && o5[s5], i5 = 0;
        if (m5)
          return m5.call(o5);
        if (o5 && typeof o5.length === "number")
          return {
            next: function() {
              if (o5 && i5 >= o5.length)
                o5 = void 0;
              return { value: o5 && o5[i5++], done: !o5 };
            }
          };
        throw new TypeError(s5 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o5, n3) {
        var m5 = typeof Symbol === "function" && o5[Symbol.iterator];
        if (!m5)
          return o5;
        var i5 = m5.call(o5), r6, ar = [], e5;
        try {
          while ((n3 === void 0 || n3-- > 0) && !(r6 = i5.next()).done)
            ar.push(r6.value);
        } catch (error2) {
          e5 = { error: error2 };
        } finally {
          try {
            if (r6 && !r6.done && (m5 = i5["return"]))
              m5.call(i5);
          } finally {
            if (e5)
              throw e5.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i5 = 0; i5 < arguments.length; i5++)
          ar = ar.concat(__read2(arguments[i5]));
        return ar;
      };
      __spreadArrays3 = function() {
        for (var s5 = 0, i5 = 0, il = arguments.length; i5 < il; i5++)
          s5 += arguments[i5].length;
        for (var r6 = Array(s5), k5 = 0, i5 = 0; i5 < il; i5++)
          for (var a5 = arguments[i5], j5 = 0, jl = a5.length; j5 < jl; j5++, k5++)
            r6[k5] = a5[j5];
        return r6;
      };
      __await2 = function(v5) {
        return this instanceof __await2 ? (this.v = v5, this) : new __await2(v5);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g5 = generator.apply(thisArg, _arguments || []), i5, q5 = [];
        return i5 = {}, verb("next"), verb("throw"), verb("return"), i5[Symbol.asyncIterator] = function() {
          return this;
        }, i5;
        function verb(n3) {
          if (g5[n3])
            i5[n3] = function(v5) {
              return new Promise(function(a5, b4) {
                q5.push([n3, v5, a5, b4]) > 1 || resume2(n3, v5);
              });
            };
        }
        function resume2(n3, v5) {
          try {
            step(g5[n3](v5));
          } catch (e5) {
            settle(q5[0][3], e5);
          }
        }
        function step(r6) {
          r6.value instanceof __await2 ? Promise.resolve(r6.value.v).then(fulfill, reject) : settle(q5[0][2], r6);
        }
        function fulfill(value) {
          resume2("next", value);
        }
        function reject(value) {
          resume2("throw", value);
        }
        function settle(f5, v5) {
          if (f5(v5), q5.shift(), q5.length)
            resume2(q5[0][0], q5[0][1]);
        }
      };
      __asyncDelegator2 = function(o5) {
        var i5, p5;
        return i5 = {}, verb("next"), verb("throw", function(e5) {
          throw e5;
        }), verb("return"), i5[Symbol.iterator] = function() {
          return this;
        }, i5;
        function verb(n3, f5) {
          i5[n3] = o5[n3] ? function(v5) {
            return (p5 = !p5) ? { value: __await2(o5[n3](v5)), done: n3 === "return" } : f5 ? f5(v5) : v5;
          } : f5;
        }
      };
      __asyncValues2 = function(o5) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m5 = o5[Symbol.asyncIterator], i5;
        return m5 ? m5.call(o5) : (o5 = typeof __values2 === "function" ? __values2(o5) : o5[Symbol.iterator](), i5 = {}, verb("next"), verb("throw"), verb("return"), i5[Symbol.asyncIterator] = function() {
          return this;
        }, i5);
        function verb(n3) {
          i5[n3] = o5[n3] && function(v5) {
            return new Promise(function(resolve, reject) {
              v5 = o5[n3](v5), settle(resolve, reject, v5.done, v5.value);
            });
          };
        }
        function settle(resolve, reject, d5, v5) {
          Promise.resolve(v5).then(function(v6) {
            resolve({ value: v6, done: d5 });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k5 in mod)
            if (Object.hasOwnProperty.call(mod, k5))
              result[k5] = mod[k5];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays3);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// node_modules/rxjs/node_modules/tslib/modules/index.js
var import_tslib, __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __createBinding, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet;
var init_modules = __esm({
  "node_modules/rxjs/node_modules/tslib/modules/index.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    import_tslib = __toESM(require_tslib(), 1);
    ({
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __exportStar,
      __createBinding,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet
    } = import_tslib.default);
  }
});

// node_modules/rxjs/_esm5/internal/util/isFunction.js
function isFunction2(x5) {
  return typeof x5 === "function";
}
var init_isFunction = __esm({
  "node_modules/rxjs/_esm5/internal/util/isFunction.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/rxjs/_esm5/internal/config.js
var _enable_super_gross_mode_that_will_cause_bad_things, config3;
var init_config = __esm({
  "node_modules/rxjs/_esm5/internal/config.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    _enable_super_gross_mode_that_will_cause_bad_things = false;
    config3 = {
      Promise: void 0,
      set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
          var error2 = /* @__PURE__ */ new Error();
          /* @__PURE__ */ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error2.stack);
        } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
          /* @__PURE__ */ console.log("RxJS: Back to a better error behavior. Thank you. <3");
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
      },
      get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/hostReportError.js
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var init_hostReportError = __esm({
  "node_modules/rxjs/_esm5/internal/util/hostReportError.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/rxjs/_esm5/internal/Observer.js
var empty;
var init_Observer = __esm({
  "node_modules/rxjs/_esm5/internal/Observer.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_config();
    init_hostReportError();
    empty = {
      closed: true,
      next: function(value) {
      },
      error: function(err) {
        if (config3.useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          hostReportError(err);
        }
      },
      complete: function() {
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isArray.js
var isArray3;
var init_isArray = __esm({
  "node_modules/rxjs/_esm5/internal/util/isArray.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    isArray3 = /* @__PURE__ */ function() {
      return Array.isArray || function(x5) {
        return x5 && typeof x5.length === "number";
      };
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/isObject.js
function isObject2(x5) {
  return x5 !== null && typeof x5 === "object";
}
var init_isObject = __esm({
  "node_modules/rxjs/_esm5/internal/util/isObject.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionErrorImpl, UnsubscriptionError;
var init_UnsubscriptionError = __esm({
  "node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
      function UnsubscriptionErrorImpl2(errors2) {
        Error.call(this);
        this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i5) {
          return i5 + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors2;
        return this;
      }
      UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
      return UnsubscriptionErrorImpl2;
    }();
    UnsubscriptionError = UnsubscriptionErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/Subscription.js
function flattenUnsubscriptionErrors(errors2) {
  return errors2.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var Subscription;
var init_Subscription = __esm({
  "node_modules/rxjs/_esm5/internal/Subscription.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_isArray();
    init_isObject();
    init_isFunction();
    init_UnsubscriptionError();
    Subscription = /* @__PURE__ */ function() {
      function Subscription2(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
          this._ctorUnsubscribe = true;
          this._unsubscribe = unsubscribe;
        }
      }
      Subscription2.prototype.unsubscribe = function() {
        var errors2;
        if (this.closed) {
          return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription2) {
          _parentOrParents.remove(this);
        } else if (_parentOrParents !== null) {
          for (var index = 0; index < _parentOrParents.length; ++index) {
            var parent_1 = _parentOrParents[index];
            parent_1.remove(this);
          }
        }
        if (isFunction2(_unsubscribe)) {
          if (_ctorUnsubscribe) {
            this._unsubscribe = void 0;
          }
          try {
            _unsubscribe.call(this);
          } catch (e5) {
            errors2 = e5 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e5.errors) : [e5];
          }
        }
        if (isArray3(_subscriptions)) {
          var index = -1;
          var len = _subscriptions.length;
          while (++index < len) {
            var sub = _subscriptions[index];
            if (isObject2(sub)) {
              try {
                sub.unsubscribe();
              } catch (e5) {
                errors2 = errors2 || [];
                if (e5 instanceof UnsubscriptionError) {
                  errors2 = errors2.concat(flattenUnsubscriptionErrors(e5.errors));
                } else {
                  errors2.push(e5);
                }
              }
            }
          }
        }
        if (errors2) {
          throw new UnsubscriptionError(errors2);
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var subscription = teardown;
        if (!teardown) {
          return Subscription2.EMPTY;
        }
        switch (typeof teardown) {
          case "function":
            subscription = new Subscription2(teardown);
          case "object":
            if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
              return subscription;
            } else if (this.closed) {
              subscription.unsubscribe();
              return subscription;
            } else if (!(subscription instanceof Subscription2)) {
              var tmp = subscription;
              subscription = new Subscription2();
              subscription._subscriptions = [tmp];
            }
            break;
          default: {
            throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
          }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
          subscription._parentOrParents = this;
        } else if (_parentOrParents instanceof Subscription2) {
          if (_parentOrParents === this) {
            return subscription;
          }
          subscription._parentOrParents = [_parentOrParents, this];
        } else if (_parentOrParents.indexOf(this) === -1) {
          _parentOrParents.push(this);
        } else {
          return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
          this._subscriptions = [subscription];
        } else {
          subscriptions.push(subscription);
        }
        return subscription;
      };
      Subscription2.prototype.remove = function(subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
          var subscriptionIndex = subscriptions.indexOf(subscription);
          if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
          }
        }
      };
      Subscription2.EMPTY = function(empty3) {
        empty3.closed = true;
        return empty3;
      }(new Subscription2());
      return Subscription2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
var rxSubscriber;
var init_rxSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    rxSubscriber = /* @__PURE__ */ function() {
      return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
    }();
  }
});

// node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber, SafeSubscriber;
var init_Subscriber = __esm({
  "node_modules/rxjs/_esm5/internal/Subscriber.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_isFunction();
    init_Observer();
    init_Subscription();
    init_rxSubscriber();
    init_config();
    init_hostReportError();
    Subscriber = /* @__PURE__ */ function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destinationOrNext, error2, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
          case 0:
            _this.destination = empty;
            break;
          case 1:
            if (!destinationOrNext) {
              _this.destination = empty;
              break;
            }
            if (typeof destinationOrNext === "object") {
              if (destinationOrNext instanceof Subscriber2) {
                _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                _this.destination = destinationOrNext;
                destinationOrNext.add(_this);
              } else {
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext);
              }
              break;
            }
          default:
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext, error2, complete);
            break;
        }
        return _this;
      }
      Subscriber2.prototype[rxSubscriber] = function() {
        return this;
      };
      Subscriber2.create = function(next, error2, complete) {
        var subscriber = new Subscriber2(next, error2, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
      };
      Subscriber2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        this.destination.error(err);
        this.unsubscribe();
      };
      Subscriber2.prototype._complete = function() {
        this.destination.complete();
        this.unsubscribe();
      };
      Subscriber2.prototype._unsubscribeAndRecycle = function() {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
      };
      return Subscriber2;
    }(Subscription);
    SafeSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(_parentSubscriber, observerOrNext, error2, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction2(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          next = observerOrNext.next;
          error2 = observerOrNext.error;
          complete = observerOrNext.complete;
          if (observerOrNext !== empty) {
            context = Object.create(observerOrNext);
            if (isFunction2(context.unsubscribe)) {
              _this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = _this.unsubscribe.bind(_this);
          }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error2;
        _this._complete = complete;
        return _this;
      }
      SafeSubscriber2.prototype.next = function(value) {
        if (!this.isStopped && this._next) {
          var _parentSubscriber = this._parentSubscriber;
          if (!config3.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._next, value);
          } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          var useDeprecatedSynchronousErrorHandling = config3.useDeprecatedSynchronousErrorHandling;
          if (this._error) {
            if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(this._error, err);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, this._error, err);
              this.unsubscribe();
            }
          } else if (!_parentSubscriber.syncErrorThrowable) {
            this.unsubscribe();
            if (useDeprecatedSynchronousErrorHandling) {
              throw err;
            }
            hostReportError(err);
          } else {
            if (useDeprecatedSynchronousErrorHandling) {
              _parentSubscriber.syncErrorValue = err;
              _parentSubscriber.syncErrorThrown = true;
            } else {
              hostReportError(err);
            }
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.complete = function() {
        var _this = this;
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          if (this._complete) {
            var wrappedComplete = function() {
              return _this._complete.call(_this._context);
            };
            if (!config3.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(wrappedComplete);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, wrappedComplete);
              this.unsubscribe();
            }
          } else {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
        try {
          fn.call(this._context, value);
        } catch (err) {
          this.unsubscribe();
          if (config3.useDeprecatedSynchronousErrorHandling) {
            throw err;
          } else {
            hostReportError(err);
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value) {
        if (!config3.useDeprecatedSynchronousErrorHandling) {
          throw new Error("bad call");
        }
        try {
          fn.call(this._context, value);
        } catch (err) {
          if (config3.useDeprecatedSynchronousErrorHandling) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
          } else {
            hostReportError(err);
            return true;
          }
        }
        return false;
      };
      SafeSubscriber2.prototype._unsubscribe = function() {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
      };
      return SafeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/canReportError.js
function canReportError(observer) {
  while (observer) {
    var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
var init_canReportError = __esm({
  "node_modules/rxjs/_esm5/internal/util/canReportError.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Subscriber();
  }
});

// node_modules/rxjs/_esm5/internal/util/toSubscriber.js
function toSubscriber(nextOrObserver, error2, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error2 && !complete) {
    return new Subscriber(empty);
  }
  return new Subscriber(nextOrObserver, error2, complete);
}
var init_toSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/util/toSubscriber.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Subscriber();
    init_rxSubscriber();
    init_Observer();
  }
});

// node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable;
var init_observable = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/observable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    observable = /* @__PURE__ */ function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/identity.js
function identity(x5) {
  return x5;
}
var init_identity = __esm({
  "node_modules/rxjs/_esm5/internal/util/identity.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/rxjs/_esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var init_pipe = __esm({
  "node_modules/rxjs/_esm5/internal/util/pipe.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/Observable.js
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config3.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var Observable;
var init_Observable = __esm({
  "node_modules/rxjs/_esm5/internal/Observable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_canReportError();
    init_toSubscriber();
    init_observable();
    init_pipe();
    init_config();
    Observable = /* @__PURE__ */ function() {
      function Observable2(subscribe) {
        this._isScalar = false;
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable2 = new Observable2();
        observable2.source = this;
        observable2.operator = operator;
        return observable2;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error2, complete);
        if (operator) {
          sink.add(operator.call(sink, this.source));
        } else {
          sink.add(this.source || config3.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (config3.useDeprecatedSynchronousErrorHandling) {
          if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
              throw sink.syncErrorValue;
            }
          }
        }
        return sink;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          if (config3.useDeprecatedSynchronousErrorHandling) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
          }
          if (canReportError(sink)) {
            sink.error(err);
          } else {
            console.warn(err);
          }
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscription;
          subscription = _this.subscribe(function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              if (subscription) {
                subscription.unsubscribe();
              }
            }
          }, reject, resolve);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
      };
      Observable2.prototype[observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
          return this;
        }
        return pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x5) {
            return value = x5;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedErrorImpl, ObjectUnsubscribedError;
var init_ObjectUnsubscribedError = __esm({
  "node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
      function ObjectUnsubscribedErrorImpl2() {
        Error.call(this);
        this.message = "object unsubscribed";
        this.name = "ObjectUnsubscribedError";
        return this;
      }
      ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
      return ObjectUnsubscribedErrorImpl2;
    }();
    ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/SubjectSubscription.js
var SubjectSubscription;
var init_SubjectSubscription = __esm({
  "node_modules/rxjs/_esm5/internal/SubjectSubscription.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscription();
    SubjectSubscription = /* @__PURE__ */ function(_super) {
      __extends(SubjectSubscription2, _super);
      function SubjectSubscription2(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
      }
      SubjectSubscription2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
          return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
          observers.splice(subscriberIndex, 1);
        }
      };
      return SubjectSubscription2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/Subject.js
var SubjectSubscriber, Subject, AnonymousSubject;
var init_Subject = __esm({
  "node_modules/rxjs/_esm5/internal/Subject.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Observable();
    init_Subscriber();
    init_Subscription();
    init_ObjectUnsubscribedError();
    init_SubjectSubscription();
    init_rxSubscriber();
    SubjectSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SubjectSubscriber2, _super);
      function SubjectSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
      }
      return SubjectSubscriber2;
    }(Subscriber);
    Subject = /* @__PURE__ */ function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype[rxSubscriber] = function() {
        return new SubjectSubscriber(this);
      };
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype.next = function(value) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
          var observers = this.observers;
          var len = observers.length;
          var copy3 = observers.slice();
          for (var i5 = 0; i5 < len; i5++) {
            copy3[i5].next(value);
          }
        }
      };
      Subject2.prototype.error = function(err) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy3 = observers.slice();
        for (var i5 = 0; i5 < len; i5++) {
          copy3[i5].error(err);
        }
        this.observers.length = 0;
      };
      Subject2.prototype.complete = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy3 = observers.slice();
        for (var i5 = 0; i5 < len; i5++) {
          copy3[i5].complete();
        }
        this.observers.length = 0;
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
      };
      Subject2.prototype._trySubscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else {
          return _super.prototype._trySubscribe.call(this, subscriber);
        }
      };
      Subject2.prototype._subscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription.EMPTY;
        } else if (this.isStopped) {
          subscriber.complete();
          return Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          return new SubjectSubscription(this, subscriber);
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable2 = new Observable();
        observable2.source = this;
        return observable2;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable);
    AnonymousSubject = /* @__PURE__ */ function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var destination = this.destination;
        if (destination && destination.next) {
          destination.next(value);
        }
      };
      AnonymousSubject2.prototype.error = function(err) {
        var destination = this.destination;
        if (destination && destination.error) {
          this.destination.error(err);
        }
      };
      AnonymousSubject2.prototype.complete = function() {
        var destination = this.destination;
        if (destination && destination.complete) {
          this.destination.complete();
        }
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        if (source) {
          return this.source.subscribe(subscriber);
        } else {
          return Subscription.EMPTY;
        }
      };
      return AnonymousSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/operators/refCount.js
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}
var RefCountOperator, RefCountSubscriber;
var init_refCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/refCount.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    RefCountOperator = /* @__PURE__ */ function() {
      function RefCountOperator2(connectable) {
        this.connectable = connectable;
      }
      RefCountOperator2.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }
        return subscription;
      };
      return RefCountOperator2;
    }();
    RefCountSubscriber = /* @__PURE__ */ function(_super) {
      __extends(RefCountSubscriber2, _super);
      function RefCountSubscriber2(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      RefCountSubscriber2.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
          this.connection = null;
          return;
        }
        this.connectable = null;
        var refCount2 = connectable._refCount;
        if (refCount2 <= 0) {
          this.connection = null;
          return;
        }
        connectable._refCount = refCount2 - 1;
        if (refCount2 > 1) {
          this.connection = null;
          return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };
      return RefCountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable, connectableObservableDescriptor, ConnectableSubscriber;
var init_ConnectableObservable = __esm({
  "node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subject();
    init_Observable();
    init_Subscription();
    init_refCount();
    ConnectableObservable = /* @__PURE__ */ function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype.connect = function() {
        var connection = this._connection;
        if (!connection) {
          this._isComplete = false;
          connection = this._connection = new Subscription();
          connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable);
    connectableObservableDescriptor = /* @__PURE__ */ function() {
      var connectableProto = ConnectableObservable.prototype;
      return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
      };
    }();
    ConnectableSubscriber = /* @__PURE__ */ function(_super) {
      __extends(ConnectableSubscriber2, _super);
      function ConnectableSubscriber2(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      ConnectableSubscriber2.prototype._error = function(err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
      };
      ConnectableSubscriber2.prototype._complete = function() {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
      };
      ConnectableSubscriber2.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (connectable) {
          this.connectable = null;
          var connection = connectable._connection;
          connectable._refCount = 0;
          connectable._subject = null;
          connectable._connection = null;
          if (connection) {
            connection.unsubscribe();
          }
        }
      };
      return ConnectableSubscriber2;
    }(SubjectSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/groupBy.js
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source) {
    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator, GroupBySubscriber, GroupDurationSubscriber, GroupedObservable, InnerRefCountSubscription;
var init_groupBy = __esm({
  "node_modules/rxjs/_esm5/internal/operators/groupBy.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_Subscription();
    init_Observable();
    init_Subject();
    GroupByOperator = /* @__PURE__ */ function() {
      function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
      }
      GroupByOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
      };
      return GroupByOperator2;
    }();
    GroupBySubscriber = /* @__PURE__ */ function(_super) {
      __extends(GroupBySubscriber2, _super);
      function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
      }
      GroupBySubscriber2.prototype._next = function(value) {
        var key;
        try {
          key = this.keySelector(value);
        } catch (err) {
          this.error(err);
          return;
        }
        this._group(value, key);
      };
      GroupBySubscriber2.prototype._group = function(value, key) {
        var groups = this.groups;
        if (!groups) {
          groups = this.groups = /* @__PURE__ */ new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
          try {
            element = this.elementSelector(value);
          } catch (err) {
            this.error(err);
          }
        } else {
          element = value;
        }
        if (!group) {
          group = this.subjectSelector ? this.subjectSelector() : new Subject();
          groups.set(key, group);
          var groupedObservable = new GroupedObservable(key, group, this);
          this.destination.next(groupedObservable);
          if (this.durationSelector) {
            var duration = void 0;
            try {
              duration = this.durationSelector(new GroupedObservable(key, group));
            } catch (err) {
              this.error(err);
              return;
            }
            this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
          }
        }
        if (!group.closed) {
          group.next(element);
        }
      };
      GroupBySubscriber2.prototype._error = function(err) {
        var groups = this.groups;
        if (groups) {
          groups.forEach(function(group, key) {
            group.error(err);
          });
          groups.clear();
        }
        this.destination.error(err);
      };
      GroupBySubscriber2.prototype._complete = function() {
        var groups = this.groups;
        if (groups) {
          groups.forEach(function(group, key) {
            group.complete();
          });
          groups.clear();
        }
        this.destination.complete();
      };
      GroupBySubscriber2.prototype.removeGroup = function(key) {
        this.groups.delete(key);
      };
      GroupBySubscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.attemptedToUnsubscribe = true;
          if (this.count === 0) {
            _super.prototype.unsubscribe.call(this);
          }
        }
      };
      return GroupBySubscriber2;
    }(Subscriber);
    GroupDurationSubscriber = /* @__PURE__ */ function(_super) {
      __extends(GroupDurationSubscriber2, _super);
      function GroupDurationSubscriber2(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
      }
      GroupDurationSubscriber2.prototype._next = function(value) {
        this.complete();
      };
      GroupDurationSubscriber2.prototype._unsubscribe = function() {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
          parent.removeGroup(key);
        }
      };
      return GroupDurationSubscriber2;
    }(Subscriber);
    GroupedObservable = /* @__PURE__ */ function(_super) {
      __extends(GroupedObservable2, _super);
      function GroupedObservable2(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
      }
      GroupedObservable2.prototype._subscribe = function(subscriber) {
        var subscription = new Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
          subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
      };
      return GroupedObservable2;
    }(Observable);
    InnerRefCountSubscription = /* @__PURE__ */ function(_super) {
      __extends(InnerRefCountSubscription2, _super);
      function InnerRefCountSubscription2(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
      }
      InnerRefCountSubscription2.prototype.unsubscribe = function() {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
          _super.prototype.unsubscribe.call(this);
          parent.count -= 1;
          if (parent.count === 0 && parent.attemptedToUnsubscribe) {
            parent.unsubscribe();
          }
        }
      };
      return InnerRefCountSubscription2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/BehaviorSubject.js
var BehaviorSubject;
var init_BehaviorSubject = __esm({
  "node_modules/rxjs/_esm5/internal/BehaviorSubject.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subject();
    init_ObjectUnsubscribedError();
    BehaviorSubject = /* @__PURE__ */ function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: true,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
          subscriber.next(this._value);
        }
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        if (this.hasError) {
          throw this.thrownError;
        } else if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else {
          return this._value;
        }
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/Action.js
var Action;
var init_Action = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/Action.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscription();
    Action = /* @__PURE__ */ function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
var AsyncAction;
var init_AsyncAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Action();
    AsyncAction = /* @__PURE__ */ function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay2);
        }
        this.pending = true;
        this.delay = delay2;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay2);
      };
      AsyncAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && this.delay === delay2 && this.pending === false) {
          return id;
        }
        clearInterval(id);
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay2) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error2 = this._execute(state, delay2);
        if (error2) {
          return error2;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, delay2) {
        var errored = false;
        var errorValue = void 0;
        try {
          this.work(state);
        } catch (e5) {
          errored = true;
          errorValue = !!e5 && e5 || new Error(e5);
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype._unsubscribe = function() {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
          actions.splice(index, 1);
        }
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
      };
      return AsyncAction2;
    }(Action);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js
var QueueAction;
var init_QueueAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_AsyncAction();
    QueueAction = /* @__PURE__ */ function(_super) {
      __extends(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 > 0) {
          return _super.prototype.schedule.call(this, state, delay2);
        }
        this.delay = delay2;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay2) {
        return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        return scheduler.flush(this);
      };
      return QueueAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/Scheduler.js
var Scheduler;
var init_Scheduler = __esm({
  "node_modules/rxjs/_esm5/internal/Scheduler.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Scheduler = /* @__PURE__ */ function() {
      function Scheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay2);
      };
      Scheduler2.now = function() {
        return Date.now();
      };
      return Scheduler2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler;
var init_AsyncScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Scheduler();
    AsyncScheduler = /* @__PURE__ */ function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function() {
          if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
            return AsyncScheduler2.delegate.now();
          } else {
            return now();
          }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = void 0;
        return _this;
      }
      AsyncScheduler2.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
          return AsyncScheduler2.delegate.schedule(work, delay2, state);
        } else {
          return _super.prototype.schedule.call(this, work, delay2, state);
        }
      };
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this.active) {
          actions.push(action);
          return;
        }
        var error2;
        this.active = true;
        do {
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this.active = false;
        if (error2) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      return AsyncScheduler2;
    }(Scheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler;
var init_QueueScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_AsyncScheduler();
    QueueScheduler = /* @__PURE__ */ function(_super) {
      __extends(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/queue.js
var queueScheduler, queue3;
var init_queue = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/queue.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_QueueAction();
    init_QueueScheduler();
    queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction);
    queue3 = queueScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/observable/empty.js
function empty2(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
var EMPTY;
var init_empty = __esm({
  "node_modules/rxjs/_esm5/internal/observable/empty.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    EMPTY = /* @__PURE__ */ new Observable(function(subscriber) {
      return subscriber.complete();
    });
  }
});

// node_modules/rxjs/_esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && typeof value.schedule === "function";
}
var init_isScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/util/isScheduler.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
var subscribeToArray;
var init_subscribeToArray = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToArray.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    subscribeToArray = function(array) {
      return function(subscriber) {
        for (var i5 = 0, len = array.length; i5 < len && !subscriber.closed; i5++) {
          subscriber.next(array[i5]);
        }
        subscriber.complete();
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var i5 = 0;
    sub.add(scheduler.schedule(function() {
      if (i5 === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i5++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
var init_scheduleArray = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromArray.js
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler);
  }
}
var init_fromArray = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromArray.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_subscribeToArray();
    init_scheduleArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
    return scheduleArray(args, scheduler);
  } else {
    return fromArray(args);
  }
}
var init_of = __esm({
  "node_modules/rxjs/_esm5/internal/observable/of.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_isScheduler();
    init_fromArray();
    init_scheduleArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/throwError.js
function throwError(error2, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      return subscriber.error(error2);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler.schedule(dispatch, 0, { error: error2, subscriber });
    });
  }
}
function dispatch(_a) {
  var error2 = _a.error, subscriber = _a.subscriber;
  subscriber.error(error2);
}
var init_throwError = __esm({
  "node_modules/rxjs/_esm5/internal/observable/throwError.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/Notification.js
var NotificationKind, Notification;
var init_Notification = __esm({
  "node_modules/rxjs/_esm5/internal/Notification.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_empty();
    init_of();
    init_throwError();
    /* @__PURE__ */ (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind || (NotificationKind = {}));
    Notification = /* @__PURE__ */ function() {
      function Notification2(kind, value, error2) {
        this.kind = kind;
        this.value = value;
        this.error = error2;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        switch (this.kind) {
          case "N":
            return observer.next && observer.next(this.value);
          case "E":
            return observer.error && observer.error(this.error);
          case "C":
            return observer.complete && observer.complete();
        }
      };
      Notification2.prototype.do = function(next, error2, complete) {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return next && next(this.value);
          case "E":
            return error2 && error2(this.error);
          case "C":
            return complete && complete();
        }
      };
      Notification2.prototype.accept = function(nextOrObserver, error2, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === "function") {
          return this.observe(nextOrObserver);
        } else {
          return this.do(nextOrObserver, error2, complete);
        }
      };
      Notification2.prototype.toObservable = function() {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return of(this.value);
          case "E":
            return throwError(this.error);
          case "C":
            return empty2();
        }
        throw new Error("unexpected notification kind value");
      };
      Notification2.createNext = function(value) {
        if (typeof value !== "undefined") {
          return new Notification2("N", value);
        }
        return Notification2.undefinedValueNotification;
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      Notification2.undefinedValueNotification = new Notification2("N", void 0);
      return Notification2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay2));
  };
}
var ObserveOnOperator, ObserveOnSubscriber, ObserveOnMessage;
var init_observeOn = __esm({
  "node_modules/rxjs/_esm5/internal/operators/observeOn.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_Notification();
    ObserveOnOperator = /* @__PURE__ */ function() {
      function ObserveOnOperator2(scheduler, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay2;
      }
      ObserveOnOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
      };
      return ObserveOnOperator2;
    }();
    ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
      __extends(ObserveOnSubscriber2, _super);
      function ObserveOnSubscriber2(destination, scheduler, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay2;
        return _this;
      }
      ObserveOnSubscriber2.dispatch = function(arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
      };
      ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
      };
      ObserveOnSubscriber2.prototype._next = function(value) {
        this.scheduleMessage(Notification.createNext(value));
      };
      ObserveOnSubscriber2.prototype._error = function(err) {
        this.scheduleMessage(Notification.createError(err));
        this.unsubscribe();
      };
      ObserveOnSubscriber2.prototype._complete = function() {
        this.scheduleMessage(Notification.createComplete());
        this.unsubscribe();
      };
      return ObserveOnSubscriber2;
    }(Subscriber);
    ObserveOnMessage = /* @__PURE__ */ function() {
      function ObserveOnMessage2(notification, destination) {
        this.notification = notification;
        this.destination = destination;
      }
      return ObserveOnMessage2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/ReplaySubject.js
var ReplaySubject, ReplayEvent;
var init_ReplaySubject = __esm({
  "node_modules/rxjs/_esm5/internal/ReplaySubject.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subject();
    init_queue();
    init_Subscription();
    init_observeOn();
    init_ObjectUnsubscribedError();
    init_SubjectSubscription();
    ReplaySubject = /* @__PURE__ */ function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(bufferSize, windowTime2, scheduler) {
        if (bufferSize === void 0) {
          bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime2 === void 0) {
          windowTime2 = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
        if (windowTime2 === Number.POSITIVE_INFINITY) {
          _this._infiniteTimeWindow = true;
          _this.next = _this.nextInfiniteTimeWindow;
        } else {
          _this.next = _this.nextTimeWindow;
        }
        return _this;
      }
      ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
        if (!this.isStopped) {
          var _events = this._events;
          _events.push(value);
          if (_events.length > this._bufferSize) {
            _events.shift();
          }
        }
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype.nextTimeWindow = function(value) {
        if (!this.isStopped) {
          this._events.push(new ReplayEvent(this._getNow(), value));
          this._trimBufferThenGetEvents();
        }
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else if (this.isStopped || this.hasError) {
          subscription = Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          subscription = new SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
          subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
          for (var i5 = 0; i5 < len && !subscriber.closed; i5++) {
            subscriber.next(_events[i5]);
          }
        } else {
          for (var i5 = 0; i5 < len && !subscriber.closed; i5++) {
            subscriber.next(_events[i5].value);
          }
        }
        if (this.hasError) {
          subscriber.error(this.thrownError);
        } else if (this.isStopped) {
          subscriber.complete();
        }
        return subscription;
      };
      ReplaySubject2.prototype._getNow = function() {
        return (this.scheduler || queue3).now();
      };
      ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
          if (now - _events[spliceCount].time < _windowTime) {
            break;
          }
          spliceCount++;
        }
        if (eventsCount > _bufferSize) {
          spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
          _events.splice(0, spliceCount);
        }
        return _events;
      };
      return ReplaySubject2;
    }(Subject);
    ReplayEvent = /* @__PURE__ */ function() {
      function ReplayEvent2(time, value) {
        this.time = time;
        this.value = value;
      }
      return ReplayEvent2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/AsyncSubject.js
var AsyncSubject;
var init_AsyncSubject = __esm({
  "node_modules/rxjs/_esm5/internal/AsyncSubject.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subject();
    init_Subscription();
    AsyncSubject = /* @__PURE__ */ function(_super) {
      __extends(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
      }
      AsyncSubject2.prototype._subscribe = function(subscriber) {
        if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription.EMPTY;
        } else if (this.hasCompleted && this.hasNext) {
          subscriber.next(this.value);
          subscriber.complete();
          return Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.hasCompleted) {
          this.value = value;
          this.hasNext = true;
        }
      };
      AsyncSubject2.prototype.error = function(error2) {
        if (!this.hasCompleted) {
          _super.prototype.error.call(this, error2);
        }
      };
      AsyncSubject2.prototype.complete = function() {
        this.hasCompleted = true;
        if (this.hasNext) {
          _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
      };
      return AsyncSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/util/Immediate.js
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var nextHandle, RESOLVED, activeHandles, Immediate;
var init_Immediate = __esm({
  "node_modules/rxjs/_esm5/internal/util/Immediate.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    nextHandle = 1;
    RESOLVED = /* @__PURE__ */ function() {
      return /* @__PURE__ */ Promise.resolve();
    }();
    activeHandles = {};
    Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js
var AsapAction;
var init_AsapAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Immediate();
    init_AsyncAction();
    AsapAction = /* @__PURE__ */ function(_super) {
      __extends(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
        }
        if (scheduler.actions.length === 0) {
          Immediate.clearImmediate(id);
          scheduler.scheduled = void 0;
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler;
var init_AsapScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_AsyncScheduler();
    AsapScheduler = /* @__PURE__ */ function(_super) {
      __extends(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = void 0;
        var actions = this.actions;
        var error2;
        var index = -1;
        var count2 = actions.length;
        action = action || actions.shift();
        do {
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count2 && (action = actions.shift()));
        this.active = false;
        if (error2) {
          while (++index < count2 && (action = actions.shift())) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/asap.js
var asapScheduler, asap;
var init_asap = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/asap.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_AsapAction();
    init_AsapScheduler();
    asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction);
    asap = asapScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/async.js
var asyncScheduler, async;
var init_async = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/async.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_AsyncAction();
    init_AsyncScheduler();
    asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction);
    async = asyncScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction;
var init_AnimationFrameAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_AsyncAction();
    AnimationFrameAction = /* @__PURE__ */ function(_super) {
      __extends(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
          return scheduler.flush(null);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
        }
        if (scheduler.actions.length === 0) {
          cancelAnimationFrame(id);
          scheduler.scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler;
var init_AnimationFrameScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_AsyncScheduler();
    AnimationFrameScheduler = /* @__PURE__ */ function(_super) {
      __extends(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = void 0;
        var actions = this.actions;
        var error2;
        var index = -1;
        var count2 = actions.length;
        action = action || actions.shift();
        do {
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count2 && (action = actions.shift()));
        this.active = false;
        if (error2) {
          while (++index < count2 && (action = actions.shift())) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler, animationFrame;
var init_animationFrame = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_AnimationFrameAction();
    init_AnimationFrameScheduler();
    animationFrameScheduler = /* @__PURE__ */ new AnimationFrameScheduler(AnimationFrameAction);
    animationFrame = animationFrameScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler, VirtualAction;
var init_VirtualTimeScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_AsyncAction();
    init_AsyncScheduler();
    VirtualTimeScheduler = /* @__PURE__ */ function(_super) {
      __extends(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
          SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error2, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error2) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler);
    VirtualAction = /* @__PURE__ */ function(_super) {
      __extends(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (!this.id) {
          return _super.prototype.schedule.call(this, state, delay2);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay2);
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.delay = scheduler.frame + delay2;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return true;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay2) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay2);
        }
      };
      VirtualAction2.sortActions = function(a5, b4) {
        if (a5.delay === b4.delay) {
          if (a5.index === b4.index) {
            return 0;
          } else if (a5.index > b4.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a5.delay > b4.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/util/noop.js
function noop3() {
}
var init_noop = __esm({
  "node_modules/rxjs/_esm5/internal/util/noop.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/rxjs/_esm5/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || typeof obj.lift === "function" && typeof obj.subscribe === "function");
}
var init_isObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isObservable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeErrorImpl, ArgumentOutOfRangeError;
var init_ArgumentOutOfRangeError = __esm({
  "node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
      function ArgumentOutOfRangeErrorImpl2() {
        Error.call(this);
        this.message = "argument out of range";
        this.name = "ArgumentOutOfRangeError";
        return this;
      }
      ArgumentOutOfRangeErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
      return ArgumentOutOfRangeErrorImpl2;
    }();
    ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/util/EmptyError.js
var EmptyErrorImpl, EmptyError;
var init_EmptyError = __esm({
  "node_modules/rxjs/_esm5/internal/util/EmptyError.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    EmptyErrorImpl = /* @__PURE__ */ function() {
      function EmptyErrorImpl2() {
        Error.call(this);
        this.message = "no elements in sequence";
        this.name = "EmptyError";
        return this;
      }
      EmptyErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
      return EmptyErrorImpl2;
    }();
    EmptyError = EmptyErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/util/TimeoutError.js
var TimeoutErrorImpl, TimeoutError;
var init_TimeoutError = __esm({
  "node_modules/rxjs/_esm5/internal/util/TimeoutError.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    TimeoutErrorImpl = /* @__PURE__ */ function() {
      function TimeoutErrorImpl2() {
        Error.call(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        return this;
      }
      TimeoutErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
      return TimeoutErrorImpl2;
    }();
    TimeoutError = TimeoutErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/operators/map.js
function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator, MapSubscriber;
var init_map = __esm({
  "node_modules/rxjs/_esm5/internal/operators/map.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    MapOperator = /* @__PURE__ */ function() {
      function MapOperator2(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
      }
      MapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      };
      return MapOperator2;
    }();
    MapSubscriber = /* @__PURE__ */ function(_super) {
      __extends(MapSubscriber2, _super);
      function MapSubscriber2(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
      }
      MapSubscriber2.prototype._next = function(value) {
        var result;
        try {
          result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return MapSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/bindCallback.js
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray3(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var context = this;
    var subject;
    var params = {
      context,
      subject,
      callbackFunc,
      scheduler
    };
    return new Observable(function(subscriber) {
      if (!scheduler) {
        if (!subject) {
          subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        var state = {
          args,
          subscriber,
          params
        };
        return scheduler.schedule(dispatch2, 0, state);
      }
    });
  };
}
function dispatch2(state) {
  var _this = this;
  var self2 = this;
  var args = state.args, subscriber = state.subscriber, params = state.params;
  var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
      _this.add(scheduler.schedule(dispatchNext, 0, { value, subject }));
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
  var value = state.value, subject = state.subject;
  subject.next(value);
  subject.complete();
}
var init_bindCallback = __esm({
  "node_modules/rxjs/_esm5/internal/observable/bindCallback.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_AsyncSubject();
    init_map();
    init_canReportError();
    init_isArray();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray3(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {
      subject: void 0,
      args,
      callbackFunc,
      scheduler,
      context: this
    };
    return new Observable(function(subscriber) {
      var context = params.context;
      var subject = params.subject;
      if (!scheduler) {
        if (!subject) {
          subject = params.subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            var err = innerArgs.shift();
            if (err) {
              subject.error(err);
              return;
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        return scheduler.schedule(dispatch3, 0, { params, subscriber, context });
      }
    });
  };
}
function dispatch3(state) {
  var _this = this;
  var params = state.params, subscriber = state.subscriber, context = state.context;
  var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var err = innerArgs.shift();
      if (err) {
        _this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
      } else {
        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler.schedule(dispatchNext2, 0, { value, subject }));
      }
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext2(arg) {
  var value = arg.value, subject = arg.subject;
  subject.next(value);
  subject.complete();
}
function dispatchError(arg) {
  var err = arg.err, subject = arg.subject;
  subject.error(err);
}
var init_bindNodeCallback = __esm({
  "node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_AsyncSubject();
    init_map();
    init_canReportError();
    init_isScheduler();
    init_isArray();
  }
});

// node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber;
var init_OuterSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/OuterSubscriber.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    OuterSubscriber = /* @__PURE__ */ function(_super) {
      __extends(OuterSubscriber2, _super);
      function OuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      };
      OuterSubscriber2.prototype.notifyError = function(error2, innerSub) {
        this.destination.error(error2);
      };
      OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.destination.complete();
      };
      return OuterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/InnerSubscriber.js
var InnerSubscriber;
var init_InnerSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/InnerSubscriber.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    InnerSubscriber = /* @__PURE__ */ function(_super) {
      __extends(InnerSubscriber2, _super);
      function InnerSubscriber2(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
      }
      InnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
      };
      InnerSubscriber2.prototype._error = function(error2) {
        this.parent.notifyError(error2, this);
        this.unsubscribe();
      };
      InnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };
      return InnerSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
var subscribeToPromise;
var init_subscribeToPromise = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_hostReportError();
    subscribeToPromise = function(promise) {
      return function(subscriber) {
        promise.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, hostReportError);
        return subscriber;
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator;
var init_iterator = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/iterator.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    iterator = /* @__PURE__ */ getSymbolIterator();
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
var subscribeToIterable;
var init_subscribeToIterable = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_iterator();
    subscribeToIterable = function(iterable) {
      return function(subscriber) {
        var iterator2 = iterable[iterator]();
        do {
          var item = void 0;
          try {
            item = iterator2.next();
          } catch (err) {
            subscriber.error(err);
            return subscriber;
          }
          if (item.done) {
            subscriber.complete();
            break;
          }
          subscriber.next(item.value);
          if (subscriber.closed) {
            break;
          }
        } while (true);
        if (typeof iterator2.return === "function") {
          subscriber.add(function() {
            if (iterator2.return) {
              iterator2.return();
            }
          });
        }
        return subscriber;
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
var subscribeToObservable;
var init_subscribeToObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_observable();
    subscribeToObservable = function(obj) {
      return function(subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== "function") {
          throw new TypeError("Provided object does not correctly implement Symbol.observable");
        } else {
          return obs.subscribe(subscriber);
        }
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike;
var init_isArrayLike = __esm({
  "node_modules/rxjs/_esm5/internal/util/isArrayLike.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    isArrayLike = function(x5) {
      return x5 && typeof x5.length === "number" && typeof x5 !== "function";
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isPromise.js
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}
var init_isPromise = __esm({
  "node_modules/rxjs/_esm5/internal/util/isPromise.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeTo.js
var subscribeTo;
var init_subscribeTo = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeTo.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_subscribeToArray();
    init_subscribeToPromise();
    init_subscribeToIterable();
    init_subscribeToObservable();
    init_isArrayLike();
    init_isPromise();
    init_isObject();
    init_iterator();
    init_observable();
    subscribeTo = function(result) {
      if (!!result && typeof result[observable] === "function") {
        return subscribeToObservable(result);
      } else if (isArrayLike(result)) {
        return subscribeToArray(result);
      } else if (isPromise(result)) {
        return subscribeToPromise(result);
      } else if (!!result && typeof result[iterator] === "function") {
        return subscribeToIterable(result);
      } else {
        var value = isObject2(result) ? "an invalid object" : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
        throw new TypeError(msg);
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var init_subscribeToResult = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_InnerSubscriber();
    init_subscribeTo();
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/combineLatest.js
function combineLatest() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = void 0;
  var scheduler = void 0;
  if (isScheduler(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }
  if (typeof observables[observables.length - 1] === "function") {
    resultSelector = observables.pop();
  }
  if (observables.length === 1 && isArray3(observables[0])) {
    observables = observables[0];
  }
  return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var NONE, CombineLatestOperator, CombineLatestSubscriber;
var init_combineLatest = __esm({
  "node_modules/rxjs/_esm5/internal/observable/combineLatest.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_isScheduler();
    init_isArray();
    init_OuterSubscriber();
    init_subscribeToResult();
    init_fromArray();
    NONE = {};
    CombineLatestOperator = /* @__PURE__ */ function() {
      function CombineLatestOperator2(resultSelector) {
        this.resultSelector = resultSelector;
      }
      CombineLatestOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
      };
      return CombineLatestOperator2;
    }();
    CombineLatestSubscriber = /* @__PURE__ */ function(_super) {
      __extends(CombineLatestSubscriber2, _super);
      function CombineLatestSubscriber2(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
      }
      CombineLatestSubscriber2.prototype._next = function(observable2) {
        this.values.push(NONE);
        this.observables.push(observable2);
      };
      CombineLatestSubscriber2.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
          this.destination.complete();
        } else {
          this.active = len;
          this.toRespond = len;
          for (var i5 = 0; i5 < len; i5++) {
            var observable2 = observables[i5];
            this.add(subscribeToResult(this, observable2, void 0, i5));
          }
        }
      };
      CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
        if ((this.active -= 1) === 0) {
          this.destination.complete();
        }
      };
      CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
          if (this.resultSelector) {
            this._tryResultSelector(values);
          } else {
            this.destination.next(values.slice());
          }
        }
      };
      CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
        var result;
        try {
          result = this.resultSelector.apply(this, values);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return CombineLatestSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      var observable2 = input[observable]();
      sub.add(observable2.subscribe({
        next: function(value) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
var init_scheduleObservable = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_Subscription();
    init_observable();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      return input.then(function(value) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value);
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
var init_schedulePromise = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var iterator2;
    sub.add(function() {
      if (iterator2 && typeof iterator2.return === "function") {
        iterator2.return();
      }
    });
    sub.add(scheduler.schedule(function() {
      iterator2 = input[iterator]();
      sub.add(scheduler.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value;
        var done2;
        try {
          var result = iterator2.next();
          value = result.value;
          done2 = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done2) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
var init_scheduleIterable = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_Subscription();
    init_iterator();
  }
});

// node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
var init_isInteropObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isInteropObservable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_observable();
  }
});

// node_modules/rxjs/_esm5/internal/util/isIterable.js
function isIterable(input) {
  return input && typeof input[iterator] === "function";
}
var init_isIterable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isIterable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_iterator();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    } else if (isIterable(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
var init_scheduled = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduled.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_scheduleObservable();
    init_schedulePromise();
    init_scheduleArray();
    init_scheduleIterable();
    init_isInteropObservable();
    init_isPromise();
    init_isArrayLike();
    init_isIterable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/from.js
function from3(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler);
  }
}
var init_from = __esm({
  "node_modules/rxjs/_esm5/internal/observable/from.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_subscribeTo();
    init_scheduled();
  }
});

// node_modules/rxjs/_esm5/internal/innerSubscribe.js
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error2) {
    innerSubscriber.error(error2);
  }
  return subscription;
}
var SimpleInnerSubscriber, SimpleOuterSubscriber;
var init_innerSubscribe = __esm({
  "node_modules/rxjs/_esm5/internal/innerSubscribe.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_Observable();
    init_subscribeTo();
    SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SimpleInnerSubscriber2, _super);
      function SimpleInnerSubscriber2(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
      }
      SimpleInnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(value);
      };
      SimpleInnerSubscriber2.prototype._error = function(error2) {
        this.parent.notifyError(error2);
        this.unsubscribe();
      };
      SimpleInnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete();
        this.unsubscribe();
      };
      return SimpleInnerSubscriber2;
    }(Subscriber);
    SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SimpleOuterSubscriber2, _super);
      function SimpleOuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      SimpleOuterSubscriber2.prototype.notifyError = function(err) {
        this.destination.error(err);
      };
      SimpleOuterSubscriber2.prototype.notifyComplete = function() {
        this.destination.complete();
      };
      return SimpleOuterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(mergeMap(function(a5, i5) {
        return from3(project(a5, i5)).pipe(map(function(b4, ii) {
          return resultSelector(a5, b4, i5, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator, MergeMapSubscriber, flatMap;
var init_mergeMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeMap.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_map();
    init_from();
    init_innerSubscribe();
    MergeMapOperator = /* @__PURE__ */ function() {
      function MergeMapOperator2(project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
      }
      MergeMapOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
      };
      return MergeMapOperator2;
    }();
    MergeMapSubscriber = /* @__PURE__ */ function(_super) {
      __extends(MergeMapSubscriber2, _super);
      function MergeMapSubscriber2(destination, project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
      }
      MergeMapSubscriber2.prototype._next = function(value) {
        if (this.active < this.concurrent) {
          this._tryNext(value);
        } else {
          this.buffer.push(value);
        }
      };
      MergeMapSubscriber2.prototype._tryNext = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.active++;
        this._innerSub(result);
      };
      MergeMapSubscriber2.prototype._innerSub = function(ish) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      MergeMapSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      MergeMapSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2.length > 0) {
          this._next(buffer2.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          this.destination.complete();
        }
      };
      return MergeMapSubscriber2;
    }(SimpleOuterSubscriber);
    flatMap = mergeMap;
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity, concurrent);
}
var init_mergeAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeAll.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_mergeMap();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}
var init_concatAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatAll.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_mergeAll();
  }
});

// node_modules/rxjs/_esm5/internal/observable/concat.js
function concat3() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return concatAll()(of.apply(void 0, observables));
}
var init_concat = __esm({
  "node_modules/rxjs/_esm5/internal/observable/concat.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_of();
    init_concatAll();
  }
});

// node_modules/rxjs/_esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = input ? from3(input) : empty2();
    return source.subscribe(subscriber);
  });
}
var init_defer = __esm({
  "node_modules/rxjs/_esm5/internal/observable/defer.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_from();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/forkJoin.js
function forkJoin() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 1) {
    var first_1 = sources[0];
    if (isArray3(first_1)) {
      return forkJoinInternal(first_1, null);
    }
    if (isObject2(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys2 = Object.keys(first_1);
      return forkJoinInternal(keys2.map(function(key) {
        return first_1[key];
      }), keys2);
    }
  }
  if (typeof sources[sources.length - 1] === "function") {
    var resultSelector_1 = sources.pop();
    sources = sources.length === 1 && isArray3(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe(map(function(args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys2) {
  return new Observable(function(subscriber) {
    var len = sources.length;
    if (len === 0) {
      subscriber.complete();
      return;
    }
    var values = new Array(len);
    var completed = 0;
    var emitted = 0;
    var _loop_1 = function(i6) {
      var source = from3(sources[i6]);
      var hasValue = false;
      subscriber.add(source.subscribe({
        next: function(value) {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }
          values[i6] = value;
        },
        error: function(err) {
          return subscriber.error(err);
        },
        complete: function() {
          completed++;
          if (completed === len || !hasValue) {
            if (emitted === len) {
              subscriber.next(keys2 ? keys2.reduce(function(result, key, i7) {
                return result[key] = values[i7], result;
              }, {}) : values);
            }
            subscriber.complete();
          }
        }
      }));
    };
    for (var i5 = 0; i5 < len; i5++) {
      _loop_1(i5);
    }
  });
}
var init_forkJoin = __esm({
  "node_modules/rxjs/_esm5/internal/observable/forkJoin.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_isArray();
    init_map();
    init_isObject();
    init_from();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromEvent.js
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction2(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(map(function(args) {
      return isArray3(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    function handler(e5) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e5);
      }
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe;
  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe = function() {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe = function() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe = function() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i5 = 0, len = sourceObj.length; i5 < len; i5++) {
      setupSubscription(sourceObj[i5], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError("Invalid event target");
  }
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === "function" && typeof sourceObj.removeListener === "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === "function" && typeof sourceObj.off === "function";
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === "function" && typeof sourceObj.removeEventListener === "function";
}
var init_fromEvent = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromEvent.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_isArray();
    init_isFunction();
    init_map();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(map(function(args) {
      return isArray3(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e5 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e5[_i] = arguments[_i];
      }
      return subscriber.next(e5.length === 1 ? e5[0] : e5);
    };
    var retValue;
    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!isFunction2(removeHandler)) {
      return void 0;
    }
    return function() {
      return removeHandler(handler, retValue);
    };
  });
}
var init_fromEventPattern = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_isArray();
    init_isFunction();
    init_map();
  }
});

// node_modules/rxjs/_esm5/internal/observable/generate.js
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
  var resultSelector;
  var initialState;
  if (arguments.length == 1) {
    var options = initialStateOrOptions;
    initialState = options.initialState;
    condition = options.condition;
    iterate = options.iterate;
    resultSelector = options.resultSelector || identity;
    scheduler = options.scheduler;
  } else if (resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable)) {
    initialState = initialStateOrOptions;
    resultSelector = identity;
    scheduler = resultSelectorOrObservable;
  } else {
    initialState = initialStateOrOptions;
    resultSelector = resultSelectorOrObservable;
  }
  return new Observable(function(subscriber) {
    var state = initialState;
    if (scheduler) {
      return scheduler.schedule(dispatch4, 0, {
        subscriber,
        iterate,
        condition,
        resultSelector,
        state
      });
    }
    do {
      if (condition) {
        var conditionResult = void 0;
        try {
          conditionResult = condition(state);
        } catch (err) {
          subscriber.error(err);
          return void 0;
        }
        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }
      var value = void 0;
      try {
        value = resultSelector(state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      subscriber.next(value);
      if (subscriber.closed) {
        break;
      }
      try {
        state = iterate(state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
    } while (true);
    return void 0;
  });
}
function dispatch4(state) {
  var subscriber = state.subscriber, condition = state.condition;
  if (subscriber.closed) {
    return void 0;
  }
  if (state.needIterate) {
    try {
      state.state = state.iterate(state.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
  } else {
    state.needIterate = true;
  }
  if (condition) {
    var conditionResult = void 0;
    try {
      conditionResult = condition(state.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!conditionResult) {
      subscriber.complete();
      return void 0;
    }
    if (subscriber.closed) {
      return void 0;
    }
  }
  var value;
  try {
    value = state.resultSelector(state.state);
  } catch (err) {
    subscriber.error(err);
    return void 0;
  }
  if (subscriber.closed) {
    return void 0;
  }
  subscriber.next(value);
  if (subscriber.closed) {
    return void 0;
  }
  return this.schedule(state);
}
var init_generate = __esm({
  "node_modules/rxjs/_esm5/internal/observable/generate.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_identity();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/iif.js
function iif(condition, trueResult, falseResult) {
  if (trueResult === void 0) {
    trueResult = EMPTY;
  }
  if (falseResult === void 0) {
    falseResult = EMPTY;
  }
  return defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
var init_iif = __esm({
  "node_modules/rxjs/_esm5/internal/observable/iif.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_defer();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/util/isNumeric.js
function isNumeric(val) {
  return !isArray3(val) && val - parseFloat(val) + 1 >= 0;
}
var init_isNumeric = __esm({
  "node_modules/rxjs/_esm5/internal/util/isNumeric.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_isArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/interval.js
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (!isNumeric(period) || period < 0) {
    period = 0;
  }
  if (!scheduler || typeof scheduler.schedule !== "function") {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    subscriber.add(scheduler.schedule(dispatch5, period, { subscriber, counter: 0, period }));
    return subscriber;
  });
}
function dispatch5(state) {
  var subscriber = state.subscriber, counter = state.counter, period = state.period;
  subscriber.next(counter);
  this.schedule({ subscriber, counter: counter + 1, period }, period);
}
var init_interval = __esm({
  "node_modules/rxjs/_esm5/internal/observable/interval.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_async();
    init_isNumeric();
  }
});

// node_modules/rxjs/_esm5/internal/observable/merge.js
function merge() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last2 = observables[observables.length - 1];
  if (isScheduler(last2)) {
    scheduler = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
      concurrent = observables.pop();
    }
  } else if (typeof last2 === "number") {
    concurrent = observables.pop();
  }
  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray(observables, scheduler));
}
var init_merge = __esm({
  "node_modules/rxjs/_esm5/internal/observable/merge.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_isScheduler();
    init_mergeAll();
    init_fromArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/never.js
function never() {
  return NEVER;
}
var NEVER;
var init_never = __esm({
  "node_modules/rxjs/_esm5/internal/observable/never.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_noop();
    NEVER = /* @__PURE__ */ new Observable(noop3);
  }
});

// node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js
function onErrorResumeNext() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 0) {
    return EMPTY;
  }
  var first2 = sources[0], remainder = sources.slice(1);
  if (sources.length === 1 && isArray3(first2)) {
    return onErrorResumeNext.apply(void 0, first2);
  }
  return new Observable(function(subscriber) {
    var subNext = function() {
      return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber));
    };
    return from3(first2).subscribe({
      next: function(value) {
        subscriber.next(value);
      },
      error: subNext,
      complete: subNext
    });
  });
}
var init_onErrorResumeNext = __esm({
  "node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_from();
    init_isArray();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/pairs.js
function pairs(obj, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      var keys2 = Object.keys(obj);
      for (var i5 = 0; i5 < keys2.length && !subscriber.closed; i5++) {
        var key = keys2[i5];
        if (obj.hasOwnProperty(key)) {
          subscriber.next([key, obj[key]]);
        }
      }
      subscriber.complete();
    });
  } else {
    return new Observable(function(subscriber) {
      var keys2 = Object.keys(obj);
      var subscription = new Subscription();
      subscription.add(scheduler.schedule(dispatch6, 0, { keys: keys2, index: 0, subscriber, subscription, obj }));
      return subscription;
    });
  }
}
function dispatch6(state) {
  var keys2 = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
  if (!subscriber.closed) {
    if (index < keys2.length) {
      var key = keys2[index];
      subscriber.next([key, obj[key]]);
      subscription.add(this.schedule({ keys: keys2, index: index + 1, subscriber, subscription, obj }));
    } else {
      subscriber.complete();
    }
  }
}
var init_pairs = __esm({
  "node_modules/rxjs/_esm5/internal/observable/pairs.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/util/not.js
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
var init_not = __esm({
  "node_modules/rxjs/_esm5/internal/util/not.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/rxjs/_esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator, FilterSubscriber;
var init_filter = __esm({
  "node_modules/rxjs/_esm5/internal/operators/filter.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    FilterOperator = /* @__PURE__ */ function() {
      function FilterOperator2(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
      }
      FilterOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
      };
      return FilterOperator2;
    }();
    FilterSubscriber = /* @__PURE__ */ function(_super) {
      __extends(FilterSubscriber2, _super);
      function FilterSubscriber2(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
      }
      FilterSubscriber2.prototype._next = function(value) {
        var result;
        try {
          result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.destination.next(value);
        }
      };
      return FilterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/partition.js
function partition(source, predicate, thisArg) {
  return [
    filter(predicate, thisArg)(new Observable(subscribeTo(source))),
    filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))
  ];
}
var init_partition = __esm({
  "node_modules/rxjs/_esm5/internal/observable/partition.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_not();
    init_subscribeTo();
    init_filter();
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/race.js
function race() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  if (observables.length === 1) {
    if (isArray3(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator, RaceSubscriber;
var init_race = __esm({
  "node_modules/rxjs/_esm5/internal/observable/race.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_isArray();
    init_fromArray();
    init_OuterSubscriber();
    init_subscribeToResult();
    RaceOperator = /* @__PURE__ */ function() {
      function RaceOperator2() {
      }
      RaceOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
      };
      return RaceOperator2;
    }();
    RaceSubscriber = /* @__PURE__ */ function(_super) {
      __extends(RaceSubscriber2, _super);
      function RaceSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
      }
      RaceSubscriber2.prototype._next = function(observable2) {
        this.observables.push(observable2);
      };
      RaceSubscriber2.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
          this.destination.complete();
        } else {
          for (var i5 = 0; i5 < len && !this.hasFirst; i5++) {
            var observable2 = observables[i5];
            var subscription = subscribeToResult(this, observable2, void 0, i5);
            if (this.subscriptions) {
              this.subscriptions.push(subscription);
            }
            this.add(subscription);
          }
          this.observables = null;
        }
      };
      RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        if (!this.hasFirst) {
          this.hasFirst = true;
          for (var i5 = 0; i5 < this.subscriptions.length; i5++) {
            if (i5 !== outerIndex) {
              var subscription = this.subscriptions[i5];
              subscription.unsubscribe();
              this.remove(subscription);
            }
          }
          this.subscriptions = null;
        }
        this.destination.next(innerValue);
      };
      return RaceSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/range.js
function range(start, count2, scheduler) {
  if (start === void 0) {
    start = 0;
  }
  return new Observable(function(subscriber) {
    if (count2 === void 0) {
      count2 = start;
      start = 0;
    }
    var index = 0;
    var current = start;
    if (scheduler) {
      return scheduler.schedule(dispatch7, 0, {
        index,
        count: count2,
        start,
        subscriber
      });
    } else {
      do {
        if (index++ >= count2) {
          subscriber.complete();
          break;
        }
        subscriber.next(current++);
        if (subscriber.closed) {
          break;
        }
      } while (true);
    }
    return void 0;
  });
}
function dispatch7(state) {
  var start = state.start, index = state.index, count2 = state.count, subscriber = state.subscriber;
  if (index >= count2) {
    subscriber.complete();
    return;
  }
  subscriber.next(start);
  if (subscriber.closed) {
    return;
  }
  state.index = index + 1;
  state.start = start + 1;
  this.schedule(state);
}
var init_range = __esm({
  "node_modules/rxjs/_esm5/internal/observable/range.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/timer.js
function timer(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!isScheduler(scheduler)) {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch8, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch8(state) {
  var index = state.index, period = state.period, subscriber = state.subscriber;
  subscriber.next(index);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state.index = index + 1;
  this.schedule(state, period);
}
var init_timer = __esm({
  "node_modules/rxjs/_esm5/internal/observable/timer.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_async();
    init_isNumeric();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/using.js
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource;
    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var result;
    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = result ? from3(result) : EMPTY;
    var subscription = source.subscribe(subscriber);
    return function() {
      subscription.unsubscribe();
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
var init_using = __esm({
  "node_modules/rxjs/_esm5/internal/observable/using.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_from();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/zip.js
function zip() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === "function") {
    observables.pop();
  }
  return fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator, ZipSubscriber, StaticIterator, StaticArrayIterator, ZipBufferIterator;
var init_zip = __esm({
  "node_modules/rxjs/_esm5/internal/observable/zip.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_fromArray();
    init_isArray();
    init_Subscriber();
    init_iterator();
    init_innerSubscribe();
    ZipOperator = /* @__PURE__ */ function() {
      function ZipOperator2(resultSelector) {
        this.resultSelector = resultSelector;
      }
      ZipOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
      };
      return ZipOperator2;
    }();
    ZipSubscriber = /* @__PURE__ */ function(_super) {
      __extends(ZipSubscriber2, _super);
      function ZipSubscriber2(destination, resultSelector, values) {
        if (values === void 0) {
          values = /* @__PURE__ */ Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
        return _this;
      }
      ZipSubscriber2.prototype._next = function(value) {
        var iterators = this.iterators;
        if (isArray3(value)) {
          iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator] === "function") {
          iterators.push(new StaticIterator(value[iterator]()));
        } else {
          iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
      };
      ZipSubscriber2.prototype._complete = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
          this.destination.complete();
          return;
        }
        this.active = len;
        for (var i5 = 0; i5 < len; i5++) {
          var iterator2 = iterators[i5];
          if (iterator2.stillUnsubscribed) {
            var destination = this.destination;
            destination.add(iterator2.subscribe());
          } else {
            this.active--;
          }
        }
      };
      ZipSubscriber2.prototype.notifyInactive = function() {
        this.active--;
        if (this.active === 0) {
          this.destination.complete();
        }
      };
      ZipSubscriber2.prototype.checkIterators = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i5 = 0; i5 < len; i5++) {
          var iterator2 = iterators[i5];
          if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
            return;
          }
        }
        var shouldComplete = false;
        var args = [];
        for (var i5 = 0; i5 < len; i5++) {
          var iterator2 = iterators[i5];
          var result = iterator2.next();
          if (iterator2.hasCompleted()) {
            shouldComplete = true;
          }
          if (result.done) {
            destination.complete();
            return;
          }
          args.push(result.value);
        }
        if (this.resultSelector) {
          this._tryresultSelector(args);
        } else {
          destination.next(args);
        }
        if (shouldComplete) {
          destination.complete();
        }
      };
      ZipSubscriber2.prototype._tryresultSelector = function(args) {
        var result;
        try {
          result = this.resultSelector.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return ZipSubscriber2;
    }(Subscriber);
    StaticIterator = /* @__PURE__ */ function() {
      function StaticIterator2(iterator2) {
        this.iterator = iterator2;
        this.nextResult = iterator2.next();
      }
      StaticIterator2.prototype.hasValue = function() {
        return true;
      };
      StaticIterator2.prototype.next = function() {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
      };
      StaticIterator2.prototype.hasCompleted = function() {
        var nextResult = this.nextResult;
        return Boolean(nextResult && nextResult.done);
      };
      return StaticIterator2;
    }();
    StaticArrayIterator = /* @__PURE__ */ function() {
      function StaticArrayIterator2(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
      }
      StaticArrayIterator2.prototype[iterator] = function() {
        return this;
      };
      StaticArrayIterator2.prototype.next = function(value) {
        var i5 = this.index++;
        var array = this.array;
        return i5 < this.length ? { value: array[i5], done: false } : { value: null, done: true };
      };
      StaticArrayIterator2.prototype.hasValue = function() {
        return this.array.length > this.index;
      };
      StaticArrayIterator2.prototype.hasCompleted = function() {
        return this.array.length === this.index;
      };
      return StaticArrayIterator2;
    }();
    ZipBufferIterator = /* @__PURE__ */ function(_super) {
      __extends(ZipBufferIterator2, _super);
      function ZipBufferIterator2(destination, parent, observable2) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable2;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
      }
      ZipBufferIterator2.prototype[iterator] = function() {
        return this;
      };
      ZipBufferIterator2.prototype.next = function() {
        var buffer2 = this.buffer;
        if (buffer2.length === 0 && this.isComplete) {
          return { value: null, done: true };
        } else {
          return { value: buffer2.shift(), done: false };
        }
      };
      ZipBufferIterator2.prototype.hasValue = function() {
        return this.buffer.length > 0;
      };
      ZipBufferIterator2.prototype.hasCompleted = function() {
        return this.buffer.length === 0 && this.isComplete;
      };
      ZipBufferIterator2.prototype.notifyComplete = function() {
        if (this.buffer.length > 0) {
          this.isComplete = true;
          this.parent.notifyInactive();
        } else {
          this.destination.complete();
        }
      };
      ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
      };
      ZipBufferIterator2.prototype.subscribe = function() {
        return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
      };
      return ZipBufferIterator2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/index.js
var esm5_exports = {};
__export(esm5_exports, {
  ArgumentOutOfRangeError: () => ArgumentOutOfRangeError,
  AsyncSubject: () => AsyncSubject,
  BehaviorSubject: () => BehaviorSubject,
  ConnectableObservable: () => ConnectableObservable,
  EMPTY: () => EMPTY,
  EmptyError: () => EmptyError,
  GroupedObservable: () => GroupedObservable,
  NEVER: () => NEVER,
  Notification: () => Notification,
  NotificationKind: () => NotificationKind,
  ObjectUnsubscribedError: () => ObjectUnsubscribedError,
  Observable: () => Observable,
  ReplaySubject: () => ReplaySubject,
  Scheduler: () => Scheduler,
  Subject: () => Subject,
  Subscriber: () => Subscriber,
  Subscription: () => Subscription,
  TimeoutError: () => TimeoutError,
  UnsubscriptionError: () => UnsubscriptionError,
  VirtualAction: () => VirtualAction,
  VirtualTimeScheduler: () => VirtualTimeScheduler,
  animationFrame: () => animationFrame,
  animationFrameScheduler: () => animationFrameScheduler,
  asap: () => asap,
  asapScheduler: () => asapScheduler,
  async: () => async,
  asyncScheduler: () => asyncScheduler,
  bindCallback: () => bindCallback,
  bindNodeCallback: () => bindNodeCallback,
  combineLatest: () => combineLatest,
  concat: () => concat3,
  config: () => config3,
  defer: () => defer,
  empty: () => empty2,
  forkJoin: () => forkJoin,
  from: () => from3,
  fromEvent: () => fromEvent,
  fromEventPattern: () => fromEventPattern,
  generate: () => generate,
  identity: () => identity,
  iif: () => iif,
  interval: () => interval,
  isObservable: () => isObservable,
  merge: () => merge,
  never: () => never,
  noop: () => noop3,
  observable: () => observable,
  of: () => of,
  onErrorResumeNext: () => onErrorResumeNext,
  pairs: () => pairs,
  partition: () => partition,
  pipe: () => pipe,
  queue: () => queue3,
  queueScheduler: () => queueScheduler,
  race: () => race,
  range: () => range,
  scheduled: () => scheduled,
  throwError: () => throwError,
  timer: () => timer,
  using: () => using,
  zip: () => zip
});
var init_esm5 = __esm({
  "node_modules/rxjs/_esm5/index.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Observable();
    init_ConnectableObservable();
    init_groupBy();
    init_observable();
    init_Subject();
    init_BehaviorSubject();
    init_ReplaySubject();
    init_AsyncSubject();
    init_asap();
    init_async();
    init_queue();
    init_animationFrame();
    init_VirtualTimeScheduler();
    init_Scheduler();
    init_Subscription();
    init_Subscriber();
    init_Notification();
    init_pipe();
    init_noop();
    init_identity();
    init_isObservable();
    init_ArgumentOutOfRangeError();
    init_EmptyError();
    init_ObjectUnsubscribedError();
    init_UnsubscriptionError();
    init_TimeoutError();
    init_bindCallback();
    init_bindNodeCallback();
    init_combineLatest();
    init_concat();
    init_defer();
    init_empty();
    init_forkJoin();
    init_from();
    init_fromEvent();
    init_fromEventPattern();
    init_generate();
    init_iif();
    init_interval();
    init_merge();
    init_never();
    init_of();
    init_onErrorResumeNext();
    init_pairs();
    init_partition();
    init_race();
    init_range();
    init_throwError();
    init_timer();
    init_using();
    init_zip();
    init_scheduled();
    init_empty();
    init_never();
    init_config();
  }
});

// node_modules/rxjs/_esm5/internal/operators/audit.js
function audit(durationSelector) {
  return function auditOperatorFunction(source) {
    return source.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator, AuditSubscriber;
var init_audit = __esm({
  "node_modules/rxjs/_esm5/internal/operators/audit.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    AuditOperator = /* @__PURE__ */ function() {
      function AuditOperator2(durationSelector) {
        this.durationSelector = durationSelector;
      }
      AuditOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
      };
      return AuditOperator2;
    }();
    AuditSubscriber = /* @__PURE__ */ function(_super) {
      __extends(AuditSubscriber2, _super);
      function AuditSubscriber2(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
      }
      AuditSubscriber2.prototype._next = function(value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
          var duration = void 0;
          try {
            var durationSelector = this.durationSelector;
            duration = durationSelector(value);
          } catch (err) {
            return this.destination.error(err);
          }
          var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
          if (!innerSubscription || innerSubscription.closed) {
            this.clearThrottle();
          } else {
            this.add(this.throttled = innerSubscription);
          }
        }
      };
      AuditSubscriber2.prototype.clearThrottle = function() {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
          this.remove(throttled);
          this.throttled = void 0;
          throttled.unsubscribe();
        }
        if (hasValue) {
          this.value = void 0;
          this.hasValue = false;
          this.destination.next(value);
        }
      };
      AuditSubscriber2.prototype.notifyNext = function() {
        this.clearThrottle();
      };
      AuditSubscriber2.prototype.notifyComplete = function() {
        this.clearThrottle();
      };
      return AuditSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/auditTime.js
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return audit(function() {
    return timer(duration, scheduler);
  });
}
var init_auditTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/auditTime.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_async();
    init_audit();
    init_timer();
  }
});

// node_modules/rxjs/_esm5/internal/operators/buffer.js
function buffer(closingNotifier) {
  return function bufferOperatorFunction(source) {
    return source.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator, BufferSubscriber;
var init_buffer3 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/buffer.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    BufferOperator = /* @__PURE__ */ function() {
      function BufferOperator2(closingNotifier) {
        this.closingNotifier = closingNotifier;
      }
      BufferOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
      };
      return BufferOperator2;
    }();
    BufferSubscriber = /* @__PURE__ */ function(_super) {
      __extends(BufferSubscriber2, _super);
      function BufferSubscriber2(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
        return _this;
      }
      BufferSubscriber2.prototype._next = function(value) {
        this.buffer.push(value);
      };
      BufferSubscriber2.prototype.notifyNext = function() {
        var buffer2 = this.buffer;
        this.buffer = [];
        this.destination.next(buffer2);
      };
      return BufferSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferCount.js
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  return function bufferCountOperatorFunction(source) {
    return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator, BufferCountSubscriber, BufferSkipCountSubscriber;
var init_bufferCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferCount.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    BufferCountOperator = /* @__PURE__ */ function() {
      function BufferCountOperator2(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
          this.subscriberClass = BufferCountSubscriber;
        } else {
          this.subscriberClass = BufferSkipCountSubscriber;
        }
      }
      BufferCountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
      };
      return BufferCountOperator2;
    }();
    BufferCountSubscriber = /* @__PURE__ */ function(_super) {
      __extends(BufferCountSubscriber2, _super);
      function BufferCountSubscriber2(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
      }
      BufferCountSubscriber2.prototype._next = function(value) {
        var buffer2 = this.buffer;
        buffer2.push(value);
        if (buffer2.length == this.bufferSize) {
          this.destination.next(buffer2);
          this.buffer = [];
        }
      };
      BufferCountSubscriber2.prototype._complete = function() {
        var buffer2 = this.buffer;
        if (buffer2.length > 0) {
          this.destination.next(buffer2);
        }
        _super.prototype._complete.call(this);
      };
      return BufferCountSubscriber2;
    }(Subscriber);
    BufferSkipCountSubscriber = /* @__PURE__ */ function(_super) {
      __extends(BufferSkipCountSubscriber2, _super);
      function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
      }
      BufferSkipCountSubscriber2.prototype._next = function(value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count2 = _a.count;
        this.count++;
        if (count2 % startBufferEvery === 0) {
          buffers.push([]);
        }
        for (var i5 = buffers.length; i5--; ) {
          var buffer2 = buffers[i5];
          buffer2.push(value);
          if (buffer2.length === bufferSize) {
            buffers.splice(i5, 1);
            this.destination.next(buffer2);
          }
        }
      };
      BufferSkipCountSubscriber2.prototype._complete = function() {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
          var buffer2 = buffers.shift();
          if (buffer2.length > 0) {
            destination.next(buffer2);
          }
        }
        _super.prototype._complete.call(this);
      };
      return BufferSkipCountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferTime.js
function bufferTime(bufferTimeSpan) {
  var length = arguments.length;
  var scheduler = async;
  if (isScheduler(arguments[arguments.length - 1])) {
    scheduler = arguments[arguments.length - 1];
    length--;
  }
  var bufferCreationInterval = null;
  if (length >= 2) {
    bufferCreationInterval = arguments[1];
  }
  var maxBufferSize = Number.POSITIVE_INFINITY;
  if (length >= 3) {
    maxBufferSize = arguments[2];
  }
  return function bufferTimeOperatorFunction(source) {
    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}
function dispatchBufferTimeSpanOnly(state) {
  var subscriber = state.subscriber;
  var prevContext = state.context;
  if (prevContext) {
    subscriber.closeContext(prevContext);
  }
  if (!subscriber.closed) {
    state.context = subscriber.openContext();
    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
  }
}
function dispatchBufferCreation(state) {
  var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
  var context = subscriber.openContext();
  var action = this;
  if (!subscriber.closed) {
    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));
    action.schedule(state, bufferCreationInterval);
  }
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context = arg.context;
  subscriber.closeContext(context);
}
var BufferTimeOperator, Context, BufferTimeSubscriber;
var init_bufferTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferTime.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_async();
    init_Subscriber();
    init_isScheduler();
    BufferTimeOperator = /* @__PURE__ */ function() {
      function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
      }
      BufferTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
      };
      return BufferTimeOperator2;
    }();
    Context = /* @__PURE__ */ function() {
      function Context2() {
        this.buffer = [];
      }
      return Context2;
    }();
    BufferTimeSubscriber = /* @__PURE__ */ function(_super) {
      __extends(BufferTimeSubscriber2, _super);
      function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
          var timeSpanOnlyState = { subscriber: _this, context, bufferTimeSpan };
          _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        } else {
          var closeState = { subscriber: _this, context };
          var creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler };
          _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
          _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
      }
      BufferTimeSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i5 = 0; i5 < len; i5++) {
          var context_1 = contexts[i5];
          var buffer2 = context_1.buffer;
          buffer2.push(value);
          if (buffer2.length == this.maxBufferSize) {
            filledBufferContext = context_1;
          }
        }
        if (filledBufferContext) {
          this.onBufferFull(filledBufferContext);
        }
      };
      BufferTimeSubscriber2.prototype._error = function(err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
      };
      BufferTimeSubscriber2.prototype._complete = function() {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
          var context_2 = contexts.shift();
          destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
      };
      BufferTimeSubscriber2.prototype._unsubscribe = function() {
        this.contexts = null;
      };
      BufferTimeSubscriber2.prototype.onBufferFull = function(context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
          context = this.openContext();
          var bufferTimeSpan = this.bufferTimeSpan;
          var timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };
          this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
      };
      BufferTimeSubscriber2.prototype.openContext = function() {
        var context = new Context();
        this.contexts.push(context);
        return context;
      };
      BufferTimeSubscriber2.prototype.closeContext = function(context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
          contexts.splice(contexts.indexOf(context), 1);
        }
      };
      return BufferTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferToggle.js
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source) {
    return source.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator, BufferToggleSubscriber;
var init_bufferToggle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferToggle.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscription();
    init_subscribeToResult();
    init_OuterSubscriber();
    BufferToggleOperator = /* @__PURE__ */ function() {
      function BufferToggleOperator2(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }
      BufferToggleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
      };
      return BufferToggleOperator2;
    }();
    BufferToggleSubscriber = /* @__PURE__ */ function(_super) {
      __extends(BufferToggleSubscriber2, _super);
      function BufferToggleSubscriber2(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult(_this, openings));
        return _this;
      }
      BufferToggleSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i5 = 0; i5 < len; i5++) {
          contexts[i5].buffer.push(value);
        }
      };
      BufferToggleSubscriber2.prototype._error = function(err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
          var context_1 = contexts.shift();
          context_1.subscription.unsubscribe();
          context_1.buffer = null;
          context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
      };
      BufferToggleSubscriber2.prototype._complete = function() {
        var contexts = this.contexts;
        while (contexts.length > 0) {
          var context_2 = contexts.shift();
          this.destination.next(context_2.buffer);
          context_2.subscription.unsubscribe();
          context_2.buffer = null;
          context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
      };
      BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
      };
      BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.closeBuffer(innerSub.context);
      };
      BufferToggleSubscriber2.prototype.openBuffer = function(value) {
        try {
          var closingSelector = this.closingSelector;
          var closingNotifier = closingSelector.call(this, value);
          if (closingNotifier) {
            this.trySubscribe(closingNotifier);
          }
        } catch (err) {
          this._error(err);
        }
      };
      BufferToggleSubscriber2.prototype.closeBuffer = function(context) {
        var contexts = this.contexts;
        if (contexts && context) {
          var buffer2 = context.buffer, subscription = context.subscription;
          this.destination.next(buffer2);
          contexts.splice(contexts.indexOf(context), 1);
          this.remove(subscription);
          subscription.unsubscribe();
        }
      };
      BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
        var contexts = this.contexts;
        var buffer2 = [];
        var subscription = new Subscription();
        var context = { buffer: buffer2, subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
          this.closeBuffer(context);
        } else {
          innerSubscription.context = context;
          this.add(innerSubscription);
          subscription.add(innerSubscription);
        }
      };
      return BufferToggleSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferWhen.js
function bufferWhen(closingSelector) {
  return function(source) {
    return source.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator, BufferWhenSubscriber;
var init_bufferWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferWhen.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscription();
    init_innerSubscribe();
    BufferWhenOperator = /* @__PURE__ */ function() {
      function BufferWhenOperator2(closingSelector) {
        this.closingSelector = closingSelector;
      }
      BufferWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
      };
      return BufferWhenOperator2;
    }();
    BufferWhenSubscriber = /* @__PURE__ */ function(_super) {
      __extends(BufferWhenSubscriber2, _super);
      function BufferWhenSubscriber2(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
      }
      BufferWhenSubscriber2.prototype._next = function(value) {
        this.buffer.push(value);
      };
      BufferWhenSubscriber2.prototype._complete = function() {
        var buffer2 = this.buffer;
        if (buffer2) {
          this.destination.next(buffer2);
        }
        _super.prototype._complete.call(this);
      };
      BufferWhenSubscriber2.prototype._unsubscribe = function() {
        this.buffer = void 0;
        this.subscribing = false;
      };
      BufferWhenSubscriber2.prototype.notifyNext = function() {
        this.openBuffer();
      };
      BufferWhenSubscriber2.prototype.notifyComplete = function() {
        if (this.subscribing) {
          this.complete();
        } else {
          this.openBuffer();
        }
      };
      BufferWhenSubscriber2.prototype.openBuffer = function() {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
          this.remove(closingSubscription);
          closingSubscription.unsubscribe();
        }
        var buffer2 = this.buffer;
        if (this.buffer) {
          this.destination.next(buffer2);
        }
        this.buffer = [];
        var closingNotifier;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector();
        } catch (err) {
          return this.error(err);
        }
        closingSubscription = new Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
        this.subscribing = false;
      };
      return BufferWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/catchError.js
function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator, CatchSubscriber;
var init_catchError = __esm({
  "node_modules/rxjs/_esm5/internal/operators/catchError.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    CatchOperator = /* @__PURE__ */ function() {
      function CatchOperator2(selector) {
        this.selector = selector;
      }
      CatchOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
      };
      return CatchOperator2;
    }();
    CatchSubscriber = /* @__PURE__ */ function(_super) {
      __extends(CatchSubscriber2, _super);
      function CatchSubscriber2(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
      }
      CatchSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var result = void 0;
          try {
            result = this.selector(err, this.caught);
          } catch (err2) {
            _super.prototype.error.call(this, err2);
            return;
          }
          this._unsubscribeAndRecycle();
          var innerSubscriber = new SimpleInnerSubscriber(this);
          this.add(innerSubscriber);
          var innerSubscription = innerSubscribe(result, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
            this.add(innerSubscription);
          }
        }
      };
      return CatchSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/combineAll.js
function combineAll(project) {
  return function(source) {
    return source.lift(new CombineLatestOperator(project));
  };
}
var init_combineAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/combineAll.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_combineLatest();
  }
});

// node_modules/rxjs/_esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var project = null;
  if (typeof observables[observables.length - 1] === "function") {
    project = observables.pop();
  }
  if (observables.length === 1 && isArray3(observables[0])) {
    observables = observables[0].slice();
  }
  return function(source) {
    return source.lift.call(from3([source].concat(observables)), new CombineLatestOperator(project));
  };
}
var init_combineLatest2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/combineLatest.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_isArray();
    init_combineLatest();
    init_from();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concat.js
function concat4() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(concat3.apply(void 0, [source].concat(observables)));
  };
}
var init_concat2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concat.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_concat();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
var init_concatMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatMap.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_mergeMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatMapTo.js
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
var init_concatMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatMapTo.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_concatMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/count.js
function count(predicate) {
  return function(source) {
    return source.lift(new CountOperator(predicate, source));
  };
}
var CountOperator, CountSubscriber;
var init_count = __esm({
  "node_modules/rxjs/_esm5/internal/operators/count.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    CountOperator = /* @__PURE__ */ function() {
      function CountOperator2(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }
      CountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
      };
      return CountOperator2;
    }();
    CountSubscriber = /* @__PURE__ */ function(_super) {
      __extends(CountSubscriber2, _super);
      function CountSubscriber2(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
      }
      CountSubscriber2.prototype._next = function(value) {
        if (this.predicate) {
          this._tryPredicate(value);
        } else {
          this.count++;
        }
      };
      CountSubscriber2.prototype._tryPredicate = function(value) {
        var result;
        try {
          result = this.predicate(value, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.count++;
        }
      };
      CountSubscriber2.prototype._complete = function() {
        this.destination.next(this.count);
        this.destination.complete();
      };
      return CountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/debounce.js
function debounce(durationSelector) {
  return function(source) {
    return source.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator, DebounceSubscriber;
var init_debounce = __esm({
  "node_modules/rxjs/_esm5/internal/operators/debounce.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    DebounceOperator = /* @__PURE__ */ function() {
      function DebounceOperator2(durationSelector) {
        this.durationSelector = durationSelector;
      }
      DebounceOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
      };
      return DebounceOperator2;
    }();
    DebounceSubscriber = /* @__PURE__ */ function(_super) {
      __extends(DebounceSubscriber2, _super);
      function DebounceSubscriber2(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
      }
      DebounceSubscriber2.prototype._next = function(value) {
        try {
          var result = this.durationSelector.call(this, value);
          if (result) {
            this._tryNext(value, result);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      DebounceSubscriber2.prototype._complete = function() {
        this.emitValue();
        this.destination.complete();
      };
      DebounceSubscriber2.prototype._tryNext = function(value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
          subscription.unsubscribe();
          this.remove(subscription);
        }
        subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
        if (subscription && !subscription.closed) {
          this.add(this.durationSubscription = subscription);
        }
      };
      DebounceSubscriber2.prototype.notifyNext = function() {
        this.emitValue();
      };
      DebounceSubscriber2.prototype.notifyComplete = function() {
        this.emitValue();
      };
      DebounceSubscriber2.prototype.emitValue = function() {
        if (this.hasValue) {
          var value = this.value;
          var subscription = this.durationSubscription;
          if (subscription) {
            this.durationSubscription = void 0;
            subscription.unsubscribe();
            this.remove(subscription);
          }
          this.value = void 0;
          this.hasValue = false;
          _super.prototype._next.call(this, value);
        }
      };
      return DebounceSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}
function dispatchNext3(subscriber) {
  subscriber.debouncedNext();
}
var DebounceTimeOperator, DebounceTimeSubscriber;
var init_debounceTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/debounceTime.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_async();
    DebounceTimeOperator = /* @__PURE__ */ function() {
      function DebounceTimeOperator2(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
      }
      DebounceTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
      };
      return DebounceTimeOperator2;
    }();
    DebounceTimeSubscriber = /* @__PURE__ */ function(_super) {
      __extends(DebounceTimeSubscriber2, _super);
      function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
      }
      DebounceTimeSubscriber2.prototype._next = function(value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext3, this.dueTime, this));
      };
      DebounceTimeSubscriber2.prototype._complete = function() {
        this.debouncedNext();
        this.destination.complete();
      };
      DebounceTimeSubscriber2.prototype.debouncedNext = function() {
        this.clearDebounce();
        if (this.hasValue) {
          var lastValue = this.lastValue;
          this.lastValue = null;
          this.hasValue = false;
          this.destination.next(lastValue);
        }
      };
      DebounceTimeSubscriber2.prototype.clearDebounce = function() {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
          this.remove(debouncedSubscription);
          debouncedSubscription.unsubscribe();
          this.debouncedSubscription = null;
        }
      };
      return DebounceTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source) {
    return source.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator, DefaultIfEmptySubscriber;
var init_defaultIfEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    DefaultIfEmptyOperator = /* @__PURE__ */ function() {
      function DefaultIfEmptyOperator2(defaultValue) {
        this.defaultValue = defaultValue;
      }
      DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
      };
      return DefaultIfEmptyOperator2;
    }();
    DefaultIfEmptySubscriber = /* @__PURE__ */ function(_super) {
      __extends(DefaultIfEmptySubscriber2, _super);
      function DefaultIfEmptySubscriber2(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
      }
      DefaultIfEmptySubscriber2.prototype._next = function(value) {
        this.isEmpty = false;
        this.destination.next(value);
      };
      DefaultIfEmptySubscriber2.prototype._complete = function() {
        if (this.isEmpty) {
          this.destination.next(this.defaultValue);
        }
        this.destination.complete();
      };
      return DefaultIfEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/isDate.js
function isDate2(value) {
  return value instanceof Date && !isNaN(+value);
}
var init_isDate = __esm({
  "node_modules/rxjs/_esm5/internal/util/isDate.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/rxjs/_esm5/internal/operators/delay.js
function delay(delay2, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  var absoluteDelay = isDate2(delay2);
  var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
  return function(source) {
    return source.lift(new DelayOperator(delayFor, scheduler));
  };
}
var DelayOperator, DelaySubscriber, DelayMessage;
var init_delay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/delay.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_async();
    init_isDate();
    init_Subscriber();
    init_Notification();
    DelayOperator = /* @__PURE__ */ function() {
      function DelayOperator2(delay2, scheduler) {
        this.delay = delay2;
        this.scheduler = scheduler;
      }
      DelayOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
      };
      return DelayOperator2;
    }();
    DelaySubscriber = /* @__PURE__ */ function(_super) {
      __extends(DelaySubscriber2, _super);
      function DelaySubscriber2(destination, delay2, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay2;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
      }
      DelaySubscriber2.dispatch = function(state) {
        var source = state.source;
        var queue4 = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue4.length > 0 && queue4[0].time - scheduler.now() <= 0) {
          queue4.shift().notification.observe(destination);
        }
        if (queue4.length > 0) {
          var delay_1 = Math.max(0, queue4[0].time - scheduler.now());
          this.schedule(state, delay_1);
        } else {
          this.unsubscribe();
          source.active = false;
        }
      };
      DelaySubscriber2.prototype._schedule = function(scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
          source: this,
          destination: this.destination,
          scheduler
        }));
      };
      DelaySubscriber2.prototype.scheduleNotification = function(notification) {
        if (this.errored === true) {
          return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
          this._schedule(scheduler);
        }
      };
      DelaySubscriber2.prototype._next = function(value) {
        this.scheduleNotification(Notification.createNext(value));
      };
      DelaySubscriber2.prototype._error = function(err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
      };
      DelaySubscriber2.prototype._complete = function() {
        this.scheduleNotification(Notification.createComplete());
        this.unsubscribe();
      };
      return DelaySubscriber2;
    }(Subscriber);
    DelayMessage = /* @__PURE__ */ function() {
      function DelayMessage2(time, notification) {
        this.time = time;
        this.notification = notification;
      }
      return DelayMessage2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/delayWhen.js
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  return function(source) {
    return source.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator, DelayWhenSubscriber, SubscriptionDelayObservable, SubscriptionDelaySubscriber;
var init_delayWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/delayWhen.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_Observable();
    init_OuterSubscriber();
    init_subscribeToResult();
    DelayWhenOperator = /* @__PURE__ */ function() {
      function DelayWhenOperator2(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
      }
      DelayWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
      };
      return DelayWhenOperator2;
    }();
    DelayWhenSubscriber = /* @__PURE__ */ function(_super) {
      __extends(DelayWhenSubscriber2, _super);
      function DelayWhenSubscriber2(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
      }
      DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
      };
      DelayWhenSubscriber2.prototype.notifyError = function(error2, innerSub) {
        this._error(error2);
      };
      DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
          this.destination.next(value);
        }
        this.tryComplete();
      };
      DelayWhenSubscriber2.prototype._next = function(value) {
        var index = this.index++;
        try {
          var delayNotifier = this.delayDurationSelector(value, index);
          if (delayNotifier) {
            this.tryDelay(delayNotifier, value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      DelayWhenSubscriber2.prototype._complete = function() {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
      };
      DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
          this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
      };
      DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
        var notifierSubscription = subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
          var destination = this.destination;
          destination.add(notifierSubscription);
          this.delayNotifierSubscriptions.push(notifierSubscription);
        }
      };
      DelayWhenSubscriber2.prototype.tryComplete = function() {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
          this.destination.complete();
        }
      };
      return DelayWhenSubscriber2;
    }(OuterSubscriber);
    SubscriptionDelayObservable = /* @__PURE__ */ function(_super) {
      __extends(SubscriptionDelayObservable2, _super);
      function SubscriptionDelayObservable2(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
      }
      SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
      };
      return SubscriptionDelayObservable2;
    }(Observable);
    SubscriptionDelaySubscriber = /* @__PURE__ */ function(_super) {
      __extends(SubscriptionDelaySubscriber2, _super);
      function SubscriptionDelaySubscriber2(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
      }
      SubscriptionDelaySubscriber2.prototype._next = function(unused) {
        this.subscribeToSource();
      };
      SubscriptionDelaySubscriber2.prototype._error = function(err) {
        this.unsubscribe();
        this.parent.error(err);
      };
      SubscriptionDelaySubscriber2.prototype._complete = function() {
        this.unsubscribe();
        this.subscribeToSource();
      };
      SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
        if (!this.sourceSubscribed) {
          this.sourceSubscribed = true;
          this.unsubscribe();
          this.source.subscribe(this.parent);
        }
      };
      return SubscriptionDelaySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/dematerialize.js
function dematerialize() {
  return function dematerializeOperatorFunction(source) {
    return source.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator, DeMaterializeSubscriber;
var init_dematerialize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/dematerialize.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    DeMaterializeOperator = /* @__PURE__ */ function() {
      function DeMaterializeOperator2() {
      }
      DeMaterializeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
      };
      return DeMaterializeOperator2;
    }();
    DeMaterializeSubscriber = /* @__PURE__ */ function(_super) {
      __extends(DeMaterializeSubscriber2, _super);
      function DeMaterializeSubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      DeMaterializeSubscriber2.prototype._next = function(value) {
        value.observe(this.destination);
      };
      return DeMaterializeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinct.js
function distinct(keySelector, flushes) {
  return function(source) {
    return source.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator, DistinctSubscriber;
var init_distinct = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinct.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    DistinctOperator = /* @__PURE__ */ function() {
      function DistinctOperator2(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
      }
      DistinctOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
      };
      return DistinctOperator2;
    }();
    DistinctSubscriber = /* @__PURE__ */ function(_super) {
      __extends(DistinctSubscriber2, _super);
      function DistinctSubscriber2(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = /* @__PURE__ */ new Set();
        if (flushes) {
          _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
        }
        return _this;
      }
      DistinctSubscriber2.prototype.notifyNext = function() {
        this.values.clear();
      };
      DistinctSubscriber2.prototype.notifyError = function(error2) {
        this._error(error2);
      };
      DistinctSubscriber2.prototype._next = function(value) {
        if (this.keySelector) {
          this._useKeySelector(value);
        } else {
          this._finalizeNext(value, value);
        }
      };
      DistinctSubscriber2.prototype._useKeySelector = function(value) {
        var key;
        var destination = this.destination;
        try {
          key = this.keySelector(value);
        } catch (err) {
          destination.error(err);
          return;
        }
        this._finalizeNext(key, value);
      };
      DistinctSubscriber2.prototype._finalizeNext = function(key, value) {
        var values = this.values;
        if (!values.has(key)) {
          values.add(key);
          this.destination.next(value);
        }
      };
      return DistinctSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(compare6, keySelector) {
  return function(source) {
    return source.lift(new DistinctUntilChangedOperator(compare6, keySelector));
  };
}
var DistinctUntilChangedOperator, DistinctUntilChangedSubscriber;
var init_distinctUntilChanged = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    DistinctUntilChangedOperator = /* @__PURE__ */ function() {
      function DistinctUntilChangedOperator2(compare6, keySelector) {
        this.compare = compare6;
        this.keySelector = keySelector;
      }
      DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
      };
      return DistinctUntilChangedOperator2;
    }();
    DistinctUntilChangedSubscriber = /* @__PURE__ */ function(_super) {
      __extends(DistinctUntilChangedSubscriber2, _super);
      function DistinctUntilChangedSubscriber2(destination, compare6, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare6 === "function") {
          _this.compare = compare6;
        }
        return _this;
      }
      DistinctUntilChangedSubscriber2.prototype.compare = function(x5, y5) {
        return x5 === y5;
      };
      DistinctUntilChangedSubscriber2.prototype._next = function(value) {
        var key;
        try {
          var keySelector = this.keySelector;
          key = keySelector ? keySelector(value) : value;
        } catch (err) {
          return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
          try {
            var compare6 = this.compare;
            result = compare6(this.key, key);
          } catch (err) {
            return this.destination.error(err);
          }
        } else {
          this.hasKey = true;
        }
        if (!result) {
          this.key = key;
          this.destination.next(value);
        }
      };
      return DistinctUntilChangedSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js
function distinctUntilKeyChanged(key, compare6) {
  return distinctUntilChanged(function(x5, y5) {
    return compare6 ? compare6(x5[key], y5[key]) : x5[key] === y5[key];
  });
}
var init_distinctUntilKeyChanged = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_distinctUntilChanged();
  }
});

// node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source) {
    return source.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
function defaultErrorFactory() {
  return new EmptyError();
}
var ThrowIfEmptyOperator, ThrowIfEmptySubscriber;
var init_throwIfEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_EmptyError();
    init_Subscriber();
    ThrowIfEmptyOperator = /* @__PURE__ */ function() {
      function ThrowIfEmptyOperator2(errorFactory) {
        this.errorFactory = errorFactory;
      }
      ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
      };
      return ThrowIfEmptyOperator2;
    }();
    ThrowIfEmptySubscriber = /* @__PURE__ */ function(_super) {
      __extends(ThrowIfEmptySubscriber2, _super);
      function ThrowIfEmptySubscriber2(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
      }
      ThrowIfEmptySubscriber2.prototype._next = function(value) {
        this.hasValue = true;
        this.destination.next(value);
      };
      ThrowIfEmptySubscriber2.prototype._complete = function() {
        if (!this.hasValue) {
          var err = void 0;
          try {
            err = this.errorFactory();
          } catch (e5) {
            err = e5;
          }
          this.destination.error(err);
        } else {
          return this.destination.complete();
        }
      };
      return ThrowIfEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/take.js
function take(count2) {
  return function(source) {
    if (count2 === 0) {
      return empty2();
    } else {
      return source.lift(new TakeOperator(count2));
    }
  };
}
var TakeOperator, TakeSubscriber;
var init_take = __esm({
  "node_modules/rxjs/_esm5/internal/operators/take.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    init_empty();
    TakeOperator = /* @__PURE__ */ function() {
      function TakeOperator2(total) {
        this.total = total;
        if (this.total < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      TakeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
      };
      return TakeOperator2;
    }();
    TakeSubscriber = /* @__PURE__ */ function(_super) {
      __extends(TakeSubscriber2, _super);
      function TakeSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
      }
      TakeSubscriber2.prototype._next = function(value) {
        var total = this.total;
        var count2 = ++this.count;
        if (count2 <= total) {
          this.destination.next(value);
          if (count2 === total) {
            this.destination.complete();
            this.unsubscribe();
          }
        }
      };
      return TakeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/elementAt.js
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter(function(v5, i5) {
      return i5 === index;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
var init_elementAt = __esm({
  "node_modules/rxjs/_esm5/internal/operators/elementAt.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_ArgumentOutOfRangeError();
    init_filter();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_take();
  }
});

// node_modules/rxjs/_esm5/internal/operators/endWith.js
function endWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  return function(source) {
    return concat3(source, of.apply(void 0, array));
  };
}
var init_endWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/endWith.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_concat();
    init_of();
  }
});

// node_modules/rxjs/_esm5/internal/operators/every.js
function every(predicate, thisArg) {
  return function(source) {
    return source.lift(new EveryOperator(predicate, thisArg, source));
  };
}
var EveryOperator, EverySubscriber;
var init_every = __esm({
  "node_modules/rxjs/_esm5/internal/operators/every.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    EveryOperator = /* @__PURE__ */ function() {
      function EveryOperator2(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
      }
      EveryOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
      };
      return EveryOperator2;
    }();
    EverySubscriber = /* @__PURE__ */ function(_super) {
      __extends(EverySubscriber2, _super);
      function EverySubscriber2(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
      }
      EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
      };
      EverySubscriber2.prototype._next = function(value) {
        var result = false;
        try {
          result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (!result) {
          this.notifyComplete(false);
        }
      };
      EverySubscriber2.prototype._complete = function() {
        this.notifyComplete(true);
      };
      return EverySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/exhaust.js
function exhaust() {
  return function(source) {
    return source.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator, SwitchFirstSubscriber;
var init_exhaust = __esm({
  "node_modules/rxjs/_esm5/internal/operators/exhaust.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    SwitchFirstOperator = /* @__PURE__ */ function() {
      function SwitchFirstOperator2() {
      }
      SwitchFirstOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
      };
      return SwitchFirstOperator2;
    }();
    SwitchFirstSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SwitchFirstSubscriber2, _super);
      function SwitchFirstSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
      }
      SwitchFirstSubscriber2.prototype._next = function(value) {
        if (!this.hasSubscription) {
          this.hasSubscription = true;
          this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));
        }
      };
      SwitchFirstSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
          this.destination.complete();
        }
      };
      SwitchFirstSubscriber2.prototype.notifyComplete = function() {
        this.hasSubscription = false;
        if (this.hasCompleted) {
          this.destination.complete();
        }
      };
      return SwitchFirstSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a5, i5) {
        return from3(project(a5, i5)).pipe(map(function(b4, ii) {
          return resultSelector(a5, b4, i5, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator, ExhaustMapSubscriber;
var init_exhaustMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/exhaustMap.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_map();
    init_from();
    init_innerSubscribe();
    ExhaustMapOperator = /* @__PURE__ */ function() {
      function ExhaustMapOperator2(project) {
        this.project = project;
      }
      ExhaustMapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
      };
      return ExhaustMapOperator2;
    }();
    ExhaustMapSubscriber = /* @__PURE__ */ function(_super) {
      __extends(ExhaustMapSubscriber2, _super);
      function ExhaustMapSubscriber2(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
      }
      ExhaustMapSubscriber2.prototype._next = function(value) {
        if (!this.hasSubscription) {
          this.tryNext(value);
        }
      };
      ExhaustMapSubscriber2.prototype.tryNext = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.hasSubscription = true;
        this._innerSub(result);
      };
      ExhaustMapSubscriber2.prototype._innerSub = function(result) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      ExhaustMapSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      ExhaustMapSubscriber2.prototype.notifyError = function(err) {
        this.destination.error(err);
      };
      ExhaustMapSubscriber2.prototype.notifyComplete = function() {
        this.hasSubscription = false;
        if (this.hasCompleted) {
          this.destination.complete();
        }
      };
      return ExhaustMapSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/expand.js
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function(source) {
    return source.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}
var ExpandOperator, ExpandSubscriber;
var init_expand = __esm({
  "node_modules/rxjs/_esm5/internal/operators/expand.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    ExpandOperator = /* @__PURE__ */ function() {
      function ExpandOperator2(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
      }
      ExpandOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
      };
      return ExpandOperator2;
    }();
    ExpandSubscriber = /* @__PURE__ */ function(_super) {
      __extends(ExpandSubscriber2, _super);
      function ExpandSubscriber2(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
          _this.buffer = [];
        }
        return _this;
      }
      ExpandSubscriber2.dispatch = function(arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
      };
      ExpandSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        if (destination.closed) {
          this._complete();
          return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
          destination.next(value);
          try {
            var project = this.project;
            var result = project(value, index);
            if (!this.scheduler) {
              this.subscribeToProjection(result, value, index);
            } else {
              var state = { subscriber: this, result, value, index };
              var destination_1 = this.destination;
              destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state));
            }
          } catch (e5) {
            destination.error(e5);
          }
        } else {
          this.buffer.push(value);
        }
      };
      ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
      };
      ExpandSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
        this._next(innerValue);
      };
      ExpandSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2 && buffer2.length > 0) {
          this._next(buffer2.shift());
        }
        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }
      };
      return ExpandSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/finalize.js
function finalize(callback) {
  return function(source) {
    return source.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator, FinallySubscriber;
var init_finalize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/finalize.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_Subscription();
    FinallyOperator = /* @__PURE__ */ function() {
      function FinallyOperator2(callback) {
        this.callback = callback;
      }
      FinallyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
      };
      return FinallyOperator2;
    }();
    FinallySubscriber = /* @__PURE__ */ function(_super) {
      __extends(FinallySubscriber2, _super);
      function FinallySubscriber2(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription(callback));
        return _this;
      }
      return FinallySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/find.js
function find(predicate, thisArg) {
  if (typeof predicate !== "function") {
    throw new TypeError("predicate is not a function");
  }
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, false, thisArg));
  };
}
var FindValueOperator, FindValueSubscriber;
var init_find = __esm({
  "node_modules/rxjs/_esm5/internal/operators/find.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    FindValueOperator = /* @__PURE__ */ function() {
      function FindValueOperator2(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
      }
      FindValueOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
      };
      return FindValueOperator2;
    }();
    FindValueSubscriber = /* @__PURE__ */ function(_super) {
      __extends(FindValueSubscriber2, _super);
      function FindValueSubscriber2(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
      }
      FindValueSubscriber2.prototype.notifyComplete = function(value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
      };
      FindValueSubscriber2.prototype._next = function(value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
          var result = predicate.call(thisArg || this, value, index, this.source);
          if (result) {
            this.notifyComplete(this.yieldIndex ? index : value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      FindValueSubscriber2.prototype._complete = function() {
        this.notifyComplete(this.yieldIndex ? -1 : void 0);
      };
      return FindValueSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/findIndex.js
function findIndex(predicate, thisArg) {
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, true, thisArg));
  };
}
var init_findIndex = __esm({
  "node_modules/rxjs/_esm5/internal/operators/findIndex.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_find();
  }
});

// node_modules/rxjs/_esm5/internal/operators/first.js
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v5, i5) {
      return predicate(v5, i5, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_first = __esm({
  "node_modules/rxjs/_esm5/internal/operators/first.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_EmptyError();
    init_filter();
    init_take();
    init_defaultIfEmpty();
    init_throwIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator, IgnoreElementsSubscriber;
var init_ignoreElements = __esm({
  "node_modules/rxjs/_esm5/internal/operators/ignoreElements.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    IgnoreElementsOperator = /* @__PURE__ */ function() {
      function IgnoreElementsOperator2() {
      }
      IgnoreElementsOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
      };
      return IgnoreElementsOperator2;
    }();
    IgnoreElementsSubscriber = /* @__PURE__ */ function(_super) {
      __extends(IgnoreElementsSubscriber2, _super);
      function IgnoreElementsSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      IgnoreElementsSubscriber2.prototype._next = function(unused) {
      };
      return IgnoreElementsSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/isEmpty.js
function isEmpty() {
  return function(source) {
    return source.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator, IsEmptySubscriber;
var init_isEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/isEmpty.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    IsEmptyOperator = /* @__PURE__ */ function() {
      function IsEmptyOperator2() {
      }
      IsEmptyOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
      };
      return IsEmptyOperator2;
    }();
    IsEmptySubscriber = /* @__PURE__ */ function(_super) {
      __extends(IsEmptySubscriber2, _super);
      function IsEmptySubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
        var destination = this.destination;
        destination.next(isEmpty2);
        destination.complete();
      };
      IsEmptySubscriber2.prototype._next = function(value) {
        this.notifyComplete(false);
      };
      IsEmptySubscriber2.prototype._complete = function() {
        this.notifyComplete(true);
      };
      return IsEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeLast.js
function takeLast(count2) {
  return function takeLastOperatorFunction(source) {
    if (count2 === 0) {
      return empty2();
    } else {
      return source.lift(new TakeLastOperator(count2));
    }
  };
}
var TakeLastOperator, TakeLastSubscriber;
var init_takeLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeLast.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    init_empty();
    TakeLastOperator = /* @__PURE__ */ function() {
      function TakeLastOperator2(total) {
        this.total = total;
        if (this.total < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      TakeLastOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
      };
      return TakeLastOperator2;
    }();
    TakeLastSubscriber = /* @__PURE__ */ function(_super) {
      __extends(TakeLastSubscriber2, _super);
      function TakeLastSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
      }
      TakeLastSubscriber2.prototype._next = function(value) {
        var ring = this.ring;
        var total = this.total;
        var count2 = this.count++;
        if (ring.length < total) {
          ring.push(value);
        } else {
          var index = count2 % total;
          ring[index] = value;
        }
      };
      TakeLastSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        var count2 = this.count;
        if (count2 > 0) {
          var total = this.count >= this.total ? this.total : this.count;
          var ring = this.ring;
          for (var i5 = 0; i5 < total; i5++) {
            var idx = count2++ % total;
            destination.next(ring[idx]);
          }
        }
        destination.complete();
      };
      return TakeLastSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/last.js
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v5, i5) {
      return predicate(v5, i5, source);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_last = __esm({
  "node_modules/rxjs/_esm5/internal/operators/last.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_EmptyError();
    init_filter();
    init_takeLast();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mapTo.js
function mapTo(value) {
  return function(source) {
    return source.lift(new MapToOperator(value));
  };
}
var MapToOperator, MapToSubscriber;
var init_mapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mapTo.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    MapToOperator = /* @__PURE__ */ function() {
      function MapToOperator2(value) {
        this.value = value;
      }
      MapToOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
      };
      return MapToOperator2;
    }();
    MapToSubscriber = /* @__PURE__ */ function(_super) {
      __extends(MapToSubscriber2, _super);
      function MapToSubscriber2(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
      }
      MapToSubscriber2.prototype._next = function(x5) {
        this.destination.next(this.value);
      };
      return MapToSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/materialize.js
function materialize() {
  return function materializeOperatorFunction(source) {
    return source.lift(new MaterializeOperator());
  };
}
var MaterializeOperator, MaterializeSubscriber;
var init_materialize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/materialize.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_Notification();
    MaterializeOperator = /* @__PURE__ */ function() {
      function MaterializeOperator2() {
      }
      MaterializeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
      };
      return MaterializeOperator2;
    }();
    MaterializeSubscriber = /* @__PURE__ */ function(_super) {
      __extends(MaterializeSubscriber2, _super);
      function MaterializeSubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      MaterializeSubscriber2.prototype._next = function(value) {
        this.destination.next(Notification.createNext(value));
      };
      MaterializeSubscriber2.prototype._error = function(err) {
        var destination = this.destination;
        destination.next(Notification.createError(err));
        destination.complete();
      };
      MaterializeSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        destination.next(Notification.createComplete());
        destination.complete();
      };
      return MaterializeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  var hasSeed = false;
  if (arguments.length >= 2) {
    hasSeed = true;
  }
  return function scanOperatorFunction(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator, ScanSubscriber;
var init_scan = __esm({
  "node_modules/rxjs/_esm5/internal/operators/scan.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    ScanOperator = /* @__PURE__ */ function() {
      function ScanOperator2(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
          hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
      }
      ScanOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
      };
      return ScanOperator2;
    }();
    ScanSubscriber = /* @__PURE__ */ function(_super) {
      __extends(ScanSubscriber2, _super);
      function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
      }
      Object.defineProperty(ScanSubscriber2.prototype, "seed", {
        get: function() {
          return this._seed;
        },
        set: function(value) {
          this.hasSeed = true;
          this._seed = value;
        },
        enumerable: true,
        configurable: true
      });
      ScanSubscriber2.prototype._next = function(value) {
        if (!this.hasSeed) {
          this.seed = value;
          this.destination.next(value);
        } else {
          return this._tryNext(value);
        }
      };
      ScanSubscriber2.prototype._tryNext = function(value) {
        var index = this.index++;
        var result;
        try {
          result = this.accumulator(this.seed, value, index);
        } catch (err) {
          this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
      };
      return ScanSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/reduce.js
function reduce(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source) {
      return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
    };
  }
  return function reduceOperatorFunction(source) {
    return pipe(scan(function(acc, value, index) {
      return accumulator(acc, value, index + 1);
    }), takeLast(1))(source);
  };
}
var init_reduce = __esm({
  "node_modules/rxjs/_esm5/internal/operators/reduce.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_scan();
    init_takeLast();
    init_defaultIfEmpty();
    init_pipe();
  }
});

// node_modules/rxjs/_esm5/internal/operators/max.js
function max(comparer) {
  var max2 = typeof comparer === "function" ? function(x5, y5) {
    return comparer(x5, y5) > 0 ? x5 : y5;
  } : function(x5, y5) {
    return x5 > y5 ? x5 : y5;
  };
  return reduce(max2);
}
var init_max = __esm({
  "node_modules/rxjs/_esm5/internal/operators/max.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/merge.js
function merge2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(merge.apply(void 0, [source].concat(observables)));
  };
}
var init_merge2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/merge.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_merge();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
var init_mergeMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_mergeMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeScan.js
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return function(source) {
    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator, MergeScanSubscriber;
var init_mergeScan = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeScan.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    MergeScanOperator = /* @__PURE__ */ function() {
      function MergeScanOperator2(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
      }
      MergeScanOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
      };
      return MergeScanOperator2;
    }();
    MergeScanSubscriber = /* @__PURE__ */ function(_super) {
      __extends(MergeScanSubscriber2, _super);
      function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
      }
      MergeScanSubscriber2.prototype._next = function(value) {
        if (this.active < this.concurrent) {
          var index = this.index++;
          var destination = this.destination;
          var ish = void 0;
          try {
            var accumulator = this.accumulator;
            ish = accumulator(this.acc, value, index);
          } catch (e5) {
            return destination.error(e5);
          }
          this.active++;
          this._innerSub(ish);
        } else {
          this.buffer.push(value);
        }
      };
      MergeScanSubscriber2.prototype._innerSub = function(ish) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      MergeScanSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }
          this.destination.complete();
        }
        this.unsubscribe();
      };
      MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
      };
      MergeScanSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2.length > 0) {
          this._next(buffer2.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }
          this.destination.complete();
        }
      };
      return MergeScanSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/min.js
function min(comparer) {
  var min2 = typeof comparer === "function" ? function(x5, y5) {
    return comparer(x5, y5) < 0 ? x5 : y5;
  } : function(x5, y5) {
    return x5 < y5 ? x5 : y5;
  };
  return reduce(min2);
}
var init_min = __esm({
  "node_modules/rxjs/_esm5/internal/operators/min.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/multicast.js
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator;
var init_multicast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/multicast.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_ConnectableObservable();
    MulticastOperator = /* @__PURE__ */ function() {
      function MulticastOperator2(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
      }
      MulticastOperator2.prototype.call = function(subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
      };
      return MulticastOperator2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js
function onErrorResumeNext2() {
  var nextSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }
  if (nextSources.length === 1 && isArray3(nextSources[0])) {
    nextSources = nextSources[0];
  }
  return function(source) {
    return source.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator, OnErrorResumeNextSubscriber;
var init_onErrorResumeNext2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_isArray();
    init_innerSubscribe();
    OnErrorResumeNextOperator = /* @__PURE__ */ function() {
      function OnErrorResumeNextOperator2(nextSources) {
        this.nextSources = nextSources;
      }
      OnErrorResumeNextOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
      };
      return OnErrorResumeNextOperator2;
    }();
    OnErrorResumeNextSubscriber = /* @__PURE__ */ function(_super) {
      __extends(OnErrorResumeNextSubscriber2, _super);
      function OnErrorResumeNextSubscriber2(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
      }
      OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
        this.subscribeToNextSource();
      };
      OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
        this.subscribeToNextSource();
      };
      OnErrorResumeNextSubscriber2.prototype._error = function(err) {
        this.subscribeToNextSource();
        this.unsubscribe();
      };
      OnErrorResumeNextSubscriber2.prototype._complete = function() {
        this.subscribeToNextSource();
        this.unsubscribe();
      };
      OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
        var next = this.nextSources.shift();
        if (!!next) {
          var innerSubscriber = new SimpleInnerSubscriber(this);
          var destination = this.destination;
          destination.add(innerSubscriber);
          var innerSubscription = innerSubscribe(next, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
          }
        } else {
          this.destination.complete();
        }
      };
      return OnErrorResumeNextSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/pairwise.js
function pairwise() {
  return function(source) {
    return source.lift(new PairwiseOperator());
  };
}
var PairwiseOperator, PairwiseSubscriber;
var init_pairwise = __esm({
  "node_modules/rxjs/_esm5/internal/operators/pairwise.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    PairwiseOperator = /* @__PURE__ */ function() {
      function PairwiseOperator2() {
      }
      PairwiseOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
      };
      return PairwiseOperator2;
    }();
    PairwiseSubscriber = /* @__PURE__ */ function(_super) {
      __extends(PairwiseSubscriber2, _super);
      function PairwiseSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
      }
      PairwiseSubscriber2.prototype._next = function(value) {
        var pair;
        if (this.hasPrev) {
          pair = [this.prev, value];
        } else {
          this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
          this.destination.next(pair);
        }
      };
      return PairwiseSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/partition.js
function partition2(predicate, thisArg) {
  return function(source) {
    return [
      filter(predicate, thisArg)(source),
      filter(not(predicate, thisArg))(source)
    ];
  };
}
var init_partition2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/partition.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_not();
    init_filter();
  }
});

// node_modules/rxjs/_esm5/internal/operators/pluck.js
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source) {
    return map(plucker(properties, length))(source);
  };
}
function plucker(props, length) {
  var mapper = function(x5) {
    var currentProp = x5;
    for (var i5 = 0; i5 < length; i5++) {
      var p5 = currentProp != null ? currentProp[props[i5]] : void 0;
      if (p5 !== void 0) {
        currentProp = p5;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
var init_pluck = __esm({
  "node_modules/rxjs/_esm5/internal/operators/pluck.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_map();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publish.js
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
var init_publish = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publish.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_Subject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishBehavior.js
function publishBehavior(value) {
  return function(source) {
    return multicast(new BehaviorSubject(value))(source);
  };
}
var init_publishBehavior = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishBehavior.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_BehaviorSubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishLast.js
function publishLast() {
  return function(source) {
    return multicast(new AsyncSubject())(source);
  };
}
var init_publishLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishLast.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_AsyncSubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishReplay.js
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
  return function(source) {
    return multicast(function() {
      return subject;
    }, selector)(source);
  };
}
var init_publishReplay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishReplay.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_ReplaySubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/race.js
function race2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function raceOperatorFunction(source) {
    if (observables.length === 1 && isArray3(observables[0])) {
      observables = observables[0];
    }
    return source.lift.call(race.apply(void 0, [source].concat(observables)));
  };
}
var init_race2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/race.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_isArray();
    init_race();
  }
});

// node_modules/rxjs/_esm5/internal/operators/repeat.js
function repeat(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    if (count2 === 0) {
      return empty2();
    } else if (count2 < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count2 - 1, source));
    }
  };
}
var RepeatOperator, RepeatSubscriber;
var init_repeat = __esm({
  "node_modules/rxjs/_esm5/internal/operators/repeat.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_empty();
    RepeatOperator = /* @__PURE__ */ function() {
      function RepeatOperator2(count2, source) {
        this.count = count2;
        this.source = source;
      }
      RepeatOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
      };
      return RepeatOperator2;
    }();
    RepeatSubscriber = /* @__PURE__ */ function(_super) {
      __extends(RepeatSubscriber2, _super);
      function RepeatSubscriber2(destination, count2, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count2;
        _this.source = source;
        return _this;
      }
      RepeatSubscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          var _a = this, source = _a.source, count2 = _a.count;
          if (count2 === 0) {
            return _super.prototype.complete.call(this);
          } else if (count2 > -1) {
            this.count = count2 - 1;
          }
          source.subscribe(this._unsubscribeAndRecycle());
        }
      };
      return RepeatSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/repeatWhen.js
function repeatWhen(notifier) {
  return function(source) {
    return source.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator, RepeatWhenSubscriber;
var init_repeatWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/repeatWhen.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subject();
    init_innerSubscribe();
    RepeatWhenOperator = /* @__PURE__ */ function() {
      function RepeatWhenOperator2(notifier) {
        this.notifier = notifier;
      }
      RepeatWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
      };
      return RepeatWhenOperator2;
    }();
    RepeatWhenSubscriber = /* @__PURE__ */ function(_super) {
      __extends(RepeatWhenSubscriber2, _super);
      function RepeatWhenSubscriber2(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
      }
      RepeatWhenSubscriber2.prototype.notifyNext = function() {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
      };
      RepeatWhenSubscriber2.prototype.notifyComplete = function() {
        if (this.sourceIsBeingSubscribedTo === false) {
          return _super.prototype.complete.call(this);
        }
      };
      RepeatWhenSubscriber2.prototype.complete = function() {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
          if (!this.retries) {
            this.subscribeToRetries();
          }
          if (!this.retriesSubscription || this.retriesSubscription.closed) {
            return _super.prototype.complete.call(this);
          }
          this._unsubscribeAndRecycle();
          this.notifications.next(void 0);
        }
      };
      RepeatWhenSubscriber2.prototype._unsubscribe = function() {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
          notifications.unsubscribe();
          this.notifications = void 0;
        }
        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = void 0;
        }
        this.retries = void 0;
      };
      RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
      };
      RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
        this.notifications = new Subject();
        var retries;
        try {
          var notifier = this.notifier;
          retries = notifier(this.notifications);
        } catch (e5) {
          return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      };
      return RepeatWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/retry.js
function retry(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    return source.lift(new RetryOperator(count2, source));
  };
}
var RetryOperator, RetrySubscriber;
var init_retry = __esm({
  "node_modules/rxjs/_esm5/internal/operators/retry.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    RetryOperator = /* @__PURE__ */ function() {
      function RetryOperator2(count2, source) {
        this.count = count2;
        this.source = source;
      }
      RetryOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
      };
      return RetryOperator2;
    }();
    RetrySubscriber = /* @__PURE__ */ function(_super) {
      __extends(RetrySubscriber2, _super);
      function RetrySubscriber2(destination, count2, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count2;
        _this.source = source;
        return _this;
      }
      RetrySubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _a = this, source = _a.source, count2 = _a.count;
          if (count2 === 0) {
            return _super.prototype.error.call(this, err);
          } else if (count2 > -1) {
            this.count = count2 - 1;
          }
          source.subscribe(this._unsubscribeAndRecycle());
        }
      };
      return RetrySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/retryWhen.js
function retryWhen(notifier) {
  return function(source) {
    return source.lift(new RetryWhenOperator(notifier, source));
  };
}
var RetryWhenOperator, RetryWhenSubscriber;
var init_retryWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/retryWhen.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subject();
    init_innerSubscribe();
    RetryWhenOperator = /* @__PURE__ */ function() {
      function RetryWhenOperator2(notifier, source) {
        this.notifier = notifier;
        this.source = source;
      }
      RetryWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
      };
      return RetryWhenOperator2;
    }();
    RetryWhenSubscriber = /* @__PURE__ */ function(_super) {
      __extends(RetryWhenSubscriber2, _super);
      function RetryWhenSubscriber2(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
      }
      RetryWhenSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var errors2 = this.errors;
          var retries = this.retries;
          var retriesSubscription = this.retriesSubscription;
          if (!retries) {
            errors2 = new Subject();
            try {
              var notifier = this.notifier;
              retries = notifier(errors2);
            } catch (e5) {
              return _super.prototype.error.call(this, e5);
            }
            retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
          } else {
            this.errors = void 0;
            this.retriesSubscription = void 0;
          }
          this._unsubscribeAndRecycle();
          this.errors = errors2;
          this.retries = retries;
          this.retriesSubscription = retriesSubscription;
          errors2.next(err);
        }
      };
      RetryWhenSubscriber2.prototype._unsubscribe = function() {
        var _a = this, errors2 = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors2) {
          errors2.unsubscribe();
          this.errors = void 0;
        }
        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = void 0;
        }
        this.retries = void 0;
      };
      RetryWhenSubscriber2.prototype.notifyNext = function() {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
      };
      return RetryWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sample.js
function sample(notifier) {
  return function(source) {
    return source.lift(new SampleOperator(notifier));
  };
}
var SampleOperator, SampleSubscriber;
var init_sample = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sample.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    SampleOperator = /* @__PURE__ */ function() {
      function SampleOperator2(notifier) {
        this.notifier = notifier;
      }
      SampleOperator2.prototype.call = function(subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
        return subscription;
      };
      return SampleOperator2;
    }();
    SampleSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SampleSubscriber2, _super);
      function SampleSubscriber2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
      }
      SampleSubscriber2.prototype._next = function(value) {
        this.value = value;
        this.hasValue = true;
      };
      SampleSubscriber2.prototype.notifyNext = function() {
        this.emitValue();
      };
      SampleSubscriber2.prototype.notifyComplete = function() {
        this.emitValue();
      };
      SampleSubscriber2.prototype.emitValue = function() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.value);
        }
      };
      return SampleSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sampleTime.js
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new SampleTimeOperator(period, scheduler));
  };
}
function dispatchNotification(state) {
  var subscriber = state.subscriber, period = state.period;
  subscriber.notifyNext();
  this.schedule(state, period);
}
var SampleTimeOperator, SampleTimeSubscriber;
var init_sampleTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sampleTime.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_async();
    SampleTimeOperator = /* @__PURE__ */ function() {
      function SampleTimeOperator2(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
      }
      SampleTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
      };
      return SampleTimeOperator2;
    }();
    SampleTimeSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SampleTimeSubscriber2, _super);
      function SampleTimeSubscriber2(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period }));
        return _this;
      }
      SampleTimeSubscriber2.prototype._next = function(value) {
        this.lastValue = value;
        this.hasValue = true;
      };
      SampleTimeSubscriber2.prototype.notifyNext = function() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.lastValue);
        }
      };
      return SampleTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js
function sequenceEqual(compareTo, comparator) {
  return function(source) {
    return source.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}
var SequenceEqualOperator, SequenceEqualSubscriber, SequenceEqualCompareToSubscriber;
var init_sequenceEqual = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    SequenceEqualOperator = /* @__PURE__ */ function() {
      function SequenceEqualOperator2(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
      }
      SequenceEqualOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
      };
      return SequenceEqualOperator2;
    }();
    SequenceEqualSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SequenceEqualSubscriber2, _super);
      function SequenceEqualSubscriber2(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
      }
      SequenceEqualSubscriber2.prototype._next = function(value) {
        if (this._oneComplete && this._b.length === 0) {
          this.emit(false);
        } else {
          this._a.push(value);
          this.checkValues();
        }
      };
      SequenceEqualSubscriber2.prototype._complete = function() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }
        this.unsubscribe();
      };
      SequenceEqualSubscriber2.prototype.checkValues = function() {
        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a.length > 0 && _b.length > 0) {
          var a5 = _a.shift();
          var b4 = _b.shift();
          var areEqual = false;
          try {
            areEqual = comparator ? comparator(a5, b4) : a5 === b4;
          } catch (e5) {
            this.destination.error(e5);
          }
          if (!areEqual) {
            this.emit(false);
          }
        }
      };
      SequenceEqualSubscriber2.prototype.emit = function(value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
      };
      SequenceEqualSubscriber2.prototype.nextB = function(value) {
        if (this._oneComplete && this._a.length === 0) {
          this.emit(false);
        } else {
          this._b.push(value);
          this.checkValues();
        }
      };
      SequenceEqualSubscriber2.prototype.completeB = function() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }
      };
      return SequenceEqualSubscriber2;
    }(Subscriber);
    SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SequenceEqualCompareToSubscriber2, _super);
      function SequenceEqualCompareToSubscriber2(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
      }
      SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
        this.parent.nextB(value);
      };
      SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
        this.parent.error(err);
        this.unsubscribe();
      };
      SequenceEqualCompareToSubscriber2.prototype._complete = function() {
        this.parent.completeB();
        this.unsubscribe();
      };
      return SequenceEqualCompareToSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/share.js
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source) {
    return refCount()(multicast(shareSubjectFactory)(source));
  };
}
var init_share = __esm({
  "node_modules/rxjs/_esm5/internal/operators/share.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_multicast();
    init_refCount();
    init_Subject();
  }
});

// node_modules/rxjs/_esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var config4;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config4 = configOrBufferSize;
  } else {
    config4 = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime2,
      refCount: false,
      scheduler
    };
  }
  return function(source) {
    return source.lift(shareReplayOperator(config4));
  };
}
function shareReplayOperator(_a) {
  var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next: function(value) {
          subject.next(value);
        },
        error: function(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function() {
          isComplete = true;
          subscription = void 0;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
var init_shareReplay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/shareReplay.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_ReplaySubject();
  }
});

// node_modules/rxjs/_esm5/internal/operators/single.js
function single(predicate) {
  return function(source) {
    return source.lift(new SingleOperator(predicate, source));
  };
}
var SingleOperator, SingleSubscriber;
var init_single = __esm({
  "node_modules/rxjs/_esm5/internal/operators/single.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_EmptyError();
    SingleOperator = /* @__PURE__ */ function() {
      function SingleOperator2(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }
      SingleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
      };
      return SingleOperator2;
    }();
    SingleSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SingleSubscriber2, _super);
      function SingleSubscriber2(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
      }
      SingleSubscriber2.prototype.applySingleValue = function(value) {
        if (this.seenValue) {
          this.destination.error("Sequence contains more than one element");
        } else {
          this.seenValue = true;
          this.singleValue = value;
        }
      };
      SingleSubscriber2.prototype._next = function(value) {
        var index = this.index++;
        if (this.predicate) {
          this.tryNext(value, index);
        } else {
          this.applySingleValue(value);
        }
      };
      SingleSubscriber2.prototype.tryNext = function(value, index) {
        try {
          if (this.predicate(value, index, this.source)) {
            this.applySingleValue(value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      SingleSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        if (this.index > 0) {
          destination.next(this.seenValue ? this.singleValue : void 0);
          destination.complete();
        } else {
          destination.error(new EmptyError());
        }
      };
      return SingleSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skip.js
function skip(count2) {
  return function(source) {
    return source.lift(new SkipOperator(count2));
  };
}
var SkipOperator, SkipSubscriber;
var init_skip = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skip.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    SkipOperator = /* @__PURE__ */ function() {
      function SkipOperator2(total) {
        this.total = total;
      }
      SkipOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
      };
      return SkipOperator2;
    }();
    SkipSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SkipSubscriber2, _super);
      function SkipSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
      }
      SkipSubscriber2.prototype._next = function(x5) {
        if (++this.count > this.total) {
          this.destination.next(x5);
        }
      };
      return SkipSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipLast.js
function skipLast(count2) {
  return function(source) {
    return source.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator, SkipLastSubscriber;
var init_skipLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipLast.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    SkipLastOperator = /* @__PURE__ */ function() {
      function SkipLastOperator2(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      SkipLastOperator2.prototype.call = function(subscriber, source) {
        if (this._skipCount === 0) {
          return source.subscribe(new Subscriber(subscriber));
        } else {
          return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
      };
      return SkipLastOperator2;
    }();
    SkipLastSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SkipLastSubscriber2, _super);
      function SkipLastSubscriber2(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
      }
      SkipLastSubscriber2.prototype._next = function(value) {
        var skipCount = this._skipCount;
        var count2 = this._count++;
        if (count2 < skipCount) {
          this._ring[count2] = value;
        } else {
          var currentIndex = count2 % skipCount;
          var ring = this._ring;
          var oldValue = ring[currentIndex];
          ring[currentIndex] = value;
          this.destination.next(oldValue);
        }
      };
      return SkipLastSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipUntil.js
function skipUntil(notifier) {
  return function(source) {
    return source.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator, SkipUntilSubscriber;
var init_skipUntil = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipUntil.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    SkipUntilOperator = /* @__PURE__ */ function() {
      function SkipUntilOperator2(notifier) {
        this.notifier = notifier;
      }
      SkipUntilOperator2.prototype.call = function(destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
      };
      return SkipUntilOperator2;
    }();
    SkipUntilSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SkipUntilSubscriber2, _super);
      function SkipUntilSubscriber2(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new SimpleInnerSubscriber(_this);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = innerSubscribe(notifier, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          _this.add(innerSubscription);
          _this.innerSubscription = innerSubscription;
        }
        return _this;
      }
      SkipUntilSubscriber2.prototype._next = function(value) {
        if (this.hasValue) {
          _super.prototype._next.call(this, value);
        }
      };
      SkipUntilSubscriber2.prototype.notifyNext = function() {
        this.hasValue = true;
        if (this.innerSubscription) {
          this.innerSubscription.unsubscribe();
        }
      };
      SkipUntilSubscriber2.prototype.notifyComplete = function() {
      };
      return SkipUntilSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipWhile.js
function skipWhile(predicate) {
  return function(source) {
    return source.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator, SkipWhileSubscriber;
var init_skipWhile = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipWhile.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    SkipWhileOperator = /* @__PURE__ */ function() {
      function SkipWhileOperator2(predicate) {
        this.predicate = predicate;
      }
      SkipWhileOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
      };
      return SkipWhileOperator2;
    }();
    SkipWhileSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SkipWhileSubscriber2, _super);
      function SkipWhileSubscriber2(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
      }
      SkipWhileSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        if (this.skipping) {
          this.tryCallPredicate(value);
        }
        if (!this.skipping) {
          destination.next(value);
        }
      };
      SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
        try {
          var result = this.predicate(value, this.index++);
          this.skipping = Boolean(result);
        } catch (err) {
          this.destination.error(err);
        }
      };
      return SkipWhileSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/startWith.js
function startWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  var scheduler = array[array.length - 1];
  if (isScheduler(scheduler)) {
    array.pop();
    return function(source) {
      return concat3(array, source, scheduler);
    };
  } else {
    return function(source) {
      return concat3(array, source);
    };
  }
}
var init_startWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/startWith.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_concat();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js
var SubscribeOnObservable;
var init_SubscribeOnObservable = __esm({
  "node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Observable();
    init_asap();
    init_isNumeric();
    SubscribeOnObservable = /* @__PURE__ */ function(_super) {
      __extends(SubscribeOnObservable2, _super);
      function SubscribeOnObservable2(source, delayTime, scheduler) {
        if (delayTime === void 0) {
          delayTime = 0;
        }
        if (scheduler === void 0) {
          scheduler = asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric(delayTime) || delayTime < 0) {
          _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== "function") {
          _this.scheduler = asap;
        }
        return _this;
      }
      SubscribeOnObservable2.create = function(source, delay2, scheduler) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (scheduler === void 0) {
          scheduler = asap;
        }
        return new SubscribeOnObservable2(source, delay2, scheduler);
      };
      SubscribeOnObservable2.dispatch = function(arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
      };
      SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
        var delay2 = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
          source,
          subscriber
        });
      };
      return SubscribeOnObservable2;
    }(Observable);
  }
});

// node_modules/rxjs/_esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function subscribeOnOperatorFunction(source) {
    return source.lift(new SubscribeOnOperator(scheduler, delay2));
  };
}
var SubscribeOnOperator;
var init_subscribeOn = __esm({
  "node_modules/rxjs/_esm5/internal/operators/subscribeOn.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_SubscribeOnObservable();
    SubscribeOnOperator = /* @__PURE__ */ function() {
      function SubscribeOnOperator2(scheduler, delay2) {
        this.scheduler = scheduler;
        this.delay = delay2;
      }
      SubscribeOnOperator2.prototype.call = function(subscriber, source) {
        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
      };
      return SubscribeOnOperator2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(switchMap(function(a5, i5) {
        return from3(project(a5, i5)).pipe(map(function(b4, ii) {
          return resultSelector(a5, b4, i5, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator, SwitchMapSubscriber;
var init_switchMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchMap.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_map();
    init_from();
    init_innerSubscribe();
    SwitchMapOperator = /* @__PURE__ */ function() {
      function SwitchMapOperator2(project) {
        this.project = project;
      }
      SwitchMapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
      };
      return SwitchMapOperator2;
    }();
    SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
      __extends(SwitchMapSubscriber2, _super);
      function SwitchMapSubscriber2(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
      }
      SwitchMapSubscriber2.prototype._next = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (error2) {
          this.destination.error(error2);
          return;
        }
        this._innerSub(result);
      };
      SwitchMapSubscriber2.prototype._innerSub = function(result) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
          innerSubscription.unsubscribe();
        }
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = innerSubscribe(result, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
          destination.add(this.innerSubscription);
        }
      };
      SwitchMapSubscriber2.prototype._complete = function() {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
          _super.prototype._complete.call(this);
        }
        this.unsubscribe();
      };
      SwitchMapSubscriber2.prototype._unsubscribe = function() {
        this.innerSubscription = void 0;
      };
      SwitchMapSubscriber2.prototype.notifyComplete = function() {
        this.innerSubscription = void 0;
        if (this.isStopped) {
          _super.prototype._complete.call(this);
        }
      };
      SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      return SwitchMapSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchAll.js
function switchAll() {
  return switchMap(identity);
}
var init_switchAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchAll.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_switchMap();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
var init_switchMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchMapTo.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_switchMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return function(source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator, TakeUntilSubscriber;
var init_takeUntil = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeUntil.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    TakeUntilOperator = /* @__PURE__ */ function() {
      function TakeUntilOperator2(notifier) {
        this.notifier = notifier;
      }
      TakeUntilOperator2.prototype.call = function(subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
          takeUntilSubscriber.add(notifierSubscription);
          return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
      };
      return TakeUntilOperator2;
    }();
    TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
      __extends(TakeUntilSubscriber2, _super);
      function TakeUntilSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
      }
      TakeUntilSubscriber2.prototype.notifyNext = function() {
        this.seenValue = true;
        this.complete();
      };
      TakeUntilSubscriber2.prototype.notifyComplete = function() {
      };
      return TakeUntilSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator, TakeWhileSubscriber;
var init_takeWhile = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeWhile.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    TakeWhileOperator = /* @__PURE__ */ function() {
      function TakeWhileOperator2(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
      }
      TakeWhileOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
      };
      return TakeWhileOperator2;
    }();
    TakeWhileSubscriber = /* @__PURE__ */ function(_super) {
      __extends(TakeWhileSubscriber2, _super);
      function TakeWhileSubscriber2(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
      }
      TakeWhileSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        var result;
        try {
          result = this.predicate(value, this.index++);
        } catch (err) {
          destination.error(err);
          return;
        }
        this.nextOrComplete(value, result);
      };
      TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
          destination.next(value);
        } else {
          if (this.inclusive) {
            destination.next(value);
          }
          destination.complete();
        }
      };
      return TakeWhileSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/tap.js
function tap(nextOrObserver, error2, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error2, complete));
  };
}
var DoOperator, TapSubscriber;
var init_tap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/tap.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_noop();
    init_isFunction();
    DoOperator = /* @__PURE__ */ function() {
      function DoOperator2(nextOrObserver, error2, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error2;
        this.complete = complete;
      }
      DoOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
      };
      return DoOperator2;
    }();
    TapSubscriber = /* @__PURE__ */ function(_super) {
      __extends(TapSubscriber2, _super);
      function TapSubscriber2(destination, observerOrNext, error2, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop3;
        _this._tapError = noop3;
        _this._tapComplete = noop3;
        _this._tapError = error2 || noop3;
        _this._tapComplete = complete || noop3;
        if (isFunction2(observerOrNext)) {
          _this._context = _this;
          _this._tapNext = observerOrNext;
        } else if (observerOrNext) {
          _this._context = observerOrNext;
          _this._tapNext = observerOrNext.next || noop3;
          _this._tapError = observerOrNext.error || noop3;
          _this._tapComplete = observerOrNext.complete || noop3;
        }
        return _this;
      }
      TapSubscriber2.prototype._next = function(value) {
        try {
          this._tapNext.call(this._context, value);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(value);
      };
      TapSubscriber2.prototype._error = function(err) {
        try {
          this._tapError.call(this._context, err);
        } catch (err2) {
          this.destination.error(err2);
          return;
        }
        this.destination.error(err);
      };
      TapSubscriber2.prototype._complete = function() {
        try {
          this._tapComplete.call(this._context);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        return this.destination.complete();
      };
      return TapSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/throttle.js
function throttle(durationSelector, config4) {
  if (config4 === void 0) {
    config4 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleOperator(durationSelector, !!config4.leading, !!config4.trailing));
  };
}
var defaultThrottleConfig, ThrottleOperator, ThrottleSubscriber;
var init_throttle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throttle.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_innerSubscribe();
    defaultThrottleConfig = {
      leading: true,
      trailing: false
    };
    ThrottleOperator = /* @__PURE__ */ function() {
      function ThrottleOperator2(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
      }
      ThrottleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
      };
      return ThrottleOperator2;
    }();
    ThrottleSubscriber = /* @__PURE__ */ function(_super) {
      __extends(ThrottleSubscriber2, _super);
      function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
      }
      ThrottleSubscriber2.prototype._next = function(value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
          if (this._leading) {
            this.send();
          } else {
            this.throttle(value);
          }
        }
      };
      ThrottleSubscriber2.prototype.send = function() {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
          this.destination.next(_sendValue);
          this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = void 0;
      };
      ThrottleSubscriber2.prototype.throttle = function(value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
          this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
        }
      };
      ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
        try {
          return this.durationSelector(value);
        } catch (err) {
          this.destination.error(err);
          return null;
        }
      };
      ThrottleSubscriber2.prototype.throttlingDone = function() {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
          _throttled.unsubscribe();
        }
        this._throttled = void 0;
        if (_trailing) {
          this.send();
        }
      };
      ThrottleSubscriber2.prototype.notifyNext = function() {
        this.throttlingDone();
      };
      ThrottleSubscriber2.prototype.notifyComplete = function() {
        this.throttlingDone();
      };
      return ThrottleSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/throttleTime.js
function throttleTime(duration, scheduler, config4) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (config4 === void 0) {
    config4 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleTimeOperator(duration, scheduler, config4.leading, config4.trailing));
  };
}
function dispatchNext4(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
var ThrottleTimeOperator, ThrottleTimeSubscriber;
var init_throttleTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throttleTime.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_async();
    init_throttle();
    ThrottleTimeOperator = /* @__PURE__ */ function() {
      function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
      }
      ThrottleTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
      };
      return ThrottleTimeOperator2;
    }();
    ThrottleTimeSubscriber = /* @__PURE__ */ function(_super) {
      __extends(ThrottleTimeSubscriber2, _super);
      function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
      }
      ThrottleTimeSubscriber2.prototype._next = function(value) {
        if (this.throttled) {
          if (this.trailing) {
            this._trailingValue = value;
            this._hasTrailingValue = true;
          }
        } else {
          this.add(this.throttled = this.scheduler.schedule(dispatchNext4, this.duration, { subscriber: this }));
          if (this.leading) {
            this.destination.next(value);
          } else if (this.trailing) {
            this._trailingValue = value;
            this._hasTrailingValue = true;
          }
        }
      };
      ThrottleTimeSubscriber2.prototype._complete = function() {
        if (this._hasTrailingValue) {
          this.destination.next(this._trailingValue);
          this.destination.complete();
        } else {
          this.destination.complete();
        }
      };
      ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
        var throttled = this.throttled;
        if (throttled) {
          if (this.trailing && this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
          }
          throttled.unsubscribe();
          this.remove(throttled);
          this.throttled = null;
        }
      };
      return ThrottleTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeInterval.js
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return defer(function() {
      return source.pipe(scan(function(_a, value) {
        var current = _a.current;
        return { value, current: scheduler.now(), last: current };
      }, { current: scheduler.now(), value: void 0, last: void 0 }), map(function(_a) {
        var current = _a.current, last2 = _a.last, value = _a.value;
        return new TimeInterval(value, current - last2);
      }));
    });
  };
}
var TimeInterval;
var init_timeInterval = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeInterval.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_async();
    init_scan();
    init_defer();
    init_map();
    TimeInterval = /* @__PURE__ */ function() {
      function TimeInterval2(value, interval2) {
        this.value = value;
        this.interval = interval2;
      }
      return TimeInterval2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    var absoluteTimeout = isDate2(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator, TimeoutWithSubscriber;
var init_timeoutWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeoutWith.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_async();
    init_isDate();
    init_innerSubscribe();
    TimeoutWithOperator = /* @__PURE__ */ function() {
      function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
      }
      TimeoutWithOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
      };
      return TimeoutWithOperator2;
    }();
    TimeoutWithSubscriber = /* @__PURE__ */ function(_super) {
      __extends(TimeoutWithSubscriber2, _super);
      function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.scheduleTimeout();
        return _this;
      }
      TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
      };
      TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
        var action = this.action;
        if (action) {
          this.action = action.schedule(this, this.waitFor);
        } else {
          this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
        }
      };
      TimeoutWithSubscriber2.prototype._next = function(value) {
        if (!this.absoluteTimeout) {
          this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
      };
      TimeoutWithSubscriber2.prototype._unsubscribe = function() {
        this.action = void 0;
        this.scheduler = null;
        this.withObservable = null;
      };
      return TimeoutWithSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeout.js
function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler);
}
var init_timeout = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeout.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_async();
    init_TimeoutError();
    init_timeoutWith();
    init_throwError();
  }
});

// node_modules/rxjs/_esm5/internal/operators/timestamp.js
function timestamp2(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return map(function(value) {
    return new Timestamp(value, scheduler.now());
  });
}
var Timestamp;
var init_timestamp = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timestamp.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_async();
    init_map();
    Timestamp = /* @__PURE__ */ function() {
      function Timestamp2(value, timestamp3) {
        this.value = value;
        this.timestamp = timestamp3;
      }
      return Timestamp2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/toArray.js
function toArrayReducer(arr, item, index) {
  if (index === 0) {
    return [item];
  }
  arr.push(item);
  return arr;
}
function toArray() {
  return reduce(toArrayReducer, []);
}
var init_toArray = __esm({
  "node_modules/rxjs/_esm5/internal/operators/toArray.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/window.js
function window2(windowBoundaries) {
  return function windowOperatorFunction(source) {
    return source.lift(new WindowOperator(windowBoundaries));
  };
}
var WindowOperator, WindowSubscriber;
var init_window = __esm({
  "node_modules/rxjs/_esm5/internal/operators/window.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subject();
    init_innerSubscribe();
    WindowOperator = /* @__PURE__ */ function() {
      function WindowOperator3(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
      }
      WindowOperator3.prototype.call = function(subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
          windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
        }
        return sourceSubscription;
      };
      return WindowOperator3;
    }();
    WindowSubscriber = /* @__PURE__ */ function(_super) {
      __extends(WindowSubscriber3, _super);
      function WindowSubscriber3(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject();
        destination.next(_this.window);
        return _this;
      }
      WindowSubscriber3.prototype.notifyNext = function() {
        this.openWindow();
      };
      WindowSubscriber3.prototype.notifyError = function(error2) {
        this._error(error2);
      };
      WindowSubscriber3.prototype.notifyComplete = function() {
        this._complete();
      };
      WindowSubscriber3.prototype._next = function(value) {
        this.window.next(value);
      };
      WindowSubscriber3.prototype._error = function(err) {
        this.window.error(err);
        this.destination.error(err);
      };
      WindowSubscriber3.prototype._complete = function() {
        this.window.complete();
        this.destination.complete();
      };
      WindowSubscriber3.prototype._unsubscribe = function() {
        this.window = null;
      };
      WindowSubscriber3.prototype.openWindow = function() {
        var prevWindow = this.window;
        if (prevWindow) {
          prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject();
        destination.next(newWindow);
      };
      return WindowSubscriber3;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowCount.js
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  return function windowCountOperatorFunction(source) {
    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator, WindowCountSubscriber;
var init_windowCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowCount.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subscriber();
    init_Subject();
    WindowCountOperator = /* @__PURE__ */ function() {
      function WindowCountOperator2(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
      }
      WindowCountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
      };
      return WindowCountOperator2;
    }();
    WindowCountSubscriber = /* @__PURE__ */ function(_super) {
      __extends(WindowCountSubscriber2, _super);
      function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
      }
      WindowCountSubscriber2.prototype._next = function(value) {
        var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i5 = 0; i5 < len && !this.closed; i5++) {
          windows[i5].next(value);
        }
        var c5 = this.count - windowSize + 1;
        if (c5 >= 0 && c5 % startWindowEvery === 0 && !this.closed) {
          windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
          var window_1 = new Subject();
          windows.push(window_1);
          destination.next(window_1);
        }
      };
      WindowCountSubscriber2.prototype._error = function(err) {
        var windows = this.windows;
        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().error(err);
          }
        }
        this.destination.error(err);
      };
      WindowCountSubscriber2.prototype._complete = function() {
        var windows = this.windows;
        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().complete();
          }
        }
        this.destination.complete();
      };
      WindowCountSubscriber2.prototype._unsubscribe = function() {
        this.count = 0;
        this.windows = null;
      };
      return WindowCountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowTime.js
function windowTime(windowTimeSpan) {
  var scheduler = async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;
  if (isScheduler(arguments[3])) {
    scheduler = arguments[3];
  }
  if (isScheduler(arguments[2])) {
    scheduler = arguments[2];
  } else if (isNumeric(arguments[2])) {
    maxWindowSize = Number(arguments[2]);
  }
  if (isScheduler(arguments[1])) {
    scheduler = arguments[1];
  } else if (isNumeric(arguments[1])) {
    windowCreationInterval = Number(arguments[1]);
  }
  return function windowTimeOperatorFunction(source) {
    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}
function dispatchWindowTimeSpanOnly(state) {
  var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window3 = state.window;
  if (window3) {
    subscriber.closeWindow(window3);
  }
  state.window = subscriber.openWindow();
  this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
  var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
  var window3 = subscriber.openWindow();
  var action = this;
  var context = { action, subscription: null };
  var timeSpanState = { subscriber, window: window3, context };
  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context.subscription);
  action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
  var subscriber = state.subscriber, window3 = state.window, context = state.context;
  if (context && context.action && context.subscription) {
    context.action.remove(context.subscription);
  }
  subscriber.closeWindow(window3);
}
var WindowTimeOperator, CountedSubject, WindowTimeSubscriber;
var init_windowTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowTime.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subject();
    init_async();
    init_Subscriber();
    init_isNumeric();
    init_isScheduler();
    WindowTimeOperator = /* @__PURE__ */ function() {
      function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
      }
      WindowTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
      };
      return WindowTimeOperator2;
    }();
    CountedSubject = /* @__PURE__ */ function(_super) {
      __extends(CountedSubject2, _super);
      function CountedSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
      }
      CountedSubject2.prototype.next = function(value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
      };
      Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
        get: function() {
          return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
      });
      return CountedSubject2;
    }(Subject);
    WindowTimeSubscriber = /* @__PURE__ */ function(_super) {
      __extends(WindowTimeSubscriber2, _super);
      function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window3 = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          var closeState = { subscriber: _this, window: window3, context: null };
          var creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler };
          _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
          _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        } else {
          var timeSpanOnlyState = { subscriber: _this, window: window3, windowTimeSpan };
          _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
      }
      WindowTimeSubscriber2.prototype._next = function(value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i5 = 0; i5 < len; i5++) {
          var window_1 = windows[i5];
          if (!window_1.closed) {
            window_1.next(value);
            if (window_1.numberOfNextedValues >= this.maxWindowSize) {
              this.closeWindow(window_1);
            }
          }
        }
      };
      WindowTimeSubscriber2.prototype._error = function(err) {
        var windows = this.windows;
        while (windows.length > 0) {
          windows.shift().error(err);
        }
        this.destination.error(err);
      };
      WindowTimeSubscriber2.prototype._complete = function() {
        var windows = this.windows;
        while (windows.length > 0) {
          var window_2 = windows.shift();
          if (!window_2.closed) {
            window_2.complete();
          }
        }
        this.destination.complete();
      };
      WindowTimeSubscriber2.prototype.openWindow = function() {
        var window3 = new CountedSubject();
        this.windows.push(window3);
        var destination = this.destination;
        destination.next(window3);
        return window3;
      };
      WindowTimeSubscriber2.prototype.closeWindow = function(window3) {
        window3.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window3), 1);
      };
      return WindowTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowToggle.js
function windowToggle(openings, closingSelector) {
  return function(source) {
    return source.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator, WindowToggleSubscriber;
var init_windowToggle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowToggle.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subject();
    init_Subscription();
    init_OuterSubscriber();
    init_subscribeToResult();
    WindowToggleOperator = /* @__PURE__ */ function() {
      function WindowToggleOperator2(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }
      WindowToggleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
      };
      return WindowToggleOperator2;
    }();
    WindowToggleSubscriber = /* @__PURE__ */ function(_super) {
      __extends(WindowToggleSubscriber2, _super);
      function WindowToggleSubscriber2(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
        return _this;
      }
      WindowToggleSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        if (contexts) {
          var len = contexts.length;
          for (var i5 = 0; i5 < len; i5++) {
            contexts[i5].window.next(value);
          }
        }
      };
      WindowToggleSubscriber2.prototype._error = function(err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_1 = contexts[index];
            context_1.window.error(err);
            context_1.subscription.unsubscribe();
          }
        }
        _super.prototype._error.call(this, err);
      };
      WindowToggleSubscriber2.prototype._complete = function() {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_2 = contexts[index];
            context_2.window.complete();
            context_2.subscription.unsubscribe();
          }
        }
        _super.prototype._complete.call(this);
      };
      WindowToggleSubscriber2.prototype._unsubscribe = function() {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_3 = contexts[index];
            context_3.window.unsubscribe();
            context_3.subscription.unsubscribe();
          }
        }
      };
      WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
          var closingNotifier = void 0;
          try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector(innerValue);
          } catch (e5) {
            return this.error(e5);
          }
          var window_1 = new Subject();
          var subscription = new Subscription();
          var context_4 = { window: window_1, subscription };
          this.contexts.push(context_4);
          var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
          if (innerSubscription.closed) {
            this.closeWindow(this.contexts.length - 1);
          } else {
            innerSubscription.context = context_4;
            subscription.add(innerSubscription);
          }
          this.destination.next(window_1);
        } else {
          this.closeWindow(this.contexts.indexOf(outerValue));
        }
      };
      WindowToggleSubscriber2.prototype.notifyError = function(err) {
        this.error(err);
      };
      WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
        if (inner !== this.openSubscription) {
          this.closeWindow(this.contexts.indexOf(inner.context));
        }
      };
      WindowToggleSubscriber2.prototype.closeWindow = function(index) {
        if (index === -1) {
          return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window3 = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window3.complete();
        subscription.unsubscribe();
      };
      return WindowToggleSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowWhen.js
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source) {
    return source.lift(new WindowOperator2(closingSelector));
  };
}
var WindowOperator2, WindowSubscriber2;
var init_windowWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowWhen.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_Subject();
    init_OuterSubscriber();
    init_subscribeToResult();
    WindowOperator2 = /* @__PURE__ */ function() {
      function WindowOperator3(closingSelector) {
        this.closingSelector = closingSelector;
      }
      WindowOperator3.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowSubscriber2(subscriber, this.closingSelector));
      };
      return WindowOperator3;
    }();
    WindowSubscriber2 = /* @__PURE__ */ function(_super) {
      __extends(WindowSubscriber3, _super);
      function WindowSubscriber3(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
      }
      WindowSubscriber3.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.openWindow(innerSub);
      };
      WindowSubscriber3.prototype.notifyError = function(error2) {
        this._error(error2);
      };
      WindowSubscriber3.prototype.notifyComplete = function(innerSub) {
        this.openWindow(innerSub);
      };
      WindowSubscriber3.prototype._next = function(value) {
        this.window.next(value);
      };
      WindowSubscriber3.prototype._error = function(err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
      };
      WindowSubscriber3.prototype._complete = function() {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
      };
      WindowSubscriber3.prototype.unsubscribeClosingNotification = function() {
        if (this.closingNotification) {
          this.closingNotification.unsubscribe();
        }
      };
      WindowSubscriber3.prototype.openWindow = function(innerSub) {
        if (innerSub === void 0) {
          innerSub = null;
        }
        if (innerSub) {
          this.remove(innerSub);
          innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
          prevWindow.complete();
        }
        var window3 = this.window = new Subject();
        this.destination.next(window3);
        var closingNotifier;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector();
        } catch (e5) {
          this.destination.error(e5);
          this.window.error(e5);
          return;
        }
        this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
      };
      return WindowSubscriber3;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(source) {
    var project;
    if (typeof args[args.length - 1] === "function") {
      project = args.pop();
    }
    var observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator, WithLatestFromSubscriber;
var init_withLatestFrom = __esm({
  "node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_modules();
    init_OuterSubscriber();
    init_subscribeToResult();
    WithLatestFromOperator = /* @__PURE__ */ function() {
      function WithLatestFromOperator2(observables, project) {
        this.observables = observables;
        this.project = project;
      }
      WithLatestFromOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
      };
      return WithLatestFromOperator2;
    }();
    WithLatestFromSubscriber = /* @__PURE__ */ function(_super) {
      __extends(WithLatestFromSubscriber2, _super);
      function WithLatestFromSubscriber2(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i5 = 0; i5 < len; i5++) {
          _this.toRespond.push(i5);
        }
        for (var i5 = 0; i5 < len; i5++) {
          var observable2 = observables[i5];
          _this.add(subscribeToResult(_this, observable2, void 0, i5));
        }
        return _this;
      }
      WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
          var found = toRespond.indexOf(outerIndex);
          if (found !== -1) {
            toRespond.splice(found, 1);
          }
        }
      };
      WithLatestFromSubscriber2.prototype.notifyComplete = function() {
      };
      WithLatestFromSubscriber2.prototype._next = function(value) {
        if (this.toRespond.length === 0) {
          var args = [value].concat(this.values);
          if (this.project) {
            this._tryProject(args);
          } else {
            this.destination.next(args);
          }
        }
      };
      WithLatestFromSubscriber2.prototype._tryProject = function(args) {
        var result;
        try {
          result = this.project.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return WithLatestFromSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/zip.js
function zip2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function zipOperatorFunction(source) {
    return source.lift.call(zip.apply(void 0, [source].concat(observables)));
  };
}
var init_zip2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/zip.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_zip();
  }
});

// node_modules/rxjs/_esm5/internal/operators/zipAll.js
function zipAll(project) {
  return function(source) {
    return source.lift(new ZipOperator(project));
  };
}
var init_zipAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/zipAll.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_zip();
  }
});

// node_modules/rxjs/_esm5/operators/index.js
var operators_exports = {};
__export(operators_exports, {
  audit: () => audit,
  auditTime: () => auditTime,
  buffer: () => buffer,
  bufferCount: () => bufferCount,
  bufferTime: () => bufferTime,
  bufferToggle: () => bufferToggle,
  bufferWhen: () => bufferWhen,
  catchError: () => catchError,
  combineAll: () => combineAll,
  combineLatest: () => combineLatest2,
  concat: () => concat4,
  concatAll: () => concatAll,
  concatMap: () => concatMap,
  concatMapTo: () => concatMapTo,
  count: () => count,
  debounce: () => debounce,
  debounceTime: () => debounceTime,
  defaultIfEmpty: () => defaultIfEmpty,
  delay: () => delay,
  delayWhen: () => delayWhen,
  dematerialize: () => dematerialize,
  distinct: () => distinct,
  distinctUntilChanged: () => distinctUntilChanged,
  distinctUntilKeyChanged: () => distinctUntilKeyChanged,
  elementAt: () => elementAt,
  endWith: () => endWith,
  every: () => every,
  exhaust: () => exhaust,
  exhaustMap: () => exhaustMap,
  expand: () => expand,
  filter: () => filter,
  finalize: () => finalize,
  find: () => find,
  findIndex: () => findIndex,
  first: () => first,
  flatMap: () => flatMap,
  groupBy: () => groupBy,
  ignoreElements: () => ignoreElements,
  isEmpty: () => isEmpty,
  last: () => last,
  map: () => map,
  mapTo: () => mapTo,
  materialize: () => materialize,
  max: () => max,
  merge: () => merge2,
  mergeAll: () => mergeAll,
  mergeMap: () => mergeMap,
  mergeMapTo: () => mergeMapTo,
  mergeScan: () => mergeScan,
  min: () => min,
  multicast: () => multicast,
  observeOn: () => observeOn,
  onErrorResumeNext: () => onErrorResumeNext2,
  pairwise: () => pairwise,
  partition: () => partition2,
  pluck: () => pluck,
  publish: () => publish,
  publishBehavior: () => publishBehavior,
  publishLast: () => publishLast,
  publishReplay: () => publishReplay,
  race: () => race2,
  reduce: () => reduce,
  refCount: () => refCount,
  repeat: () => repeat,
  repeatWhen: () => repeatWhen,
  retry: () => retry,
  retryWhen: () => retryWhen,
  sample: () => sample,
  sampleTime: () => sampleTime,
  scan: () => scan,
  sequenceEqual: () => sequenceEqual,
  share: () => share,
  shareReplay: () => shareReplay,
  single: () => single,
  skip: () => skip,
  skipLast: () => skipLast,
  skipUntil: () => skipUntil,
  skipWhile: () => skipWhile,
  startWith: () => startWith,
  subscribeOn: () => subscribeOn,
  switchAll: () => switchAll,
  switchMap: () => switchMap,
  switchMapTo: () => switchMapTo,
  take: () => take,
  takeLast: () => takeLast,
  takeUntil: () => takeUntil,
  takeWhile: () => takeWhile,
  tap: () => tap,
  throttle: () => throttle,
  throttleTime: () => throttleTime,
  throwIfEmpty: () => throwIfEmpty,
  timeInterval: () => timeInterval,
  timeout: () => timeout,
  timeoutWith: () => timeoutWith,
  timestamp: () => timestamp2,
  toArray: () => toArray,
  window: () => window2,
  windowCount: () => windowCount,
  windowTime: () => windowTime,
  windowToggle: () => windowToggle,
  windowWhen: () => windowWhen,
  withLatestFrom: () => withLatestFrom,
  zip: () => zip2,
  zipAll: () => zipAll
});
var init_operators = __esm({
  "node_modules/rxjs/_esm5/operators/index.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_audit();
    init_auditTime();
    init_buffer3();
    init_bufferCount();
    init_bufferTime();
    init_bufferToggle();
    init_bufferWhen();
    init_catchError();
    init_combineAll();
    init_combineLatest2();
    init_concat2();
    init_concatAll();
    init_concatMap();
    init_concatMapTo();
    init_count();
    init_debounce();
    init_debounceTime();
    init_defaultIfEmpty();
    init_delay();
    init_delayWhen();
    init_dematerialize();
    init_distinct();
    init_distinctUntilChanged();
    init_distinctUntilKeyChanged();
    init_elementAt();
    init_endWith();
    init_every();
    init_exhaust();
    init_exhaustMap();
    init_expand();
    init_filter();
    init_finalize();
    init_find();
    init_findIndex();
    init_first();
    init_groupBy();
    init_ignoreElements();
    init_isEmpty();
    init_last();
    init_map();
    init_mapTo();
    init_materialize();
    init_max();
    init_merge2();
    init_mergeAll();
    init_mergeMap();
    init_mergeMapTo();
    init_mergeScan();
    init_min();
    init_multicast();
    init_observeOn();
    init_onErrorResumeNext2();
    init_pairwise();
    init_partition2();
    init_pluck();
    init_publish();
    init_publishBehavior();
    init_publishLast();
    init_publishReplay();
    init_race2();
    init_reduce();
    init_repeat();
    init_repeatWhen();
    init_retry();
    init_retryWhen();
    init_refCount();
    init_sample();
    init_sampleTime();
    init_scan();
    init_sequenceEqual();
    init_share();
    init_shareReplay();
    init_single();
    init_skip();
    init_skipLast();
    init_skipUntil();
    init_skipWhile();
    init_startWith();
    init_subscribeOn();
    init_switchAll();
    init_switchMap();
    init_switchMapTo();
    init_take();
    init_takeLast();
    init_takeUntil();
    init_takeWhile();
    init_tap();
    init_throttle();
    init_throttleTime();
    init_throwIfEmpty();
    init_timeInterval();
    init_timeout();
    init_timeoutWith();
    init_timestamp();
    init_toArray();
    init_window();
    init_windowCount();
    init_windowTime();
    init_windowToggle();
    init_windowWhen();
    init_withLatestFrom();
    init_zip2();
    init_zipAll();
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice3 = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice3.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice3.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice3.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i5 = 0; i5 < boundLength; i5++) {
        boundArgs.push("$" + i5);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e5) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e5) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x5) {
      return x5.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn2 = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first2 = $strSlice(string, 0, 1);
      var last2 = $strSlice(string, -1);
      if (first2 === "%" && last2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last2 === "%" && first2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn2(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn2(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i5 = 1, isOwn = true; i5 < parts.length; i5 += 1) {
        var part = parts[i5];
        var first2 = $strSlice(part, 0, 1);
        var last2 = $strSlice(part, -1);
        if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn2(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i5 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn2(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e5) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util2 = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString2 = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O3) {
      return O3.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util2();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol2(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray5(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf4(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect4(value, from4, noIndent) {
        if (from4) {
          seen = $arrSlice.call(seen);
          seen.push(from4);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp2(obj)) {
        var name = nameOf(obj);
        var keys2 = arrObjKeys(obj, inspect4);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
      }
      if (isSymbol2(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s5 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i5 = 0; i5 < attrs.length; i5++) {
          s5 += " " + attrs[i5].name + "=" + wrapQuotes(quote(attrs[i5].value), "double", opts);
        }
        s5 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s5 += "...";
        }
        s5 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s5;
      }
      if (isArray5(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect4);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError2(obj)) {
        var parts = arrObjKeys(obj, inspect4);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect4(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect4(key, obj, true) + " => " + inspect4(value, obj));
        });
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function(value) {
          setParts.push(inspect4(value, obj));
        });
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber2(obj)) {
        return markBoxed(inspect4(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect4(bigIntValueOf.call(obj)));
      }
      if (isBoolean2(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString2(obj)) {
        return markBoxed(inspect4(String(obj)));
      }
      if (!isDate3(obj) && !isRegExp2(obj)) {
        var ys = arrObjKeys(obj, inspect4);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s5, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s5 + quoteChar;
    }
    function quote(s5) {
      return $replace.call(String(s5), /"/g, "&quot;");
    }
    function isArray5(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate3(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp2(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError2(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString2(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber2(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean2(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol2(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e5) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e5) {
      }
      return false;
    }
    var hasOwn2 = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn2.call(obj, key);
    }
    function toStr(obj) {
      return objectToString2.call(obj);
    }
    function nameOf(f5) {
      if (f5.name) {
        return f5.name;
      }
      var m5 = $match.call(functionToString.call(f5), /^function\s*([\w$]+)/);
      if (m5) {
        return m5[1];
      }
      return null;
    }
    function indexOf4(xs, x5) {
      if (xs.indexOf) {
        return xs.indexOf(x5);
      }
      for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
        if (xs[i5] === x5) {
          return i5;
        }
      }
      return -1;
    }
    function isMap(x5) {
      if (!mapSize || !x5 || typeof x5 !== "object") {
        return false;
      }
      try {
        mapSize.call(x5);
        try {
          setSize.call(x5);
        } catch (s5) {
          return true;
        }
        return x5 instanceof Map;
      } catch (e5) {
      }
      return false;
    }
    function isWeakMap(x5) {
      if (!weakMapHas || !x5 || typeof x5 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x5, weakMapHas);
        try {
          weakSetHas.call(x5, weakSetHas);
        } catch (s5) {
          return true;
        }
        return x5 instanceof WeakMap;
      } catch (e5) {
      }
      return false;
    }
    function isWeakRef(x5) {
      if (!weakRefDeref || !x5 || typeof x5 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x5);
        return true;
      } catch (e5) {
      }
      return false;
    }
    function isSet(x5) {
      if (!setSize || !x5 || typeof x5 !== "object") {
        return false;
      }
      try {
        setSize.call(x5);
        try {
          mapSize.call(x5);
        } catch (m5) {
          return true;
        }
        return x5 instanceof Set;
      } catch (e5) {
      }
      return false;
    }
    function isWeakSet(x5) {
      if (!weakSetHas || !x5 || typeof x5 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x5, weakSetHas);
        try {
          weakMapHas.call(x5, weakMapHas);
        } catch (s5) {
          return true;
        }
        return x5 instanceof WeakSet;
      } catch (e5) {
      }
      return false;
    }
    function isElement(x5) {
      if (!x5 || typeof x5 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x5 instanceof HTMLElement) {
        return true;
      }
      return typeof x5.nodeName === "string" && typeof x5.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s5 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s5, "single", opts);
    }
    function lowbyte(c5) {
      var n3 = c5.charCodeAt(0);
      var x5 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n3];
      if (x5) {
        return "\\" + x5;
      }
      return "\\x" + (n3 < 16 ? "0" : "") + $toUpperCase.call(n3.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type2) {
      return type2 + " { ? }";
    }
    function collectionOf(type2, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type2 + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i5 = 0; i5 < xs.length; i5++) {
        if (indexOf4(xs[i5], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect4) {
      var isArr = isArray5(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i5 = 0; i5 < obj.length; i5++) {
          xs[i5] = has(obj, i5) ? inspect4(obj[i5], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k5 = 0; k5 < syms.length; k5++) {
          symMap["$" + syms[k5]] = syms[k5];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect4(key, obj) + ": " + inspect4(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect4(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j5 = 0; j5 < syms.length; j5++) {
          if (isEnumerable.call(obj, syms[j5])) {
            xs.push("[" + inspect4(syms[j5]) + "]: " + inspect4(obj[syms[j5]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect4 = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect4(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray5 = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i5 = 0; i5 < 256; ++i5) {
        array.push("%" + ((i5 < 16 ? "0" : "") + i5.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue4) {
      while (queue4.length > 1) {
        var item = queue4.pop();
        var obj = item.obj[item.prop];
        if (isArray5(obj)) {
          var compacted = [];
          for (var j5 = 0; j5 < obj.length; ++j5) {
            if (typeof obj[j5] !== "undefined") {
              compacted.push(obj[j5]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i5 = 0; i5 < source.length; ++i5) {
        if (typeof source[i5] !== "undefined") {
          obj[i5] = source[i5];
        }
      }
      return obj;
    };
    var merge3 = function merge4(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray5(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray5(target) && !isArray5(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray5(target) && isArray5(source)) {
        source.forEach(function(item, i5) {
          if (has.call(target, i5)) {
            var targetItem = target[i5];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i5] = merge4(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i5] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge4(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e5) {
        return strWithoutPlus;
      }
    };
    var encode2 = function encode3(str, defaultEncoder, charset, kind, format3) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i5 = 0; i5 < string.length; ++i5) {
        var c5 = string.charCodeAt(i5);
        if (c5 === 45 || c5 === 46 || c5 === 95 || c5 === 126 || c5 >= 48 && c5 <= 57 || c5 >= 65 && c5 <= 90 || c5 >= 97 && c5 <= 122 || format3 === formats.RFC1738 && (c5 === 40 || c5 === 41)) {
          out += string.charAt(i5);
          continue;
        }
        if (c5 < 128) {
          out = out + hexTable[c5];
          continue;
        }
        if (c5 < 2048) {
          out = out + (hexTable[192 | c5 >> 6] + hexTable[128 | c5 & 63]);
          continue;
        }
        if (c5 < 55296 || c5 >= 57344) {
          out = out + (hexTable[224 | c5 >> 12] + hexTable[128 | c5 >> 6 & 63] + hexTable[128 | c5 & 63]);
          continue;
        }
        i5 += 1;
        c5 = 65536 + ((c5 & 1023) << 10 | string.charCodeAt(i5) & 1023);
        out += hexTable[240 | c5 >> 18] + hexTable[128 | c5 >> 12 & 63] + hexTable[128 | c5 >> 6 & 63] + hexTable[128 | c5 & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue4 = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i5 = 0; i5 < queue4.length; ++i5) {
        var item = queue4[i5];
        var obj = item.obj[item.prop];
        var keys2 = Object.keys(obj);
        for (var j5 = 0; j5 < keys2.length; ++j5) {
          var key = keys2[j5];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue4.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue4);
      return value;
    };
    var isRegExp2 = function isRegExp3(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer5 = function isBuffer6(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a5, b4) {
      return [].concat(a5, b4);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray5(val)) {
        var mapped = [];
        for (var i5 = 0; i5 < val.length; i5 += 1) {
          mapped.push(fn(val[i5]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode: encode2,
      isBuffer: isBuffer5,
      isRegExp: isRegExp2,
      maybeMap,
      merge: merge3
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var getSideChannel = require_side_channel();
    var utils = require_utils6();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat2(prefix) {
        return prefix;
      }
    };
    var isArray5 = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray5(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v5) {
      return typeof v5 === "string" || typeof v5 === "number" || typeof v5 === "boolean" || typeof v5 === "symbol" || typeof v5 === "bigint";
    };
    var sentinel = {};
    var stringify3 = function stringify4(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter2, sort, allowDots, serializeDate, format3, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter2 === "function") {
        obj = filter2(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray5(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format3) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format3);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i5 = 0; i5 < valuesArray.length; ++i5) {
              valuesJoined += (i5 === 0 ? "" : ",") + formatter(encoder(valuesArray[i5], defaults.encoder, charset, "value", format3));
            }
            return [formatter(keyValue) + (commaRoundTrip && isArray5(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
          }
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format3))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray5(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray5(filter2)) {
        objKeys = filter2;
      } else {
        var keys2 = Object.keys(obj);
        objKeys = sort ? keys2.sort(sort) : keys2;
      }
      var adjustedPrefix = commaRoundTrip && isArray5(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j5 = 0; j5 < objKeys.length; ++j5) {
        var key = objKeys[j5];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray5(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify4(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          encoder,
          filter2,
          sort,
          allowDots,
          serializeDate,
          format3,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format3 = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format3 = opts.format;
      }
      var formatter = formats.formatters[format3];
      var filter2 = defaults.filter;
      if (typeof opts.filter === "function" || isArray5(opts.filter)) {
        filter2 = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter2,
        format: format3,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter2;
      if (typeof options.filter === "function") {
        filter2 = options.filter;
        obj = filter2("", obj);
      } else if (isArray5(options.filter)) {
        filter2 = options.filter;
        objKeys = filter2;
      }
      var keys2 = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i5 = 0; i5 < objKeys.length; ++i5) {
        var key = objKeys[i5];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys2, stringify3(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys2.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils6();
    var has = Object.prototype.hasOwnProperty;
    var isArray5 = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i5;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i5 = 0; i5 < parts.length; ++i5) {
          if (parts[i5].indexOf("utf8=") === 0) {
            if (parts[i5] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i5] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i5;
            i5 = parts.length;
          }
        }
      }
      for (i5 = 0; i5 < parts.length; ++i5) {
        if (i5 === skipIndex) {
          continue;
        }
        var part = parts[i5];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray5(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i5 = chain.length - 1; i5 >= 0; --i5) {
        var obj;
        var root = chain[i5];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys2 = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(parent);
      }
      var i5 = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i5 < options.depth) {
        i5 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(segment[1]);
      }
      if (segment) {
        keys2.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys2, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys2 = Object.keys(tempObj);
      for (var i5 = 0; i5 < keys2.length; ++i5) {
        var key = keys2[i5];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var stringify3 = require_stringify();
    var parse4 = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse: parse4,
      stringify: stringify3
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/types.js
var require_types = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/types.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProviderType = exports.RegExpString = exports.IntNumber = exports.BigIntString = exports.AddressString = exports.HexString = exports.OpaqueType = void 0;
    function OpaqueType() {
      return (value) => value;
    }
    exports.OpaqueType = OpaqueType;
    exports.HexString = OpaqueType();
    exports.AddressString = OpaqueType();
    exports.BigIntString = OpaqueType();
    function IntNumber(num) {
      return Math.floor(num);
    }
    exports.IntNumber = IntNumber;
    exports.RegExpString = OpaqueType();
    var ProviderType;
    (function(ProviderType2) {
      ProviderType2["CoinbaseWallet"] = "CoinbaseWallet";
      ProviderType2["MetaMask"] = "MetaMask";
      ProviderType2["Unselected"] = "";
    })(ProviderType = exports.ProviderType || (exports.ProviderType = {}));
  }
});

// node_modules/@coinbase/wallet-sdk/dist/util.js
var require_util3 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/util.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isInIFrame = exports.createQrUrl = exports.getFavicon = exports.range = exports.isBigNumber = exports.ensureParsedJSONObject = exports.ensureBN = exports.ensureRegExpString = exports.ensureIntNumber = exports.ensureBuffer = exports.ensureAddressString = exports.ensureEvenLengthHexString = exports.ensureHexString = exports.isHexString = exports.prepend0x = exports.strip0x = exports.has0xPrefix = exports.hexStringFromIntNumber = exports.intNumberFromHexString = exports.bigIntStringFromBN = exports.hexStringFromBuffer = exports.hexStringToUint8Array = exports.uint8ArrayToHex = exports.randomBytesHex = void 0;
    var bn_js_1 = __importDefault2(require_bn3());
    var qs_1 = require_lib();
    var types_1 = require_types();
    var INT_STRING_REGEX = /^[0-9]*$/;
    var HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
    function randomBytesHex(length) {
      return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length)));
    }
    exports.randomBytesHex = randomBytesHex;
    function uint8ArrayToHex(value) {
      return [...value].map((b4) => b4.toString(16).padStart(2, "0")).join("");
    }
    exports.uint8ArrayToHex = uint8ArrayToHex;
    function hexStringToUint8Array(hexString) {
      return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
    }
    exports.hexStringToUint8Array = hexStringToUint8Array;
    function hexStringFromBuffer(buf, includePrefix = false) {
      const hex = buf.toString("hex");
      return (0, types_1.HexString)(includePrefix ? "0x" + hex : hex);
    }
    exports.hexStringFromBuffer = hexStringFromBuffer;
    function bigIntStringFromBN(bn) {
      return (0, types_1.BigIntString)(bn.toString(10));
    }
    exports.bigIntStringFromBN = bigIntStringFromBN;
    function intNumberFromHexString(hex) {
      return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(hex, false), 16).toNumber());
    }
    exports.intNumberFromHexString = intNumberFromHexString;
    function hexStringFromIntNumber(num) {
      return (0, types_1.HexString)("0x" + new bn_js_1.default(num).toString(16));
    }
    exports.hexStringFromIntNumber = hexStringFromIntNumber;
    function has0xPrefix(str) {
      return str.startsWith("0x") || str.startsWith("0X");
    }
    exports.has0xPrefix = has0xPrefix;
    function strip0x(hex) {
      if (has0xPrefix(hex)) {
        return hex.slice(2);
      }
      return hex;
    }
    exports.strip0x = strip0x;
    function prepend0x(hex) {
      if (has0xPrefix(hex)) {
        return "0x" + hex.slice(2);
      }
      return "0x" + hex;
    }
    exports.prepend0x = prepend0x;
    function isHexString3(hex) {
      if (typeof hex !== "string") {
        return false;
      }
      const s5 = strip0x(hex).toLowerCase();
      return HEXADECIMAL_STRING_REGEX.test(s5);
    }
    exports.isHexString = isHexString3;
    function ensureHexString(hex, includePrefix = false) {
      if (typeof hex === "string") {
        const s5 = strip0x(hex).toLowerCase();
        if (HEXADECIMAL_STRING_REGEX.test(s5)) {
          return (0, types_1.HexString)(includePrefix ? "0x" + s5 : s5);
        }
      }
      throw new Error(`"${String(hex)}" is not a hexadecimal string`);
    }
    exports.ensureHexString = ensureHexString;
    function ensureEvenLengthHexString(hex, includePrefix = false) {
      let h5 = ensureHexString(hex, false);
      if (h5.length % 2 === 1) {
        h5 = (0, types_1.HexString)("0" + h5);
      }
      return includePrefix ? (0, types_1.HexString)("0x" + h5) : h5;
    }
    exports.ensureEvenLengthHexString = ensureEvenLengthHexString;
    function ensureAddressString(str) {
      if (typeof str === "string") {
        const s5 = strip0x(str).toLowerCase();
        if (isHexString3(s5) && s5.length === 40) {
          return (0, types_1.AddressString)(prepend0x(s5));
        }
      }
      throw new Error(`Invalid Ethereum address: ${String(str)}`);
    }
    exports.ensureAddressString = ensureAddressString;
    function ensureBuffer(str) {
      if (Buffer2.isBuffer(str)) {
        return str;
      }
      if (typeof str === "string") {
        if (isHexString3(str)) {
          const s5 = ensureEvenLengthHexString(str, false);
          return Buffer2.from(s5, "hex");
        } else {
          return Buffer2.from(str, "utf8");
        }
      }
      throw new Error(`Not binary data: ${String(str)}`);
    }
    exports.ensureBuffer = ensureBuffer;
    function ensureIntNumber(num) {
      if (typeof num === "number" && Number.isInteger(num)) {
        return (0, types_1.IntNumber)(num);
      }
      if (typeof num === "string") {
        if (INT_STRING_REGEX.test(num)) {
          return (0, types_1.IntNumber)(Number(num));
        }
        if (isHexString3(num)) {
          return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(num, false), 16).toNumber());
        }
      }
      throw new Error(`Not an integer: ${String(num)}`);
    }
    exports.ensureIntNumber = ensureIntNumber;
    function ensureRegExpString(regExp) {
      if (regExp instanceof RegExp) {
        return (0, types_1.RegExpString)(regExp.toString());
      }
      throw new Error(`Not a RegExp: ${String(regExp)}`);
    }
    exports.ensureRegExpString = ensureRegExpString;
    function ensureBN(val) {
      if (val !== null && (bn_js_1.default.isBN(val) || isBigNumber(val))) {
        return new bn_js_1.default(val.toString(10), 10);
      }
      if (typeof val === "number") {
        return new bn_js_1.default(ensureIntNumber(val));
      }
      if (typeof val === "string") {
        if (INT_STRING_REGEX.test(val)) {
          return new bn_js_1.default(val, 10);
        }
        if (isHexString3(val)) {
          return new bn_js_1.default(ensureEvenLengthHexString(val, false), 16);
        }
      }
      throw new Error(`Not an integer: ${String(val)}`);
    }
    exports.ensureBN = ensureBN;
    function ensureParsedJSONObject(val) {
      if (typeof val === "string") {
        return JSON.parse(val);
      }
      if (typeof val === "object") {
        return val;
      }
      throw new Error(`Not a JSON string or an object: ${String(val)}`);
    }
    exports.ensureParsedJSONObject = ensureParsedJSONObject;
    function isBigNumber(val) {
      if (val == null || typeof val.constructor !== "function") {
        return false;
      }
      const { constructor } = val;
      return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
    }
    exports.isBigNumber = isBigNumber;
    function range2(start, stop) {
      return Array.from({ length: stop - start }, (_6, i5) => start + i5);
    }
    exports.range = range2;
    function getFavicon() {
      const el = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');
      const { protocol, host } = document.location;
      const href = el ? el.getAttribute("href") : null;
      if (!href || href.startsWith("javascript:")) {
        return null;
      }
      if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("data:")) {
        return href;
      }
      if (href.startsWith("//")) {
        return protocol + href;
      }
      return `${protocol}//${host}${href}`;
    }
    exports.getFavicon = getFavicon;
    function createQrUrl(sessionId, sessionSecret, serverUrl, isParentConnection, version3, chainId) {
      const sessionIdKey = isParentConnection ? "parent-id" : "id";
      const query = (0, qs_1.stringify)({
        [sessionIdKey]: sessionId,
        secret: sessionSecret,
        server: serverUrl,
        v: version3,
        chainId
      });
      const qrUrl = `${serverUrl}/#/link?${query}`;
      return qrUrl;
    }
    exports.createQrUrl = createQrUrl;
    function isInIFrame() {
      try {
        return window.frameElement !== null;
      } catch (e5) {
        return false;
      }
    }
    exports.isInIFrame = isInIFrame;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Session.js
var require_Session = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Session.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Session = void 0;
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var sha_js_1 = require_sha2();
    var util_1 = require_util3();
    var STORAGE_KEY_SESSION_ID = "session:id";
    var STORAGE_KEY_SESSION_SECRET = "session:secret";
    var STORAGE_KEY_SESSION_LINKED = "session:linked";
    var Session = class {
      constructor(storage, id, secret, linked) {
        this._storage = storage;
        this._id = id || (0, util_1.randomBytesHex)(16);
        this._secret = secret || (0, util_1.randomBytesHex)(32);
        this._key = new sha_js_1.sha256().update(`${this._id}, ${this._secret} WalletLink`).digest("hex");
        this._linked = !!linked;
      }
      static load(storage) {
        const id = storage.getItem(STORAGE_KEY_SESSION_ID);
        const linked = storage.getItem(STORAGE_KEY_SESSION_LINKED);
        const secret = storage.getItem(STORAGE_KEY_SESSION_SECRET);
        if (id && secret) {
          return new Session(storage, id, secret, linked === "1");
        }
        return null;
      }
      static get persistedSessionIdChange$() {
        return (0, rxjs_1.fromEvent)(window, "storage").pipe((0, operators_1.filter)((evt) => evt.key === STORAGE_KEY_SESSION_ID), (0, operators_1.map)((evt) => ({
          oldValue: evt.oldValue || null,
          newValue: evt.newValue || null
        })));
      }
      static hash(sessionId) {
        return new sha_js_1.sha256().update(sessionId).digest("hex");
      }
      get id() {
        return this._id;
      }
      get secret() {
        return this._secret;
      }
      get key() {
        return this._key;
      }
      get linked() {
        return this._linked;
      }
      set linked(val) {
        this._linked = val;
        this.persistLinked();
      }
      save() {
        this._storage.setItem(STORAGE_KEY_SESSION_ID, this._id);
        this._storage.setItem(STORAGE_KEY_SESSION_SECRET, this._secret);
        this.persistLinked();
        return this;
      }
      persistLinked() {
        this._storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
      }
    };
    exports.Session = Session;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayAbstract.js
var require_WalletSDKRelayAbstract = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayAbstract.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKRelayAbstract = exports.APP_VERSION_KEY = exports.LOCAL_STORAGE_ADDRESSES_KEY = exports.WALLET_USER_NAME_KEY = void 0;
    var eth_rpc_errors_1 = require_dist();
    exports.WALLET_USER_NAME_KEY = "walletUsername";
    exports.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
    exports.APP_VERSION_KEY = "AppVersion";
    var WalletSDKRelayAbstract = class {
      async makeEthereumJSONRPCRequest(request3, jsonRpcUrl) {
        if (!jsonRpcUrl)
          throw new Error("Error: No jsonRpcUrl provided");
        return window.fetch(jsonRpcUrl, {
          method: "POST",
          body: JSON.stringify(request3),
          mode: "cors",
          headers: { "Content-Type": "application/json" }
        }).then((res) => res.json()).then((json) => {
          if (!json) {
            throw eth_rpc_errors_1.ethErrors.rpc.parse({});
          }
          const response = json;
          const { error: error2 } = response;
          if (error2) {
            throw (0, eth_rpc_errors_1.serializeError)(error2);
          }
          return response;
        });
      }
    };
    exports.WalletSDKRelayAbstract = WalletSDKRelayAbstract;
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        var source = arguments[i5] != null ? arguments[i5] : {};
        if (i5 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require_buffer();
    var Buffer4 = _require.Buffer;
    var _require2 = require_util();
    var inspect4 = _require2.inspect;
    var custom = inspect4 && inspect4.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer4.prototype.copy.call(src, target, offset);
    }
    module.exports = /* @__PURE__ */ function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList2, [{
        key: "push",
        value: function push(v5) {
          var entry = {
            data: v5,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v5) {
          var entry = {
            data: v5,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s5) {
          if (this.length === 0)
            return "";
          var p5 = this.head;
          var ret = "" + p5.data;
          while (p5 = p5.next) {
            ret += s5 + p5.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat5(n3) {
          if (this.length === 0)
            return Buffer4.alloc(0);
          var ret = Buffer4.allocUnsafe(n3 >>> 0);
          var p5 = this.head;
          var i5 = 0;
          while (p5) {
            copyBuffer(p5.data, ret, i5);
            i5 += p5.data.length;
            p5 = p5.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n3, hasStrings) {
          var ret;
          if (n3 < this.head.data.length) {
            ret = this.head.data.slice(0, n3);
            this.head.data = this.head.data.slice(n3);
          } else if (n3 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n3) : this._getBuffer(n3);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n3) {
          var p5 = this.head;
          var c5 = 1;
          var ret = p5.data;
          n3 -= ret.length;
          while (p5 = p5.next) {
            var str = p5.data;
            var nb = n3 > str.length ? str.length : n3;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n3);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === str.length) {
                ++c5;
                if (p5.next)
                  this.head = p5.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = str.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n3) {
          var ret = Buffer4.allocUnsafe(n3);
          var p5 = this.head;
          var c5 = 1;
          p5.data.copy(ret);
          n3 -= p5.data.length;
          while (p5 = p5.next) {
            var buf = p5.data;
            var nb = n3 > buf.length ? buf.length : n3;
            buf.copy(ret, ret.length - n3, 0, nb);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === buf.length) {
                ++c5;
                if (p5.next)
                  this.head = p5.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = buf.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_6, options) {
          return inspect4(this, _objectSpread({}, options, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList2;
    }();
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/keccak/node_modules/readable-stream/errors-browser.js
var require_errors_browser3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage2(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage2(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i5) {
          return String(i5);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes3(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type2 = includes3(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/internal/streams/state.js
var require_state3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ERR_INVALID_OPT_VALUE = require_errors_browser3().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Writable2;
    function CorkedRequest2(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex2;
    Writable2.WritableState = WritableState2;
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream2 = require_stream_browser3();
    var Buffer4 = require_buffer().Buffer;
    var OurUint8Array = globalThis.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy3();
    var _require = require_state3();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable2, Stream2);
    function nop2() {
    }
    function WritableState2(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex3();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite2(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest2(this);
    }
    WritableState2.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState2.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_6) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable2)
            return false;
          return object && object._writableState instanceof WritableState2;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable2(options) {
      Duplex2 = Duplex2 || require_stream_duplex3();
      var isDuplex = this instanceof Duplex2;
      if (!isDuplex && !realHasInstance.call(Writable2, this))
        return new Writable2(options);
      this._writableState = new WritableState2(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd2(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk2(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer4.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop2;
      if (state.ending)
        writeAfterEnd2(this, cb);
      else if (isBuf || validChunk2(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer2(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk2(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer4.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk2(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite2(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError2(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe2, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe2(stream, state);
      }
    }
    function onwriteStateUpdate2(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite2(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate2(state);
      if (er)
        onwriteError2(stream, state, sync, er, cb);
      else {
        var finished = needFinish2(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer2(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite2, stream, state, finished, cb);
        } else {
          afterWrite2(stream, state, finished, cb);
        }
      }
    }
    function afterWrite2(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain2(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe2(stream, state);
    }
    function onwriteDrain2(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer2(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l5 = state.bufferedRequestCount;
        var buffer2 = new Array(l5);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count2 = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count2] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count2 += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite2(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest2(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite2(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable2(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function needFinish2(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe2(stream, state);
      });
    }
    function prefinish2(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe2(stream, state) {
      var need = needFinish2(state);
      if (need) {
        prefinish2(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable2(stream, state, cb) {
      state.ending = true;
      finishMaybe2(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var objectKeys3 = Object.keys || function(obj) {
      var keys3 = [];
      for (var key in obj) {
        keys3.push(key);
      }
      return keys3;
    };
    module.exports = Duplex2;
    var Readable2 = require_stream_readable3();
    var Writable2 = require_stream_writable3();
    require_inherits_browser()(Duplex2, Readable2);
    {
      keys2 = objectKeys3(Writable2.prototype);
      for (v5 = 0; v5 < keys2.length; v5++) {
        method = keys2[v5];
        if (!Duplex2.prototype[method])
          Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    var keys2;
    var method;
    var v5;
    function Duplex2(options) {
      if (!(this instanceof Duplex2))
        return new Duplex2(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend2);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function onend2() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT2, this);
    }
    function onEndNT2(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser3().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once4(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop4() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once4(callback || noop4);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend2 = function onend3() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend2);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend2);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream3();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done2) {
      return {
        value,
        done: done2
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error2 = this[kError];
        if (error2 !== null) {
          return Promise.reject(error2);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator2[kStream].read();
          if (data) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator2[kLastResolve] = resolve;
            iterator2[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator2[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator2[kLastReject];
          if (reject !== null) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            reject(err);
          }
          iterator2[kError] = err;
          return;
        }
        var resolve = iterator2[kLastResolve];
        if (resolve !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator2[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator2));
      return iterator2;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Readable2;
    var Duplex2;
    Readable2.ReadableState = ReadableState2;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type2) {
      return emitter.listeners(type2).length;
    };
    var Stream2 = require_stream_browser3();
    var Buffer4 = require_buffer().Buffer;
    var OurUint8Array = globalThis.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug2;
    if (debugUtil && debugUtil.debuglog) {
      debug2 = debugUtil.debuglog("stream");
    } else {
      debug2 = function debug3() {
      };
    }
    var BufferList2 = require_buffer_list3();
    var destroyImpl = require_destroy3();
    var _require = require_state3();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder2;
    var createReadableStreamAsyncIterator;
    var from4;
    require_inherits_browser()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener3(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState2(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex3();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList2();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder2(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex2 = Duplex2 || require_stream_duplex3();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      var isDuplex = this instanceof Duplex2;
      this._readableState = new ReadableState2(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer4.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk2(this, chunk, null, true, false);
    };
    function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug2("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk2(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid2(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore2(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore2(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable2(stream);
      }
      maybeReadMore2(stream, state);
    }
    function chunkInvalid2(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder2)
        StringDecoder2 = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder2(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p5 = this._readableState.buffer.head;
      var content = "";
      while (p5 !== null) {
        content += decoder.write(p5.data);
        p5 = p5.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM2 = 1073741824;
    function computeNewHighWaterMark2(n3) {
      if (n3 >= MAX_HWM2) {
        n3 = MAX_HWM2;
      } else {
        n3--;
        n3 |= n3 >>> 1;
        n3 |= n3 >>> 2;
        n3 |= n3 >>> 4;
        n3 |= n3 >>> 8;
        n3 |= n3 >>> 16;
        n3++;
      }
      return n3;
    }
    function howMuchToRead2(n3, state) {
      if (n3 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n3 !== n3) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n3 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark2(n3);
      if (n3 <= state.length)
        return n3;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n3) {
      debug2("read", n3);
      n3 = parseInt(n3, 10);
      var state = this._readableState;
      var nOrig = n3;
      if (n3 !== 0)
        state.emittedReadable = false;
      if (n3 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug2("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable2(this);
        else
          emitReadable2(this);
        return null;
      }
      n3 = howMuchToRead2(n3, state);
      if (n3 === 0 && state.ended) {
        if (state.length === 0)
          endReadable2(this);
        return null;
      }
      var doRead = state.needReadable;
      debug2("need readable", doRead);
      if (state.length === 0 || state.length - n3 < state.highWaterMark) {
        doRead = true;
        debug2("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug2("reading or ended", doRead);
      } else if (doRead) {
        debug2("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n3 = howMuchToRead2(nOrig, state);
      }
      var ret;
      if (n3 > 0)
        ret = fromList2(n3, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n3 = 0;
      } else {
        state.length -= n3;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n3 && state.ended)
          endReadable2(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk2(stream, state) {
      debug2("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable2(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_2(stream);
        }
      }
    }
    function emitReadable2(stream) {
      var state = stream._readableState;
      debug2("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug2("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_2, stream);
      }
    }
    function emitReadable_2(stream) {
      var state = stream._readableState;
      debug2("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow2(stream);
    }
    function maybeReadMore2(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_2, stream, state);
      }
    }
    function maybeReadMore_2(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug2("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n3) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend2 : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug2("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend2() {
        debug2("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain2(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug2("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        var ret = dest.write(chunk);
        debug2("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf4(state.pipes, dest) !== -1) && !cleanedUp) {
            debug2("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug2("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener3(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug2("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain2(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug2("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow2(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i5 = 0; i5 < len; i5++) {
          dests[i5].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf4(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug2("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable2(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick2, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick2(self2) {
      debug2("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug2("resume");
        state.flowing = !state.readableListening;
        resume2(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume2(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_2, stream, state);
      }
    }
    function resume_2(stream, state) {
      debug2("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow2(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug2("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug2("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow2(stream) {
      var state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug2("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug2("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i5 in stream) {
        if (this[i5] === void 0 && typeof stream[i5] === "function") {
          this[i5] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i5);
        }
      }
      for (var n3 = 0; n3 < kProxyEvents.length; n3++) {
        stream.on(kProxyEvents[n3], this.emit.bind(this, kProxyEvents[n3]));
      }
      this._read = function(n4) {
        debug2("wrapped _read", n4);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator3();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      enumerable: false,
      get: function get3() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList2;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      enumerable: false,
      get: function get3() {
        return this._readableState.length;
      }
    });
    function fromList2(n3, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n3 || n3 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n3, state.decoder);
      }
      return ret;
    }
    function endReadable2(stream) {
      var state = stream._readableState;
      debug2("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT2, state, stream);
      }
    }
    function endReadableNT2(state, stream) {
      debug2("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from4 === void 0) {
          from4 = require_from_browser3();
        }
        return from4(Readable2, iterable, opts);
      };
    }
    function indexOf4(xs, x5) {
      for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
        if (xs[i5] === x5)
          return i5;
      }
      return -1;
    }
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Transform2;
    var _require$codes = require_errors_browser3().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex2 = require_stream_duplex3();
    require_inherits_browser()(Transform2, Duplex2);
    function afterTransform2(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex2.call(this, options);
      this._transformState = {
        afterTransform: afterTransform2.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish2);
    }
    function prefinish2() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done2(_this, er, data);
        });
      } else {
        done2(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex2.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n3) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex2.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done2(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = PassThrough2;
    var Transform2 = require_stream_transform3();
    require_inherits_browser()(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/keccak/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var eos;
    function once4(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser3().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop4(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once4(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream3();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe2(from4, to) {
      return from4.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop4;
      if (typeof streams[streams.length - 1] !== "function")
        return noop4;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error2;
      var destroys = streams.map(function(stream, i5) {
        var reading = i5 < streams.length - 1;
        var writing = i5 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error2)
            error2 = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error2);
        });
      });
      return streams.reduce(pipe2);
    }
    module.exports = pipeline;
  }
});

// node_modules/keccak/node_modules/readable-stream/readable-browser.js
var require_readable_browser3 = __commonJS({
  "node_modules/keccak/node_modules/readable-stream/readable-browser.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports = module.exports = require_stream_readable3();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable3();
    exports.Duplex = require_stream_duplex3();
    exports.Transform = require_stream_transform3();
    exports.PassThrough = require_stream_passthrough3();
    exports.finished = require_end_of_stream3();
    exports.pipeline = require_pipeline3();
  }
});

// node_modules/keccak/lib/api/keccak.js
var require_keccak = __commonJS({
  "node_modules/keccak/lib/api/keccak.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var { Transform: Transform2 } = require_readable_browser3();
    module.exports = (KeccakState) => class Keccak extends Transform2 {
      constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error2 = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error2 = err;
        }
        callback(error2);
      }
      _flush(callback) {
        let error2 = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error2 = err;
        }
        callback(error2);
      }
      update(data, encoding) {
        if (!Buffer2.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer2.isBuffer(data))
          data = Buffer2.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      digest(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        if (this._delimitedSuffix)
          this._state.absorbLastFewBits(this._delimitedSuffix);
        let digest = this._state.squeeze(this._hashBitLength / 8);
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._resetState();
        return digest;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/shake.js
var require_shake = __commonJS({
  "node_modules/keccak/lib/api/shake.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var { Transform: Transform2 } = require_readable_browser3();
    module.exports = (KeccakState) => class Shake extends Transform2 {
      constructor(rate, capacity, delimitedSuffix, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error2 = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error2 = err;
        }
        callback(error2);
      }
      _flush() {
      }
      _read(size) {
        this.push(this.squeeze(size));
      }
      update(data, encoding) {
        if (!Buffer2.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Squeeze already called");
        if (!Buffer2.isBuffer(data))
          data = Buffer2.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      squeeze(dataByteLength, encoding) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }
        let data = this._state.squeeze(dataByteLength);
        if (encoding !== void 0)
          data = data.toString(encoding);
        return data;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/index.js
var require_api2 = __commonJS({
  "node_modules/keccak/lib/api/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var createKeccak = require_keccak();
    var createShake = require_shake();
    module.exports = function(KeccakState) {
      const Keccak = createKeccak(KeccakState);
      const Shake = createShake(KeccakState);
      return function(algorithm, options) {
        const hash = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
        switch (hash) {
          case "keccak224":
            return new Keccak(1152, 448, null, 224, options);
          case "keccak256":
            return new Keccak(1088, 512, null, 256, options);
          case "keccak384":
            return new Keccak(832, 768, null, 384, options);
          case "keccak512":
            return new Keccak(576, 1024, null, 512, options);
          case "sha3-224":
            return new Keccak(1152, 448, 6, 224, options);
          case "sha3-256":
            return new Keccak(1088, 512, 6, 256, options);
          case "sha3-384":
            return new Keccak(832, 768, 6, 384, options);
          case "sha3-512":
            return new Keccak(576, 1024, 6, 512, options);
          case "shake128":
            return new Shake(1344, 256, 31, options);
          case "shake256":
            return new Shake(1088, 512, 31, options);
          default:
            throw new Error("Invald algorithm: " + algorithm);
        }
      };
    };
  }
});

// node_modules/keccak/lib/keccak-state-unroll.js
var require_keccak_state_unroll = __commonJS({
  "node_modules/keccak/lib/keccak-state-unroll.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports.p1600 = function(s5) {
      for (let round = 0; round < 24; ++round) {
        const lo0 = s5[0] ^ s5[10] ^ s5[20] ^ s5[30] ^ s5[40];
        const hi0 = s5[1] ^ s5[11] ^ s5[21] ^ s5[31] ^ s5[41];
        const lo1 = s5[2] ^ s5[12] ^ s5[22] ^ s5[32] ^ s5[42];
        const hi1 = s5[3] ^ s5[13] ^ s5[23] ^ s5[33] ^ s5[43];
        const lo2 = s5[4] ^ s5[14] ^ s5[24] ^ s5[34] ^ s5[44];
        const hi2 = s5[5] ^ s5[15] ^ s5[25] ^ s5[35] ^ s5[45];
        const lo3 = s5[6] ^ s5[16] ^ s5[26] ^ s5[36] ^ s5[46];
        const hi3 = s5[7] ^ s5[17] ^ s5[27] ^ s5[37] ^ s5[47];
        const lo4 = s5[8] ^ s5[18] ^ s5[28] ^ s5[38] ^ s5[48];
        const hi4 = s5[9] ^ s5[19] ^ s5[29] ^ s5[39] ^ s5[49];
        let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        const t1slo0 = s5[0] ^ lo;
        const t1shi0 = s5[1] ^ hi;
        const t1slo5 = s5[10] ^ lo;
        const t1shi5 = s5[11] ^ hi;
        const t1slo10 = s5[20] ^ lo;
        const t1shi10 = s5[21] ^ hi;
        const t1slo15 = s5[30] ^ lo;
        const t1shi15 = s5[31] ^ hi;
        const t1slo20 = s5[40] ^ lo;
        const t1shi20 = s5[41] ^ hi;
        lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        const t1slo1 = s5[2] ^ lo;
        const t1shi1 = s5[3] ^ hi;
        const t1slo6 = s5[12] ^ lo;
        const t1shi6 = s5[13] ^ hi;
        const t1slo11 = s5[22] ^ lo;
        const t1shi11 = s5[23] ^ hi;
        const t1slo16 = s5[32] ^ lo;
        const t1shi16 = s5[33] ^ hi;
        const t1slo21 = s5[42] ^ lo;
        const t1shi21 = s5[43] ^ hi;
        lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        const t1slo2 = s5[4] ^ lo;
        const t1shi2 = s5[5] ^ hi;
        const t1slo7 = s5[14] ^ lo;
        const t1shi7 = s5[15] ^ hi;
        const t1slo12 = s5[24] ^ lo;
        const t1shi12 = s5[25] ^ hi;
        const t1slo17 = s5[34] ^ lo;
        const t1shi17 = s5[35] ^ hi;
        const t1slo22 = s5[44] ^ lo;
        const t1shi22 = s5[45] ^ hi;
        lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        const t1slo3 = s5[6] ^ lo;
        const t1shi3 = s5[7] ^ hi;
        const t1slo8 = s5[16] ^ lo;
        const t1shi8 = s5[17] ^ hi;
        const t1slo13 = s5[26] ^ lo;
        const t1shi13 = s5[27] ^ hi;
        const t1slo18 = s5[36] ^ lo;
        const t1shi18 = s5[37] ^ hi;
        const t1slo23 = s5[46] ^ lo;
        const t1shi23 = s5[47] ^ hi;
        lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        const t1slo4 = s5[8] ^ lo;
        const t1shi4 = s5[9] ^ hi;
        const t1slo9 = s5[18] ^ lo;
        const t1shi9 = s5[19] ^ hi;
        const t1slo14 = s5[28] ^ lo;
        const t1shi14 = s5[29] ^ hi;
        const t1slo19 = s5[38] ^ lo;
        const t1shi19 = s5[39] ^ hi;
        const t1slo24 = s5[48] ^ lo;
        const t1shi24 = s5[49] ^ hi;
        const t2slo0 = t1slo0;
        const t2shi0 = t1shi0;
        const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
        const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
        const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
        const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
        const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
        const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
        const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
        const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
        const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
        const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
        const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
        const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
        const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
        const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
        const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
        const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
        const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
        const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
        const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
        const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
        const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
        const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
        const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
        const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
        const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
        const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
        const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
        const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
        const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
        const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
        const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
        const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
        const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
        const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
        const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
        const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
        const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
        const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
        const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
        const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
        const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
        const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
        const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
        const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
        const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
        const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
        const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
        const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
        s5[0] = t2slo0 ^ ~t2slo1 & t2slo2;
        s5[1] = t2shi0 ^ ~t2shi1 & t2shi2;
        s5[10] = t2slo5 ^ ~t2slo6 & t2slo7;
        s5[11] = t2shi5 ^ ~t2shi6 & t2shi7;
        s5[20] = t2slo10 ^ ~t2slo11 & t2slo12;
        s5[21] = t2shi10 ^ ~t2shi11 & t2shi12;
        s5[30] = t2slo15 ^ ~t2slo16 & t2slo17;
        s5[31] = t2shi15 ^ ~t2shi16 & t2shi17;
        s5[40] = t2slo20 ^ ~t2slo21 & t2slo22;
        s5[41] = t2shi20 ^ ~t2shi21 & t2shi22;
        s5[2] = t2slo1 ^ ~t2slo2 & t2slo3;
        s5[3] = t2shi1 ^ ~t2shi2 & t2shi3;
        s5[12] = t2slo6 ^ ~t2slo7 & t2slo8;
        s5[13] = t2shi6 ^ ~t2shi7 & t2shi8;
        s5[22] = t2slo11 ^ ~t2slo12 & t2slo13;
        s5[23] = t2shi11 ^ ~t2shi12 & t2shi13;
        s5[32] = t2slo16 ^ ~t2slo17 & t2slo18;
        s5[33] = t2shi16 ^ ~t2shi17 & t2shi18;
        s5[42] = t2slo21 ^ ~t2slo22 & t2slo23;
        s5[43] = t2shi21 ^ ~t2shi22 & t2shi23;
        s5[4] = t2slo2 ^ ~t2slo3 & t2slo4;
        s5[5] = t2shi2 ^ ~t2shi3 & t2shi4;
        s5[14] = t2slo7 ^ ~t2slo8 & t2slo9;
        s5[15] = t2shi7 ^ ~t2shi8 & t2shi9;
        s5[24] = t2slo12 ^ ~t2slo13 & t2slo14;
        s5[25] = t2shi12 ^ ~t2shi13 & t2shi14;
        s5[34] = t2slo17 ^ ~t2slo18 & t2slo19;
        s5[35] = t2shi17 ^ ~t2shi18 & t2shi19;
        s5[44] = t2slo22 ^ ~t2slo23 & t2slo24;
        s5[45] = t2shi22 ^ ~t2shi23 & t2shi24;
        s5[6] = t2slo3 ^ ~t2slo4 & t2slo0;
        s5[7] = t2shi3 ^ ~t2shi4 & t2shi0;
        s5[16] = t2slo8 ^ ~t2slo9 & t2slo5;
        s5[17] = t2shi8 ^ ~t2shi9 & t2shi5;
        s5[26] = t2slo13 ^ ~t2slo14 & t2slo10;
        s5[27] = t2shi13 ^ ~t2shi14 & t2shi10;
        s5[36] = t2slo18 ^ ~t2slo19 & t2slo15;
        s5[37] = t2shi18 ^ ~t2shi19 & t2shi15;
        s5[46] = t2slo23 ^ ~t2slo24 & t2slo20;
        s5[47] = t2shi23 ^ ~t2shi24 & t2shi20;
        s5[8] = t2slo4 ^ ~t2slo0 & t2slo1;
        s5[9] = t2shi4 ^ ~t2shi0 & t2shi1;
        s5[18] = t2slo9 ^ ~t2slo5 & t2slo6;
        s5[19] = t2shi9 ^ ~t2shi5 & t2shi6;
        s5[28] = t2slo14 ^ ~t2slo10 & t2slo11;
        s5[29] = t2shi14 ^ ~t2shi10 & t2shi11;
        s5[38] = t2slo19 ^ ~t2slo15 & t2slo16;
        s5[39] = t2shi19 ^ ~t2shi15 & t2shi16;
        s5[48] = t2slo24 ^ ~t2slo20 & t2slo21;
        s5[49] = t2shi24 ^ ~t2shi20 & t2shi21;
        s5[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s5[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };
  }
});

// node_modules/keccak/lib/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/keccak/lib/keccak.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var keccakState = require_keccak_state_unroll();
    function Keccak() {
      this.state = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }
    Keccak.prototype.initialize = function(rate, capacity) {
      for (let i5 = 0; i5 < 50; ++i5)
        this.state[i5] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };
    Keccak.prototype.absorb = function(data) {
      for (let i5 = 0; i5 < data.length; ++i5) {
        this.state[~~(this.count / 4)] ^= data[i5] << 8 * (this.count % 4);
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };
    Keccak.prototype.absorbLastFewBits = function(bits) {
      this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
      if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
        keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };
    Keccak.prototype.squeeze = function(length) {
      if (!this.squeezing)
        this.absorbLastFewBits(1);
      const output = Buffer2.alloc(length);
      for (let i5 = 0; i5 < length; ++i5) {
        output[i5] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
      return output;
    };
    Keccak.prototype.copy = function(dest) {
      for (let i5 = 0; i5 < 50; ++i5)
        dest.state[i5] = this.state[i5];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };
    module.exports = Keccak;
  }
});

// node_modules/keccak/js.js
var require_js = __commonJS({
  "node_modules/keccak/js.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_api2()(require_keccak2());
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.js
var require_util4 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var createKeccakHash = require_js();
    var BN2 = require_bn3();
    function zeros(bytes) {
      return Buffer2.allocUnsafe(bytes).fill(0);
    }
    function setLength(msg, length, right) {
      const buf = zeros(length);
      msg = toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    }
    function setLengthRight(msg, length) {
      return setLength(msg, length, true);
    }
    function toBuffer(v5) {
      if (!Buffer2.isBuffer(v5)) {
        if (Array.isArray(v5)) {
          v5 = Buffer2.from(v5);
        } else if (typeof v5 === "string") {
          if (isHexString3(v5)) {
            v5 = Buffer2.from(padToEven(stripHexPrefix(v5)), "hex");
          } else {
            v5 = Buffer2.from(v5);
          }
        } else if (typeof v5 === "number") {
          v5 = intToBuffer(v5);
        } else if (v5 === null || v5 === void 0) {
          v5 = Buffer2.allocUnsafe(0);
        } else if (BN2.isBN(v5)) {
          v5 = v5.toArrayLike(Buffer2);
        } else if (v5.toArray) {
          v5 = Buffer2.from(v5.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v5;
    }
    function bufferToHex2(buf) {
      buf = toBuffer(buf);
      return "0x" + buf.toString("hex");
    }
    function keccak(a5, bits) {
      a5 = toBuffer(a5);
      if (!bits)
        bits = 256;
      return createKeccakHash("keccak" + bits).update(a5).digest();
    }
    function padToEven(str) {
      return str.length % 2 ? "0" + str : str;
    }
    function isHexString3(str) {
      return typeof str === "string" && str.match(/^0x[0-9A-Fa-f]*$/);
    }
    function stripHexPrefix(str) {
      if (typeof str === "string" && str.startsWith("0x")) {
        return str.slice(2);
      }
      return str;
    }
    module.exports = {
      zeros,
      setLength,
      setLengthRight,
      isHexString: isHexString3,
      stripHexPrefix,
      toBuffer,
      bufferToHex: bufferToHex2,
      keccak
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.js
var require_abi = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var util = require_util4();
    var BN2 = require_bn3();
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    function parseTypeN(type2) {
      return parseInt(/^\D+(\d+)$/.exec(type2)[1], 10);
    }
    function parseTypeNxM(type2) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type2);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type2) {
      var tmp = type2.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type2 = typeof arg;
      if (type2 === "string") {
        if (util.isHexString(arg)) {
          return new BN2(util.stripHexPrefix(arg), 16);
        } else {
          return new BN2(arg, 10);
        }
      } else if (type2 === "number") {
        return new BN2(arg);
      } else if (arg.toArray) {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function encodeSingle(type2, arg) {
      var size, num, ret, i5;
      if (type2 === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type2 === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type2 === "string") {
        return encodeSingle("bytes", new Buffer2(arg, "utf8"));
      } else if (isArray5(type2)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type2);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error("Elements exceed array size: " + size);
        }
        ret = [];
        type2 = type2.slice(0, type2.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i5 in arg) {
          ret.push(encodeSingle(type2, arg[i5]));
        }
        if (size === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer2.concat(ret);
      } else if (type2 === "bytes") {
        arg = new Buffer2(arg);
        ret = Buffer2.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer2.concat([ret, util.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type2.startsWith("bytes")) {
        size = parseTypeN(type2);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return util.setLengthRight(arg, 32);
      } else if (type2.startsWith("uint")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer2, "be", 32);
      } else if (type2.startsWith("int")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        return num.toTwos(256).toArrayLike(Buffer2, "be", 32);
      } else if (type2.startsWith("ufixed")) {
        size = parseTypeNxM(type2);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new BN2(2).pow(new BN2(size[1]))));
      } else if (type2.startsWith("fixed")) {
        size = parseTypeNxM(type2);
        return encodeSingle("int256", parseNumber(arg).mul(new BN2(2).pow(new BN2(size[1]))));
      }
      throw new Error("Unsupported or invalid type: " + type2);
    }
    function isDynamic(type2) {
      return type2 === "string" || type2 === "bytes" || parseTypeArray(type2) === "dynamic";
    }
    function isArray5(type2) {
      return type2.lastIndexOf("]") === type2.length - 1;
    }
    function rawEncode(types, values) {
      var output = [];
      var data = [];
      var headLength = 32 * types.length;
      for (var i5 in types) {
        var type2 = elementaryName(types[i5]);
        var value = values[i5];
        var cur = encodeSingle(type2, value);
        if (isDynamic(type2)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer2.concat(output.concat(data));
    }
    function solidityPack(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var size, num;
      var ret = [];
      for (var i5 = 0; i5 < types.length; i5++) {
        var type2 = elementaryName(types[i5]);
        var value = values[i5];
        if (type2 === "bytes") {
          ret.push(value);
        } else if (type2 === "string") {
          ret.push(new Buffer2(value, "utf8"));
        } else if (type2 === "bool") {
          ret.push(new Buffer2(value ? "01" : "00", "hex"));
        } else if (type2 === "address") {
          ret.push(util.setLength(value, 20));
        } else if (type2.startsWith("bytes")) {
          size = parseTypeN(type2);
          if (size < 1 || size > 32) {
            throw new Error("Invalid bytes<N> width: " + size);
          }
          ret.push(util.setLengthRight(value, size));
        } else if (type2.startsWith("uint")) {
          size = parseTypeN(type2);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid uint<N> width: " + size);
          }
          num = parseNumber(value);
          if (num.bitLength() > size) {
            throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
          }
          ret.push(num.toArrayLike(Buffer2, "be", size / 8));
        } else if (type2.startsWith("int")) {
          size = parseTypeN(type2);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid int<N> width: " + size);
          }
          num = parseNumber(value);
          if (num.bitLength() > size) {
            throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
          }
          ret.push(num.toTwos(size).toArrayLike(Buffer2, "be", size / 8));
        } else {
          throw new Error("Unsupported or invalid type: " + type2);
        }
      }
      return Buffer2.concat(ret);
    }
    function soliditySHA3(types, values) {
      return util.keccak(solidityPack(types, values));
    }
    module.exports = {
      rawEncode,
      solidityPack,
      soliditySHA3
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.js
var require_eth_eip712_util = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var util = require_util4();
    var abi = require_abi();
    var TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    var TypedDataUtils = {
      encodeData(primaryType, data, types, useV4 = true) {
        const encodedTypes = ["bytes32"];
        const encodedValues = [this.hashType(primaryType, types)];
        if (useV4) {
          const encodeField = (name, type2, value) => {
            if (types[type2] !== void 0) {
              return ["bytes32", value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util.keccak(this.encodeData(type2, value, types, useV4))];
            }
            if (value === void 0)
              throw new Error(`missing value for field ${name} of type ${type2}`);
            if (type2 === "bytes") {
              return ["bytes32", util.keccak(value)];
            }
            if (type2 === "string") {
              if (typeof value === "string") {
                value = Buffer2.from(value, "utf8");
              }
              return ["bytes32", util.keccak(value)];
            }
            if (type2.lastIndexOf("]") === type2.length - 1) {
              const parsedType = type2.slice(0, type2.lastIndexOf("["));
              const typeValuePairs = value.map((item) => encodeField(name, parsedType, item));
              return ["bytes32", util.keccak(abi.rawEncode(
                typeValuePairs.map(([type3]) => type3),
                typeValuePairs.map(([, value2]) => value2)
              ))];
            }
            return [type2, value];
          };
          for (const field of types[primaryType]) {
            const [type2, value] = encodeField(field.name, field.type, data[field.name]);
            encodedTypes.push(type2);
            encodedValues.push(value);
          }
        } else {
          for (const field of types[primaryType]) {
            let value = data[field.name];
            if (value !== void 0) {
              if (field.type === "bytes") {
                encodedTypes.push("bytes32");
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (field.type === "string") {
                encodedTypes.push("bytes32");
                if (typeof value === "string") {
                  value = Buffer2.from(value, "utf8");
                }
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (types[field.type] !== void 0) {
                encodedTypes.push("bytes32");
                value = util.keccak(this.encodeData(field.type, value, types, useV4));
                encodedValues.push(value);
              } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
                throw new Error("Arrays currently unimplemented in encodeData");
              } else {
                encodedTypes.push(field.type);
                encodedValues.push(value);
              }
            }
          }
        }
        return abi.rawEncode(encodedTypes, encodedValues);
      },
      encodeType(primaryType, types) {
        let result = "";
        let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type2 of deps) {
          const children = types[type2];
          if (!children) {
            throw new Error("No type definition specified: " + type2);
          }
          result += type2 + "(" + types[type2].map(({ name, type: type3 }) => type3 + " " + name).join(",") + ")";
        }
        return result;
      },
      findTypeDependencies(primaryType, types, results2 = []) {
        primaryType = primaryType.match(/^\w*/)[0];
        if (results2.includes(primaryType) || types[primaryType] === void 0) {
          return results2;
        }
        results2.push(primaryType);
        for (const field of types[primaryType]) {
          for (const dep of this.findTypeDependencies(field.type, types, results2)) {
            !results2.includes(dep) && results2.push(dep);
          }
        }
        return results2;
      },
      hashStruct(primaryType, data, types, useV4 = true) {
        return util.keccak(this.encodeData(primaryType, data, types, useV4));
      },
      hashType(primaryType, types) {
        return util.keccak(this.encodeType(primaryType, types));
      },
      sanitizeData(data) {
        const sanitizedData = {};
        for (const key in TYPED_MESSAGE_SCHEMA.properties) {
          data[key] && (sanitizedData[key] = data[key]);
        }
        if (sanitizedData.types) {
          sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData;
      },
      hash(typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts = [Buffer2.from("1901", "hex")];
        parts.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== "EIP712Domain") {
          parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return util.keccak(Buffer2.concat(parts));
      }
    };
    module.exports = {
      TYPED_MESSAGE_SCHEMA,
      TypedDataUtils,
      hashForSignTypedDataLegacy: function(msgParams) {
        return typedSignatureHashLegacy(msgParams.data);
      },
      hashForSignTypedData_v3: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data, false);
      },
      hashForSignTypedData_v4: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data);
      }
    };
    function typedSignatureHashLegacy(typedData) {
      const error2 = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length)
        throw error2;
      const data = typedData.map(function(e5) {
        return e5.type === "bytes" ? util.toBuffer(e5.value) : e5.value;
      });
      const types = typedData.map(function(e5) {
        return e5.type;
      });
      const schema = typedData.map(function(e5) {
        if (!e5.name)
          throw error2;
        return e5.type + " " + e5.name;
      });
      return abi.soliditySHA3(
        ["bytes32", "bytes32"],
        [
          abi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
          abi.soliditySHA3(types, data)
        ]
      );
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/FilterPolyfill.js
var require_FilterPolyfill = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/FilterPolyfill.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterFromParam = exports.FilterPolyfill = void 0;
    var types_1 = require_types();
    var util_1 = require_util3();
    var TIMEOUT = 5 * 60 * 1e3;
    var JSONRPC_TEMPLATE = {
      jsonrpc: "2.0",
      id: 0
    };
    var FilterPolyfill = class {
      constructor(provider) {
        this.logFilters = /* @__PURE__ */ new Map();
        this.blockFilters = /* @__PURE__ */ new Set();
        this.pendingTransactionFilters = /* @__PURE__ */ new Set();
        this.cursors = /* @__PURE__ */ new Map();
        this.timeouts = /* @__PURE__ */ new Map();
        this.nextFilterId = (0, types_1.IntNumber)(1);
        this.provider = provider;
      }
      async newFilter(param) {
        const filter2 = filterFromParam(param);
        const id = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id, filter2.fromBlock);
        console.log(`Installing new log filter(${id}):`, filter2, "initial cursor position:", cursor);
        this.logFilters.set(id, filter2);
        this.setFilterTimeout(id);
        return (0, util_1.hexStringFromIntNumber)(id);
      }
      async newBlockFilter() {
        const id = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id, "latest");
        console.log(`Installing new block filter (${id}) with initial cursor position:`, cursor);
        this.blockFilters.add(id);
        this.setFilterTimeout(id);
        return (0, util_1.hexStringFromIntNumber)(id);
      }
      async newPendingTransactionFilter() {
        const id = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id, "latest");
        console.log(`Installing new block filter (${id}) with initial cursor position:`, cursor);
        this.pendingTransactionFilters.add(id);
        this.setFilterTimeout(id);
        return (0, util_1.hexStringFromIntNumber)(id);
      }
      uninstallFilter(filterId) {
        const id = (0, util_1.intNumberFromHexString)(filterId);
        console.log(`Uninstalling filter (${id})`);
        this.deleteFilter(id);
        return true;
      }
      getFilterChanges(filterId) {
        const id = (0, util_1.intNumberFromHexString)(filterId);
        if (this.timeouts.has(id)) {
          this.setFilterTimeout(id);
        }
        if (this.logFilters.has(id)) {
          return this.getLogFilterChanges(id);
        } else if (this.blockFilters.has(id)) {
          return this.getBlockFilterChanges(id);
        } else if (this.pendingTransactionFilters.has(id)) {
          return this.getPendingTransactionFilterChanges(id);
        }
        return Promise.resolve(filterNotFoundError());
      }
      async getFilterLogs(filterId) {
        const id = (0, util_1.intNumberFromHexString)(filterId);
        const filter2 = this.logFilters.get(id);
        if (!filter2) {
          return filterNotFoundError();
        }
        return this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [paramFromFilter(filter2)] }));
      }
      makeFilterId() {
        return (0, types_1.IntNumber)(++this.nextFilterId);
      }
      sendAsyncPromise(request3) {
        return new Promise((resolve, reject) => {
          this.provider.sendAsync(request3, (err, response) => {
            if (err) {
              return reject(err);
            }
            if (Array.isArray(response) || response == null) {
              return reject(new Error(`unexpected response received: ${JSON.stringify(response)}`));
            }
            resolve(response);
          });
        });
      }
      deleteFilter(id) {
        console.log(`Deleting filter (${id})`);
        this.logFilters.delete(id);
        this.blockFilters.delete(id);
        this.pendingTransactionFilters.delete(id);
        this.cursors.delete(id);
        this.timeouts.delete(id);
      }
      async getLogFilterChanges(id) {
        const filter2 = this.logFilters.get(id);
        const cursorPosition = this.cursors.get(id);
        if (!cursorPosition || !filter2) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const toBlock = filter2.toBlock === "latest" ? currentBlockHeight : filter2.toBlock;
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        if (cursorPosition > filter2.toBlock) {
          return emptyResult();
        }
        console.log(`Fetching logs from ${cursorPosition} to ${toBlock} for filter ${id}`);
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [
          paramFromFilter(Object.assign(Object.assign({}, filter2), { fromBlock: cursorPosition, toBlock }))
        ] }));
        if (Array.isArray(response.result)) {
          const blocks = response.result.map((log2) => (0, util_1.intNumberFromHexString)(log2.blockNumber || "0x0"));
          const highestBlock = Math.max(...blocks);
          if (highestBlock && highestBlock > cursorPosition) {
            const newCursorPosition = (0, types_1.IntNumber)(highestBlock + 1);
            console.log(`Moving cursor position for filter (${id}) from ${cursorPosition} to ${newCursorPosition}`);
            this.cursors.set(id, newCursorPosition);
          }
        }
        return response;
      }
      async getBlockFilterChanges(id) {
        const cursorPosition = this.cursors.get(id);
        if (!cursorPosition) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        console.log(`Fetching blocks from ${cursorPosition} to ${currentBlockHeight} for filter (${id})`);
        const blocks = (await Promise.all(
          (0, util_1.range)(cursorPosition, currentBlockHeight + 1).map((i5) => this.getBlockHashByNumber((0, types_1.IntNumber)(i5)))
        )).filter((hash) => !!hash);
        const newCursorPosition = (0, types_1.IntNumber)(cursorPosition + blocks.length);
        console.log(`Moving cursor position for filter (${id}) from ${cursorPosition} to ${newCursorPosition}`);
        this.cursors.set(id, newCursorPosition);
        return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: blocks });
      }
      async getPendingTransactionFilterChanges(_id) {
        return Promise.resolve(emptyResult());
      }
      async setInitialCursorPosition(id, startBlock) {
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const initialCursorPosition = typeof startBlock === "number" && startBlock > currentBlockHeight ? startBlock : currentBlockHeight;
        this.cursors.set(id, initialCursorPosition);
        return initialCursorPosition;
      }
      setFilterTimeout(id) {
        const existing = this.timeouts.get(id);
        if (existing) {
          window.clearTimeout(existing);
        }
        const timeout2 = window.setTimeout(() => {
          console.log(`Filter (${id}) timed out`);
          this.deleteFilter(id);
        }, TIMEOUT);
        this.timeouts.set(id, timeout2);
      }
      async getCurrentBlockHeight() {
        const { result } = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_blockNumber", params: [] }));
        return (0, util_1.intNumberFromHexString)((0, util_1.ensureHexString)(result));
      }
      async getBlockHashByNumber(blockNumber) {
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getBlockByNumber", params: [(0, util_1.hexStringFromIntNumber)(blockNumber), false] }));
        if (response.result && typeof response.result.hash === "string") {
          return (0, util_1.ensureHexString)(response.result.hash);
        }
        return null;
      }
    };
    exports.FilterPolyfill = FilterPolyfill;
    function filterFromParam(param) {
      return {
        fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),
        toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),
        addresses: param.address === void 0 ? null : Array.isArray(param.address) ? param.address : [param.address],
        topics: param.topics || []
      };
    }
    exports.filterFromParam = filterFromParam;
    function paramFromFilter(filter2) {
      const param = {
        fromBlock: hexBlockHeightFromIntBlockHeight(filter2.fromBlock),
        toBlock: hexBlockHeightFromIntBlockHeight(filter2.toBlock),
        topics: filter2.topics
      };
      if (filter2.addresses !== null) {
        param.address = filter2.addresses;
      }
      return param;
    }
    function intBlockHeightFromHexBlockHeight(value) {
      if (value === void 0 || value === "latest" || value === "pending") {
        return "latest";
      } else if (value === "earliest") {
        return (0, types_1.IntNumber)(0);
      } else if ((0, util_1.isHexString)(value)) {
        return (0, util_1.intNumberFromHexString)(value);
      }
      throw new Error(`Invalid block option: ${String(value)}`);
    }
    function hexBlockHeightFromIntBlockHeight(value) {
      if (value === "latest") {
        return value;
      }
      return (0, util_1.hexStringFromIntNumber)(value);
    }
    function filterNotFoundError() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { error: { code: -32e3, message: "filter not found" } });
    }
    function emptyResult() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: [] });
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/JSONRPC.js
var require_JSONRPC = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/JSONRPC.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONRPCMethod = void 0;
    var JSONRPCMethod;
    (function(JSONRPCMethod2) {
      JSONRPCMethod2["eth_accounts"] = "eth_accounts";
      JSONRPCMethod2["eth_coinbase"] = "eth_coinbase";
      JSONRPCMethod2["net_version"] = "net_version";
      JSONRPCMethod2["eth_chainId"] = "eth_chainId";
      JSONRPCMethod2["eth_uninstallFilter"] = "eth_uninstallFilter";
      JSONRPCMethod2["eth_requestAccounts"] = "eth_requestAccounts";
      JSONRPCMethod2["eth_sign"] = "eth_sign";
      JSONRPCMethod2["eth_ecRecover"] = "eth_ecRecover";
      JSONRPCMethod2["personal_sign"] = "personal_sign";
      JSONRPCMethod2["personal_ecRecover"] = "personal_ecRecover";
      JSONRPCMethod2["eth_signTransaction"] = "eth_signTransaction";
      JSONRPCMethod2["eth_sendRawTransaction"] = "eth_sendRawTransaction";
      JSONRPCMethod2["eth_sendTransaction"] = "eth_sendTransaction";
      JSONRPCMethod2["eth_signTypedData_v1"] = "eth_signTypedData_v1";
      JSONRPCMethod2["eth_signTypedData_v2"] = "eth_signTypedData_v2";
      JSONRPCMethod2["eth_signTypedData_v3"] = "eth_signTypedData_v3";
      JSONRPCMethod2["eth_signTypedData_v4"] = "eth_signTypedData_v4";
      JSONRPCMethod2["eth_signTypedData"] = "eth_signTypedData";
      JSONRPCMethod2["cbWallet_arbitrary"] = "walletlink_arbitrary";
      JSONRPCMethod2["wallet_addEthereumChain"] = "wallet_addEthereumChain";
      JSONRPCMethod2["wallet_switchEthereumChain"] = "wallet_switchEthereumChain";
      JSONRPCMethod2["wallet_watchAsset"] = "wallet_watchAsset";
      JSONRPCMethod2["eth_subscribe"] = "eth_subscribe";
      JSONRPCMethod2["eth_unsubscribe"] = "eth_unsubscribe";
      JSONRPCMethod2["eth_newFilter"] = "eth_newFilter";
      JSONRPCMethod2["eth_newBlockFilter"] = "eth_newBlockFilter";
      JSONRPCMethod2["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
      JSONRPCMethod2["eth_getFilterChanges"] = "eth_getFilterChanges";
      JSONRPCMethod2["eth_getFilterLogs"] = "eth_getFilterLogs";
    })(JSONRPCMethod = exports.JSONRPCMethod || (exports.JSONRPCMethod = {}));
  }
});

// node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/pify/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var processFn = (fn, opts) => function() {
      const P5 = opts.promiseModule;
      const args = new Array(arguments.length);
      for (let i5 = 0; i5 < arguments.length; i5++) {
        args[i5] = arguments[i5];
      }
      return new P5((resolve, reject) => {
        if (opts.errorFirst) {
          args.push(function(err, result) {
            if (opts.multiArgs) {
              const results2 = new Array(arguments.length - 1);
              for (let i5 = 1; i5 < arguments.length; i5++) {
                results2[i5 - 1] = arguments[i5];
              }
              if (err) {
                results2.unshift(err);
                reject(results2);
              } else {
                resolve(results2);
              }
            } else if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        } else {
          args.push(function(result) {
            if (opts.multiArgs) {
              const results2 = new Array(arguments.length - 1);
              for (let i5 = 0; i5 < arguments.length; i5++) {
                results2[i5] = arguments[i5];
              }
              resolve(results2);
            } else {
              resolve(result);
            }
          });
        }
        fn.apply(this, args);
      });
    };
    module.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter2 = (key) => {
        const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key in obj) {
        const x5 = obj[key];
        ret[key] = typeof x5 === "function" && filter2(key) ? processFn(x5, opts) : x5;
      }
      return ret;
    };
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = extend;
    var hasOwnProperty3 = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i5 = 0; i5 < arguments.length; i5++) {
        var source = arguments[i5];
        for (var key in source) {
          if (hasOwnProperty3.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/json-rpc-random-id/index.js
var require_json_rpc_random_id = __commonJS({
  "node_modules/json-rpc-random-id/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = IdIterator;
    function IdIterator(opts) {
      opts = opts || {};
      var max2 = opts.max || Number.MAX_SAFE_INTEGER;
      var idCounter = typeof opts.start !== "undefined" ? opts.start : Math.floor(Math.random() * max2);
      return function createRandomId() {
        idCounter = idCounter % max2;
        return idCounter++;
      };
    }
  }
});

// node_modules/eth-query/index.js
var require_eth_query = __commonJS({
  "node_modules/eth-query/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var extend = require_immutable();
    var createRandomId = require_json_rpc_random_id()();
    module.exports = EthQuery;
    function EthQuery(provider) {
      const self2 = this;
      self2.currentProvider = provider;
    }
    EthQuery.prototype.getBalance = generateFnWithDefaultBlockFor(2, "eth_getBalance");
    EthQuery.prototype.getCode = generateFnWithDefaultBlockFor(2, "eth_getCode");
    EthQuery.prototype.getTransactionCount = generateFnWithDefaultBlockFor(2, "eth_getTransactionCount");
    EthQuery.prototype.getStorageAt = generateFnWithDefaultBlockFor(3, "eth_getStorageAt");
    EthQuery.prototype.call = generateFnWithDefaultBlockFor(2, "eth_call");
    EthQuery.prototype.protocolVersion = generateFnFor("eth_protocolVersion");
    EthQuery.prototype.syncing = generateFnFor("eth_syncing");
    EthQuery.prototype.coinbase = generateFnFor("eth_coinbase");
    EthQuery.prototype.mining = generateFnFor("eth_mining");
    EthQuery.prototype.hashrate = generateFnFor("eth_hashrate");
    EthQuery.prototype.gasPrice = generateFnFor("eth_gasPrice");
    EthQuery.prototype.accounts = generateFnFor("eth_accounts");
    EthQuery.prototype.blockNumber = generateFnFor("eth_blockNumber");
    EthQuery.prototype.getBlockTransactionCountByHash = generateFnFor("eth_getBlockTransactionCountByHash");
    EthQuery.prototype.getBlockTransactionCountByNumber = generateFnFor("eth_getBlockTransactionCountByNumber");
    EthQuery.prototype.getUncleCountByBlockHash = generateFnFor("eth_getUncleCountByBlockHash");
    EthQuery.prototype.getUncleCountByBlockNumber = generateFnFor("eth_getUncleCountByBlockNumber");
    EthQuery.prototype.sign = generateFnFor("eth_sign");
    EthQuery.prototype.sendTransaction = generateFnFor("eth_sendTransaction");
    EthQuery.prototype.sendRawTransaction = generateFnFor("eth_sendRawTransaction");
    EthQuery.prototype.estimateGas = generateFnFor("eth_estimateGas");
    EthQuery.prototype.getBlockByHash = generateFnFor("eth_getBlockByHash");
    EthQuery.prototype.getBlockByNumber = generateFnFor("eth_getBlockByNumber");
    EthQuery.prototype.getTransactionByHash = generateFnFor("eth_getTransactionByHash");
    EthQuery.prototype.getTransactionByBlockHashAndIndex = generateFnFor("eth_getTransactionByBlockHashAndIndex");
    EthQuery.prototype.getTransactionByBlockNumberAndIndex = generateFnFor("eth_getTransactionByBlockNumberAndIndex");
    EthQuery.prototype.getTransactionReceipt = generateFnFor("eth_getTransactionReceipt");
    EthQuery.prototype.getUncleByBlockHashAndIndex = generateFnFor("eth_getUncleByBlockHashAndIndex");
    EthQuery.prototype.getUncleByBlockNumberAndIndex = generateFnFor("eth_getUncleByBlockNumberAndIndex");
    EthQuery.prototype.getCompilers = generateFnFor("eth_getCompilers");
    EthQuery.prototype.compileLLL = generateFnFor("eth_compileLLL");
    EthQuery.prototype.compileSolidity = generateFnFor("eth_compileSolidity");
    EthQuery.prototype.compileSerpent = generateFnFor("eth_compileSerpent");
    EthQuery.prototype.newFilter = generateFnFor("eth_newFilter");
    EthQuery.prototype.newBlockFilter = generateFnFor("eth_newBlockFilter");
    EthQuery.prototype.newPendingTransactionFilter = generateFnFor("eth_newPendingTransactionFilter");
    EthQuery.prototype.uninstallFilter = generateFnFor("eth_uninstallFilter");
    EthQuery.prototype.getFilterChanges = generateFnFor("eth_getFilterChanges");
    EthQuery.prototype.getFilterLogs = generateFnFor("eth_getFilterLogs");
    EthQuery.prototype.getLogs = generateFnFor("eth_getLogs");
    EthQuery.prototype.getWork = generateFnFor("eth_getWork");
    EthQuery.prototype.submitWork = generateFnFor("eth_submitWork");
    EthQuery.prototype.submitHashrate = generateFnFor("eth_submitHashrate");
    EthQuery.prototype.sendAsync = function(opts, cb) {
      const self2 = this;
      self2.currentProvider.sendAsync(createPayload(opts), function(err, response) {
        if (!err && response.error)
          err = new Error("EthQuery - RPC Error - " + response.error.message);
        if (err)
          return cb(err);
        cb(null, response.result);
      });
    };
    function generateFnFor(methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function generateFnWithDefaultBlockFor(argCount, methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        if (args.length < argCount)
          args.push("latest");
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function createPayload(data) {
      return extend({
        id: createRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/events/events.js
var require_events2 = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter3() {
      EventEmitter3.init.call(this);
    }
    module.exports = EventEmitter3;
    module.exports.once = once4;
    EventEmitter3.EventEmitter = EventEmitter3;
    EventEmitter3.prototype._events = void 0;
    EventEmitter3.prototype._eventsCount = 0;
    EventEmitter3.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter3.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter3.prototype.setMaxListeners = function setMaxListeners2(n3) {
      if (typeof n3 !== "number" || n3 < 0 || NumberIsNaN(n3)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n3 + ".");
      }
      this._maxListeners = n3;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter3.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter3.prototype.getMaxListeners = function getMaxListeners2() {
      return _getMaxListeners(this);
    };
    EventEmitter3.prototype.emit = function emit4(type2) {
      var args = [];
      for (var i5 = 1; i5 < arguments.length; i5++)
        args.push(arguments[i5]);
      var doError = type2 === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type2];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners2 = arrayClone2(handler, len);
        for (var i5 = 0; i5 < len; ++i5)
          ReflectApply(listeners2[i5], this, args);
      }
      return true;
    };
    function _addListener2(target, type2, listener, prepend) {
      var m5;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type2,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type2];
      }
      if (existing === void 0) {
        existing = events[type2] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m5 = _getMaxListeners(target);
        if (m5 > 0 && existing.length > m5 && !existing.warned) {
          existing.warned = true;
          var w6 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w6.name = "MaxListenersExceededWarning";
          w6.emitter = target;
          w6.type = type2;
          w6.count = existing.length;
          ProcessEmitWarning(w6);
        }
      }
      return target;
    }
    EventEmitter3.prototype.addListener = function addListener4(type2, listener) {
      return _addListener2(this, type2, listener, false);
    };
    EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
    EventEmitter3.prototype.prependListener = function prependListener3(type2, listener) {
      return _addListener2(this, type2, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap2(target, type2, listener) {
      var state = { fired: false, wrapFn: void 0, target, type: type2, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter3.prototype.once = function once5(type2, listener) {
      checkListener(listener);
      this.on(type2, _onceWrap2(this, type2, listener));
      return this;
    };
    EventEmitter3.prototype.prependOnceListener = function prependOnceListener2(type2, listener) {
      checkListener(listener);
      this.prependListener(type2, _onceWrap2(this, type2, listener));
      return this;
    };
    EventEmitter3.prototype.removeListener = function removeListener4(type2, listener) {
      var list, events, position, i5, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type2];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type2];
          if (events.removeListener)
            this.emit("removeListener", type2, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i5 = list.length - 1; i5 >= 0; i5--) {
          if (list[i5] === listener || list[i5].listener === listener) {
            originalListener = list[i5].listener;
            position = i5;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne2(list, position);
        }
        if (list.length === 1)
          events[type2] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type2, originalListener || listener);
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners4(type2) {
      var listeners2, events, i5;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type2] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type2];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        var key;
        for (i5 = 0; i5 < keys2.length; ++i5) {
          key = keys2[i5];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type2];
      if (typeof listeners2 === "function") {
        this.removeListener(type2, listeners2);
      } else if (listeners2 !== void 0) {
        for (i5 = listeners2.length - 1; i5 >= 0; i5--) {
          this.removeListener(type2, listeners2[i5]);
        }
      }
      return this;
    };
    function _listeners(target, type2, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type2];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners2(evlistener) : arrayClone2(evlistener, evlistener.length);
    }
    EventEmitter3.prototype.listeners = function listeners2(type2) {
      return _listeners(this, type2, true);
    };
    EventEmitter3.prototype.rawListeners = function rawListeners(type2) {
      return _listeners(this, type2, false);
    };
    EventEmitter3.listenerCount = function(emitter, type2) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type2);
      } else {
        return listenerCount3.call(emitter, type2);
      }
    };
    EventEmitter3.prototype.listenerCount = listenerCount3;
    function listenerCount3(type2) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type2];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames2() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone2(arr, n3) {
      var copy3 = new Array(n3);
      for (var i5 = 0; i5 < n3; ++i5)
        copy3[i5] = arr[i5];
      return copy3;
    }
    function spliceOne2(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners2(arr) {
      var ret = new Array(arr.length);
      for (var i5 = 0; i5 < ret.length; ++i5) {
        ret[i5] = arr[i5].listener || arr[i5];
      }
      return ret;
    }
    function once4(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/safe-event-emitter/index.js
var require_safe_event_emitter2 = __commonJS({
  "node_modules/safe-event-emitter/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var util = require_util();
    var EventEmitter3 = require_events2();
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    module.exports = SafeEventEmitter;
    function SafeEventEmitter() {
      EventEmitter3.call(this);
    }
    util.inherits(SafeEventEmitter, EventEmitter3);
    SafeEventEmitter.prototype.emit = function(type2) {
      var args = [];
      for (var i5 = 1; i5 < arguments.length; i5++)
        args.push(arguments[i5]);
      var doError = type2 === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type2];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        safeApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners2 = arrayClone2(handler, len);
        for (var i5 = 0; i5 < len; ++i5)
          safeApply(listeners2[i5], this, args);
      }
      return true;
    };
    function safeApply(handler, context, args) {
      try {
        ReflectApply(handler, context, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone2(arr, n3) {
      var copy3 = new Array(n3);
      for (var i5 = 0; i5 < n3; ++i5)
        copy3[i5] = arr[i5];
      return copy3;
    }
  }
});

// node_modules/eth-block-tracker/src/base.js
var require_base3 = __commonJS({
  "node_modules/eth-block-tracker/src/base.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var EthQuery = require_eth_query();
    var pify = require_pify();
    var SafeEventEmitter = require_safe_event_emitter2();
    var sec = 1e3;
    var calculateSum = (accumulator, currentValue) => accumulator + currentValue;
    var blockTrackerEvents = ["sync", "latest"];
    var BaseBlockTracker = class extends SafeEventEmitter {
      constructor(opts = {}) {
        super();
        this._blockResetDuration = opts.blockResetDuration || 20 * sec;
        this._blockResetTimeout;
        this._currentBlock = null;
        this._isRunning = false;
        this._onNewListener = this._onNewListener.bind(this);
        this._onRemoveListener = this._onRemoveListener.bind(this);
        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
        this._setupInternalEvents();
      }
      isRunning() {
        return this._isRunning;
      }
      getCurrentBlock() {
        return this._currentBlock;
      }
      async getLatestBlock() {
        if (this._currentBlock)
          return this._currentBlock;
        const latestBlock = await new Promise((resolve) => this.once("latest", resolve));
        return latestBlock;
      }
      removeAllListeners(eventName) {
        if (eventName) {
          super.removeAllListeners(eventName);
        } else {
          super.removeAllListeners();
        }
        this._setupInternalEvents();
        this._onRemoveListener();
      }
      _start() {
      }
      _end() {
      }
      _setupInternalEvents() {
        this.removeListener("newListener", this._onNewListener);
        this.removeListener("removeListener", this._onRemoveListener);
        this.on("newListener", this._onNewListener);
        this.on("removeListener", this._onRemoveListener);
      }
      _onNewListener(eventName, handler) {
        if (!blockTrackerEvents.includes(eventName))
          return;
        this._maybeStart();
      }
      _onRemoveListener(eventName, handler) {
        if (this._getBlockTrackerEventCount() > 0)
          return;
        this._maybeEnd();
      }
      _maybeStart() {
        if (this._isRunning)
          return;
        this._isRunning = true;
        this._cancelBlockResetTimeout();
        this._start();
      }
      _maybeEnd() {
        if (!this._isRunning)
          return;
        this._isRunning = false;
        this._setupBlockResetTimeout();
        this._end();
      }
      _getBlockTrackerEventCount() {
        return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);
      }
      _newPotentialLatest(newBlock) {
        const currentBlock = this._currentBlock;
        if (currentBlock && hexToInt(newBlock) <= hexToInt(currentBlock))
          return;
        this._setCurrentBlock(newBlock);
      }
      _setCurrentBlock(newBlock) {
        const oldBlock = this._currentBlock;
        this._currentBlock = newBlock;
        this.emit("latest", newBlock);
        this.emit("sync", { oldBlock, newBlock });
      }
      _setupBlockResetTimeout() {
        this._cancelBlockResetTimeout();
        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
        if (this._blockResetTimeout.unref) {
          this._blockResetTimeout.unref();
        }
      }
      _cancelBlockResetTimeout() {
        clearTimeout(this._blockResetTimeout);
      }
      _resetCurrentBlock() {
        this._currentBlock = null;
      }
    };
    module.exports = BaseBlockTracker;
    function hexToInt(hexInt) {
      return Number.parseInt(hexInt, 16);
    }
  }
});

// node_modules/eth-block-tracker/src/polling.js
var require_polling = __commonJS({
  "node_modules/eth-block-tracker/src/polling.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var pify = require_pify();
    var BaseBlockTracker = require_base3();
    var sec = 1e3;
    var PollingBlockTracker = class extends BaseBlockTracker {
      constructor(opts = {}) {
        if (!opts.provider)
          throw new Error("PollingBlockTracker - no provider specified.");
        const pollingInterval = opts.pollingInterval || 20 * sec;
        const retryTimeout = opts.retryTimeout || pollingInterval / 10;
        const keepEventLoopActive = opts.keepEventLoopActive !== void 0 ? opts.keepEventLoopActive : true;
        const setSkipCacheFlag = opts.setSkipCacheFlag || false;
        super(Object.assign({
          blockResetDuration: pollingInterval
        }, opts));
        this._provider = opts.provider;
        this._pollingInterval = pollingInterval;
        this._retryTimeout = retryTimeout;
        this._keepEventLoopActive = keepEventLoopActive;
        this._setSkipCacheFlag = setSkipCacheFlag;
      }
      async checkForLatestBlock() {
        await this._updateLatestBlock();
        return await this.getLatestBlock();
      }
      _start() {
        this._performSync().catch((err) => this.emit("error", err));
      }
      async _performSync() {
        while (this._isRunning) {
          try {
            await this._updateLatestBlock();
            await timeout2(this._pollingInterval, !this._keepEventLoopActive);
          } catch (err) {
            const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${err.stack}`);
            try {
              this.emit("error", newErr);
            } catch (emitErr) {
              console.error(newErr);
            }
            await timeout2(this._retryTimeout, !this._keepEventLoopActive);
          }
        }
      }
      async _updateLatestBlock() {
        const latestBlock = await this._fetchLatestBlock();
        this._newPotentialLatest(latestBlock);
      }
      async _fetchLatestBlock() {
        const req = { jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] };
        if (this._setSkipCacheFlag)
          req.skipCache = true;
        const res = await pify((cb) => this._provider.sendAsync(req, cb))();
        if (res.error)
          throw new Error(`PollingBlockTracker - encountered error fetching block:
${res.error}`);
        return res.result;
      }
    };
    module.exports = PollingBlockTracker;
    function timeout2(duration, unref) {
      return new Promise((resolve) => {
        const timoutRef = setTimeout(resolve, duration);
        if (timoutRef.unref && unref) {
          timoutRef.unref();
        }
      });
    }
  }
});

// node_modules/eth-json-rpc-middleware/node_modules/json-rpc-engine/src/createScaffoldMiddleware.js
var require_createScaffoldMiddleware = __commonJS({
  "node_modules/eth-json-rpc-middleware/node_modules/json-rpc-engine/src/createScaffoldMiddleware.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
        const handler = handlers[req.method];
        if (handler === void 0) {
          return next();
        }
        if (typeof handler === "function") {
          return handler(req, res, next, end);
        }
        res.result = handler;
        return end();
      };
    };
  }
});

// node_modules/eth-json-rpc-middleware/scaffold.js
var require_scaffold = __commonJS({
  "node_modules/eth-json-rpc-middleware/scaffold.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_createScaffoldMiddleware();
  }
});

// node_modules/json-rpc-engine/dist/getUniqueId.js
var require_getUniqueId = __commonJS({
  "node_modules/json-rpc-engine/dist/getUniqueId.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUniqueId = void 0;
    var MAX = 4294967295;
    var idCounter = Math.floor(Math.random() * MAX);
    function getUniqueId() {
      idCounter = (idCounter + 1) % MAX;
      return idCounter;
    }
    exports.getUniqueId = getUniqueId;
  }
});

// node_modules/json-rpc-engine/dist/idRemapMiddleware.js
var require_idRemapMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/idRemapMiddleware.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIdRemapMiddleware = void 0;
    var getUniqueId_1 = require_getUniqueId();
    function createIdRemapMiddleware() {
      return (req, res, next, _end) => {
        const originalId = req.id;
        const newId = getUniqueId_1.getUniqueId();
        req.id = newId;
        res.id = newId;
        next((done2) => {
          req.id = originalId;
          res.id = originalId;
          done2();
        });
      };
    }
    exports.createIdRemapMiddleware = createIdRemapMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/createAsyncMiddleware.js
var require_createAsyncMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/createAsyncMiddleware.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAsyncMiddleware = void 0;
    function createAsyncMiddleware(asyncMiddleware) {
      return async (req, res, next, end) => {
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
          resolveNextPromise = resolve;
        });
        let returnHandlerCallback = null;
        let nextWasCalled = false;
        const asyncNext = async () => {
          nextWasCalled = true;
          next((runReturnHandlersCallback) => {
            returnHandlerCallback = runReturnHandlersCallback;
            resolveNextPromise();
          });
          await nextPromise;
        };
        try {
          await asyncMiddleware(req, res, asyncNext);
          if (nextWasCalled) {
            await nextPromise;
            returnHandlerCallback(null);
          } else {
            end(null);
          }
        } catch (error2) {
          if (returnHandlerCallback) {
            returnHandlerCallback(error2);
          } else {
            end(error2);
          }
        }
      };
    }
    exports.createAsyncMiddleware = createAsyncMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js
var require_createScaffoldMiddleware2 = __commonJS({
  "node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createScaffoldMiddleware = void 0;
    function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
        const handler = handlers[req.method];
        if (handler === void 0) {
          return next();
        }
        if (typeof handler === "function") {
          return handler(req, res, next, end);
        }
        res.result = handler;
        return end();
      };
    }
    exports.createScaffoldMiddleware = createScaffoldMiddleware;
  }
});

// node_modules/eth-rpc-errors/dist/classes.js
var require_classes2 = __commonJS({
  "node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_6, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants2 = __commonJS({
  "node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/eth-rpc-errors/dist/utils.js
var require_utils7 = __commonJS({
  "node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants2();
    var classes_1 = require_classes2();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError(error2, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error2 instanceof classes_1.EthereumRpcError) {
        return error2.serialize();
      }
      const serialized = {};
      if (error2 && typeof error2 === "object" && !Array.isArray(error2) && hasKey(error2, "code") && isValidCode(error2.code)) {
        const _error = error2;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error2) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error2) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error2) };
      }
      const stack = (_b = error2) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error2 && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error2) {
      if (error2 && typeof error2 === "object" && !Array.isArray(error2)) {
        return Object.assign({}, error2);
      }
      return error2;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/eth-rpc-errors/dist/errors.js
var require_errors2 = __commonJS({
  "node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes2();
    var utils_1 = require_utils7();
    var error_constants_1 = require_error_constants2();
    exports.ethErrors = {
      rpc: {
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/eth-rpc-errors/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes2();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils7();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors2();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants2();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/json-rpc-engine/dist/JsonRpcEngine.js
var require_JsonRpcEngine = __commonJS({
  "node_modules/json-rpc-engine/dist/JsonRpcEngine.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcEngine = void 0;
    var safe_event_emitter_1 = __importDefault2(require_safe_event_emitter());
    var eth_rpc_errors_1 = require_dist2();
    var JsonRpcEngine = class extends safe_event_emitter_1.default {
      constructor() {
        super();
        this._middleware = [];
      }
      push(middleware) {
        this._middleware.push(middleware);
      }
      handle(req, cb) {
        if (cb && typeof cb !== "function") {
          throw new Error('"callback" must be a function if provided.');
        }
        if (Array.isArray(req)) {
          if (cb) {
            return this._handleBatch(req, cb);
          }
          return this._handleBatch(req);
        }
        if (cb) {
          return this._handle(req, cb);
        }
        return this._promiseHandle(req);
      }
      asMiddleware() {
        return async (req, res, next, end) => {
          try {
            const [middlewareError, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
            if (isComplete) {
              await JsonRpcEngine._runReturnHandlers(returnHandlers);
              return end(middlewareError);
            }
            return next(async (handlerCallback) => {
              try {
                await JsonRpcEngine._runReturnHandlers(returnHandlers);
              } catch (error2) {
                return handlerCallback(error2);
              }
              return handlerCallback();
            });
          } catch (error2) {
            return end(error2);
          }
        };
      }
      async _handleBatch(reqs, cb) {
        try {
          const responses = await Promise.all(
            reqs.map(this._promiseHandle.bind(this))
          );
          if (cb) {
            return cb(null, responses);
          }
          return responses;
        } catch (error2) {
          if (cb) {
            return cb(error2);
          }
          throw error2;
        }
      }
      _promiseHandle(req) {
        return new Promise((resolve) => {
          this._handle(req, (_err, res) => {
            resolve(res);
          });
        });
      }
      async _handle(callerReq, cb) {
        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
          const error3 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
          return cb(error3, { id: void 0, jsonrpc: "2.0", error: error3 });
        }
        if (typeof callerReq.method !== "string") {
          const error3 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
          return cb(error3, { id: callerReq.id, jsonrpc: "2.0", error: error3 });
        }
        const req = Object.assign({}, callerReq);
        const res = {
          id: req.id,
          jsonrpc: req.jsonrpc
        };
        let error2 = null;
        try {
          await this._processRequest(req, res);
        } catch (_error) {
          error2 = _error;
        }
        if (error2) {
          delete res.result;
          if (!res.error) {
            res.error = eth_rpc_errors_1.serializeError(error2);
          }
        }
        return cb(error2, res);
      }
      async _processRequest(req, res) {
        const [error2, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        JsonRpcEngine._checkForCompletion(req, res, isComplete);
        await JsonRpcEngine._runReturnHandlers(returnHandlers);
        if (error2) {
          throw error2;
        }
      }
      static async _runAllMiddleware(req, res, middlewareStack) {
        const returnHandlers = [];
        let error2 = null;
        let isComplete = false;
        for (const middleware of middlewareStack) {
          [error2, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
          if (isComplete) {
            break;
          }
        }
        return [error2, isComplete, returnHandlers.reverse()];
      }
      static _runMiddleware(req, res, middleware, returnHandlers) {
        return new Promise((resolve) => {
          const end = (err) => {
            const error2 = err || res.error;
            if (error2) {
              res.error = eth_rpc_errors_1.serializeError(error2);
            }
            resolve([error2, true]);
          };
          const next = (returnHandler) => {
            if (res.error) {
              end(res.error);
            } else {
              if (returnHandler) {
                if (typeof returnHandler !== "function") {
                  end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof returnHandler}" for request:
${jsonify(req)}`, { request: req }));
                }
                returnHandlers.push(returnHandler);
              }
              resolve([null, false]);
            }
          };
          try {
            middleware(req, res, next, end);
          } catch (error2) {
            end(error2);
          }
        });
      }
      static async _runReturnHandlers(handlers) {
        for (const handler of handlers) {
          await new Promise((resolve, reject) => {
            handler((err) => err ? reject(err) : resolve());
          });
        }
      }
      static _checkForCompletion(req, res, isComplete) {
        if (!("result" in res) && !("error" in res)) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${jsonify(req)}`, { request: req });
        }
        if (!isComplete) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${jsonify(req)}`, { request: req });
        }
      }
    };
    exports.JsonRpcEngine = JsonRpcEngine;
    function jsonify(request3) {
      return JSON.stringify(request3, null, 2);
    }
  }
});

// node_modules/json-rpc-engine/dist/mergeMiddleware.js
var require_mergeMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/mergeMiddleware.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMiddleware = void 0;
    var JsonRpcEngine_1 = require_JsonRpcEngine();
    function mergeMiddleware(middlewareStack) {
      const engine = new JsonRpcEngine_1.JsonRpcEngine();
      middlewareStack.forEach((middleware) => engine.push(middleware));
      return engine.asMiddleware();
    }
    exports.mergeMiddleware = mergeMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/json-rpc-engine/dist/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o5, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o5[k22] = m5[k5];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m5, exports2) {
      for (var p5 in m5)
        if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
          __createBinding2(exports2, m5, p5);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_idRemapMiddleware(), exports);
    __exportStar2(require_createAsyncMiddleware(), exports);
    __exportStar2(require_createScaffoldMiddleware2(), exports);
    __exportStar2(require_getUniqueId(), exports);
    __exportStar2(require_JsonRpcEngine(), exports);
    __exportStar2(require_mergeMiddleware(), exports);
  }
});

// node_modules/tslib/tslib.js
var require_tslib2 = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays3;
    var __spreadArray;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn;
    var __createBinding2;
    (function(factory) {
      var root = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v5) {
          return exports2[id] = previous ? previous(id, v5) : v5;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b4) {
        d5.__proto__ = b4;
      } || function(d5, b4) {
        for (var p5 in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p5))
            d5[p5] = b4[p5];
      };
      __extends2 = function(d5, b4) {
        if (typeof b4 !== "function" && b4 !== null)
          throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
        extendStatics(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
      __assign2 = Object.assign || function(t5) {
        for (var s5, i5 = 1, n3 = arguments.length; i5 < n3; i5++) {
          s5 = arguments[i5];
          for (var p5 in s5)
            if (Object.prototype.hasOwnProperty.call(s5, p5))
              t5[p5] = s5[p5];
        }
        return t5;
      };
      __rest2 = function(s5, e5) {
        var t5 = {};
        for (var p5 in s5)
          if (Object.prototype.hasOwnProperty.call(s5, p5) && e5.indexOf(p5) < 0)
            t5[p5] = s5[p5];
        if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i5 = 0, p5 = Object.getOwnPropertySymbols(s5); i5 < p5.length; i5++) {
            if (e5.indexOf(p5[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p5[i5]))
              t5[p5[i5]] = s5[p5[i5]];
          }
        return t5;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d5;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r6 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i5 = decorators.length - 1; i5 >= 0; i5--)
            if (d5 = decorators[i5])
              r6 = (c5 < 3 ? d5(r6) : c5 > 3 ? d5(target, key, r6) : d5(target, key)) || r6;
        return c5 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P5, generator) {
        function adopt(value) {
          return value instanceof P5 ? value : new P5(function(resolve) {
            resolve(value);
          });
        }
        return new (P5 || (P5 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e5) {
              reject(e5);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e5) {
              reject(e5);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _6 = { label: 0, sent: function() {
          if (t5[0] & 1)
            throw t5[1];
          return t5[1];
        }, trys: [], ops: [] }, f5, y5, t5, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n3) {
          return function(v5) {
            return step([n3, v5]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (_6)
            try {
              if (f5 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
                return t5;
              if (y5 = 0, t5)
                op = [op[0] & 2, t5.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t5 = op;
                  break;
                case 4:
                  _6.label++;
                  return { value: op[1], done: false };
                case 5:
                  _6.label++;
                  y5 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _6.ops.pop();
                  _6.trys.pop();
                  continue;
                default:
                  if (!(t5 = _6.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _6 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                    _6.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _6.label < t5[1]) {
                    _6.label = t5[1];
                    t5 = op;
                    break;
                  }
                  if (t5 && _6.label < t5[2]) {
                    _6.label = t5[2];
                    _6.ops.push(op);
                    break;
                  }
                  if (t5[2])
                    _6.ops.pop();
                  _6.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _6);
            } catch (e5) {
              op = [6, e5];
              y5 = 0;
            } finally {
              f5 = t5 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m5, o5) {
        for (var p5 in m5)
          if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(o5, p5))
            __createBinding2(o5, m5, p5);
      };
      __createBinding2 = Object.create ? function(o5, m5, k5, k22) {
        if (k22 === void 0)
          k22 = k5;
        var desc = Object.getOwnPropertyDescriptor(m5, k5);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k5];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m5, k5, k22) {
        if (k22 === void 0)
          k22 = k5;
        o5[k22] = m5[k5];
      };
      __values2 = function(o5) {
        var s5 = typeof Symbol === "function" && Symbol.iterator, m5 = s5 && o5[s5], i5 = 0;
        if (m5)
          return m5.call(o5);
        if (o5 && typeof o5.length === "number")
          return {
            next: function() {
              if (o5 && i5 >= o5.length)
                o5 = void 0;
              return { value: o5 && o5[i5++], done: !o5 };
            }
          };
        throw new TypeError(s5 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o5, n3) {
        var m5 = typeof Symbol === "function" && o5[Symbol.iterator];
        if (!m5)
          return o5;
        var i5 = m5.call(o5), r6, ar = [], e5;
        try {
          while ((n3 === void 0 || n3-- > 0) && !(r6 = i5.next()).done)
            ar.push(r6.value);
        } catch (error2) {
          e5 = { error: error2 };
        } finally {
          try {
            if (r6 && !r6.done && (m5 = i5["return"]))
              m5.call(i5);
          } finally {
            if (e5)
              throw e5.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i5 = 0; i5 < arguments.length; i5++)
          ar = ar.concat(__read2(arguments[i5]));
        return ar;
      };
      __spreadArrays3 = function() {
        for (var s5 = 0, i5 = 0, il = arguments.length; i5 < il; i5++)
          s5 += arguments[i5].length;
        for (var r6 = Array(s5), k5 = 0, i5 = 0; i5 < il; i5++)
          for (var a5 = arguments[i5], j5 = 0, jl = a5.length; j5 < jl; j5++, k5++)
            r6[k5] = a5[j5];
        return r6;
      };
      __spreadArray = function(to, from4, pack) {
        if (pack || arguments.length === 2)
          for (var i5 = 0, l5 = from4.length, ar; i5 < l5; i5++) {
            if (ar || !(i5 in from4)) {
              if (!ar)
                ar = Array.prototype.slice.call(from4, 0, i5);
              ar[i5] = from4[i5];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from4));
      };
      __await2 = function(v5) {
        return this instanceof __await2 ? (this.v = v5, this) : new __await2(v5);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g5 = generator.apply(thisArg, _arguments || []), i5, q5 = [];
        return i5 = {}, verb("next"), verb("throw"), verb("return"), i5[Symbol.asyncIterator] = function() {
          return this;
        }, i5;
        function verb(n3) {
          if (g5[n3])
            i5[n3] = function(v5) {
              return new Promise(function(a5, b4) {
                q5.push([n3, v5, a5, b4]) > 1 || resume2(n3, v5);
              });
            };
        }
        function resume2(n3, v5) {
          try {
            step(g5[n3](v5));
          } catch (e5) {
            settle(q5[0][3], e5);
          }
        }
        function step(r6) {
          r6.value instanceof __await2 ? Promise.resolve(r6.value.v).then(fulfill, reject) : settle(q5[0][2], r6);
        }
        function fulfill(value) {
          resume2("next", value);
        }
        function reject(value) {
          resume2("throw", value);
        }
        function settle(f5, v5) {
          if (f5(v5), q5.shift(), q5.length)
            resume2(q5[0][0], q5[0][1]);
        }
      };
      __asyncDelegator2 = function(o5) {
        var i5, p5;
        return i5 = {}, verb("next"), verb("throw", function(e5) {
          throw e5;
        }), verb("return"), i5[Symbol.iterator] = function() {
          return this;
        }, i5;
        function verb(n3, f5) {
          i5[n3] = o5[n3] ? function(v5) {
            return (p5 = !p5) ? { value: __await2(o5[n3](v5)), done: n3 === "return" } : f5 ? f5(v5) : v5;
          } : f5;
        }
      };
      __asyncValues2 = function(o5) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m5 = o5[Symbol.asyncIterator], i5;
        return m5 ? m5.call(o5) : (o5 = typeof __values2 === "function" ? __values2(o5) : o5[Symbol.iterator](), i5 = {}, verb("next"), verb("throw"), verb("return"), i5[Symbol.asyncIterator] = function() {
          return this;
        }, i5);
        function verb(n3) {
          i5[n3] = o5[n3] && function(v5) {
            return new Promise(function(resolve, reject) {
              v5 = o5[n3](v5), settle(resolve, reject, v5.done, v5.value);
            });
          };
        }
        function settle(resolve, reject, d5, v5) {
          Promise.resolve(v5).then(function(v6) {
            resolve({ value: v6, done: d5 });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o5, v5) {
        Object.defineProperty(o5, "default", { enumerable: true, value: v5 });
      } : function(o5, v5) {
        o5["default"] = v5;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k5 in mod)
            if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k5))
              __createBinding2(result, mod, k5);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f5) {
        if (kind === "a" && !f5)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f5) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f5)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays3);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    });
  }
});

// node_modules/async-mutex/lib/Semaphore.js
var require_Semaphore = __commonJS({
  "node_modules/async-mutex/lib/Semaphore.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib2();
    var Semaphore = function() {
      function Semaphore2(_maxConcurrency) {
        this._maxConcurrency = _maxConcurrency;
        this._queue = [];
        if (_maxConcurrency <= 0) {
          throw new Error("semaphore must be initialized to a positive value");
        }
        this._value = _maxConcurrency;
      }
      Semaphore2.prototype.acquire = function() {
        var _this = this;
        var locked = this.isLocked();
        var ticket = new Promise(function(r6) {
          return _this._queue.push(r6);
        });
        if (!locked)
          this._dispatch();
        return ticket;
      };
      Semaphore2.prototype.runExclusive = function(callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var _a, value, release4;
          return tslib_1.__generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.acquire()];
              case 1:
                _a = _b.sent(), value = _a[0], release4 = _a[1];
                _b.label = 2;
              case 2:
                _b.trys.push([2, , 4, 5]);
                return [4, callback(value)];
              case 3:
                return [2, _b.sent()];
              case 4:
                release4();
                return [7];
              case 5:
                return [2];
            }
          });
        });
      };
      Semaphore2.prototype.isLocked = function() {
        return this._value <= 0;
      };
      Semaphore2.prototype.release = function() {
        if (this._maxConcurrency > 1) {
          throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
        }
        if (this._currentReleaser) {
          var releaser = this._currentReleaser;
          this._currentReleaser = void 0;
          releaser();
        }
      };
      Semaphore2.prototype._dispatch = function() {
        var _this = this;
        var nextConsumer = this._queue.shift();
        if (!nextConsumer)
          return;
        var released = false;
        this._currentReleaser = function() {
          if (released)
            return;
          released = true;
          _this._value++;
          _this._dispatch();
        };
        nextConsumer([this._value--, this._currentReleaser]);
      };
      return Semaphore2;
    }();
    exports.default = Semaphore;
  }
});

// node_modules/async-mutex/lib/Mutex.js
var require_Mutex = __commonJS({
  "node_modules/async-mutex/lib/Mutex.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib2();
    var Semaphore_1 = require_Semaphore();
    var Mutex = function() {
      function Mutex2() {
        this._semaphore = new Semaphore_1.default(1);
      }
      Mutex2.prototype.acquire = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var _a, releaser;
          return tslib_1.__generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._semaphore.acquire()];
              case 1:
                _a = _b.sent(), releaser = _a[1];
                return [2, releaser];
            }
          });
        });
      };
      Mutex2.prototype.runExclusive = function(callback) {
        return this._semaphore.runExclusive(function() {
          return callback();
        });
      };
      Mutex2.prototype.isLocked = function() {
        return this._semaphore.isLocked();
      };
      Mutex2.prototype.release = function() {
        this._semaphore.release();
      };
      return Mutex2;
    }();
    exports.default = Mutex;
  }
});

// node_modules/async-mutex/lib/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/async-mutex/lib/withTimeout.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = void 0;
    var tslib_1 = require_tslib2();
    function withTimeout(sync, timeout2, timeoutError) {
      var _this = this;
      if (timeoutError === void 0) {
        timeoutError = new Error("timeout");
      }
      return {
        acquire: function() {
          return new Promise(function(resolve, reject) {
            return tslib_1.__awaiter(_this, void 0, void 0, function() {
              var isTimeout, ticket, release4;
              return tslib_1.__generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    isTimeout = false;
                    setTimeout(function() {
                      isTimeout = true;
                      reject(timeoutError);
                    }, timeout2);
                    return [4, sync.acquire()];
                  case 1:
                    ticket = _a.sent();
                    if (isTimeout) {
                      release4 = Array.isArray(ticket) ? ticket[1] : ticket;
                      release4();
                    } else {
                      resolve(ticket);
                    }
                    return [2];
                }
              });
            });
          });
        },
        runExclusive: function(callback) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var release4, ticket;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  release4 = function() {
                    return void 0;
                  };
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, , 7, 8]);
                  return [4, this.acquire()];
                case 2:
                  ticket = _a.sent();
                  if (!Array.isArray(ticket))
                    return [3, 4];
                  release4 = ticket[1];
                  return [4, callback(ticket[0])];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  release4 = ticket;
                  return [4, callback()];
                case 5:
                  return [2, _a.sent()];
                case 6:
                  return [3, 8];
                case 7:
                  release4();
                  return [7];
                case 8:
                  return [2];
              }
            });
          });
        },
        release: function() {
          sync.release();
        },
        isLocked: function() {
          return sync.isLocked();
        }
      };
    }
    exports.withTimeout = withTimeout;
  }
});

// node_modules/async-mutex/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/async-mutex/lib/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;
    var Mutex_1 = require_Mutex();
    Object.defineProperty(exports, "Mutex", { enumerable: true, get: function() {
      return Mutex_1.default;
    } });
    var Semaphore_1 = require_Semaphore();
    Object.defineProperty(exports, "Semaphore", { enumerable: true, get: function() {
      return Semaphore_1.default;
    } });
    var withTimeout_1 = require_withTimeout();
    Object.defineProperty(exports, "withTimeout", { enumerable: true, get: function() {
      return withTimeout_1.withTimeout;
    } });
  }
});

// node_modules/eth-json-rpc-filters/node_modules/pify/index.js
var require_pify2 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/pify/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var processFn = (fn, options, proxy, unwrapped) => function(...arguments_) {
      const P5 = options.promiseModule;
      return new P5((resolve, reject) => {
        if (options.multiArgs) {
          arguments_.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          arguments_.push((error2, result) => {
            if (error2) {
              reject(error2);
            } else {
              resolve(result);
            }
          });
        } else {
          arguments_.push(resolve);
        }
        const self2 = this === proxy ? unwrapped : this;
        Reflect.apply(fn, self2, arguments_);
      });
    };
    var filterCache = /* @__PURE__ */ new WeakMap();
    module.exports = (input, options) => {
      options = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise,
        ...options
      };
      const objectType = typeof input;
      if (!(input !== null && (objectType === "object" || objectType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
      }
      const filter2 = (target, key) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key in cached) {
          return cached[key];
        }
        const match = (pattern) => typeof pattern === "string" || typeof key === "symbol" ? key === pattern : pattern.test(key);
        const desc = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
        const included = options.include ? options.include.some(match) : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
      };
      const cache = /* @__PURE__ */ new WeakMap();
      const proxy = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key) {
          const property = target[key];
          if (!filter2(target, key) || property === Function.prototype[key]) {
            return property;
          }
          const cached = cache.get(property);
          if (cached) {
            return cached;
          }
          if (typeof property === "function") {
            const pified = processFn(property, options, proxy, target);
            cache.set(property, pified);
            return pified;
          }
          return property;
        }
      });
      return proxy;
    };
  }
});

// node_modules/eth-json-rpc-filters/base-filter.js
var require_base_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var SafeEventEmitter = require_safe_event_emitter().default;
    var BaseFilter = class extends SafeEventEmitter {
      constructor() {
        super();
        this.updates = [];
      }
      async initialize() {
      }
      async update() {
        throw new Error("BaseFilter - no update method specified");
      }
      addResults(newResults) {
        this.updates = this.updates.concat(newResults);
        newResults.forEach((result) => this.emit("update", result));
      }
      addInitialResults(newResults) {
      }
      getChangesAndClear() {
        const updates = this.updates;
        this.updates = [];
        return updates;
      }
    };
    module.exports = BaseFilter;
  }
});

// node_modules/eth-json-rpc-filters/base-filter-history.js
var require_base_filter_history = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter-history.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BaseFilter = require_base_filter();
    var BaseFilterWithHistory = class extends BaseFilter {
      constructor() {
        super();
        this.allResults = [];
      }
      async update() {
        throw new Error("BaseFilterWithHistory - no update method specified");
      }
      addResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addResults(newResults);
      }
      addInitialResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addInitialResults(newResults);
      }
      getAllResults() {
        return this.allResults;
      }
    };
    module.exports = BaseFilterWithHistory;
  }
});

// node_modules/eth-json-rpc-filters/hexUtils.js
var require_hexUtils = __commonJS({
  "node_modules/eth-json-rpc-filters/hexUtils.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = {
      minBlockRef,
      maxBlockRef,
      sortBlockRefs,
      bnToHex,
      blockRefIsNumber,
      hexToInt,
      incrementHexInt,
      intToHex,
      unsafeRandomBytes
    };
    function minBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[0];
    }
    function maxBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[sortedRefs.length - 1];
    }
    function sortBlockRefs(refs) {
      return refs.sort((refA, refB) => {
        if (refA === "latest" || refB === "earliest")
          return 1;
        if (refB === "latest" || refA === "earliest")
          return -1;
        return hexToInt(refA) - hexToInt(refB);
      });
    }
    function bnToHex(bn) {
      return "0x" + bn.toString(16);
    }
    function blockRefIsNumber(blockRef) {
      return blockRef && !["earliest", "latest", "pending"].includes(blockRef);
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function incrementHexInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      const value = hexToInt(hexString);
      return intToHex(value + 1);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      let hexString = int.toString(16);
      const needsLeftPad = hexString.length % 2;
      if (needsLeftPad)
        hexString = "0" + hexString;
      return "0x" + hexString;
    }
    function unsafeRandomBytes(byteCount) {
      let result = "0x";
      for (let i5 = 0; i5 < byteCount; i5++) {
        result += unsafeRandomNibble();
        result += unsafeRandomNibble();
      }
      return result;
    }
    function unsafeRandomNibble() {
      return Math.floor(Math.random() * 16).toString(16);
    }
  }
});

// node_modules/eth-json-rpc-filters/log-filter.js
var require_log_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/log-filter.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var EthQuery = require_eth_query();
    var pify = require_pify2();
    var BaseFilterWithHistory = require_base_filter_history();
    var { bnToHex, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require_hexUtils();
    var LogFilter = class extends BaseFilterWithHistory {
      constructor({ provider, params }) {
        super();
        this.type = "log";
        this.ethQuery = new EthQuery(provider);
        this.params = Object.assign({
          fromBlock: "latest",
          toBlock: "latest",
          address: void 0,
          topics: []
        }, params);
        if (this.params.address) {
          if (!Array.isArray(this.params.address)) {
            this.params.address = [this.params.address];
          }
          this.params.address = this.params.address.map((address) => address.toLowerCase());
        }
      }
      async initialize({ currentBlock }) {
        let fromBlock = this.params.fromBlock;
        if (["latest", "pending"].includes(fromBlock))
          fromBlock = currentBlock;
        if ("earliest" === fromBlock)
          fromBlock = "0x0";
        this.params.fromBlock = fromBlock;
        const toBlock = minBlockRef(this.params.toBlock, currentBlock);
        const params = Object.assign({}, this.params, { toBlock });
        const newLogs = await this._fetchLogs(params);
        this.addInitialResults(newLogs);
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        let fromBlock;
        if (oldBlock) {
          fromBlock = incrementHexInt(oldBlock);
        } else {
          fromBlock = newBlock;
        }
        const params = Object.assign({}, this.params, { fromBlock, toBlock });
        const newLogs = await this._fetchLogs(params);
        const matchingLogs = newLogs.filter((log2) => this.matchLog(log2));
        this.addResults(matchingLogs);
      }
      async _fetchLogs(params) {
        const newLogs = await pify((cb) => this.ethQuery.getLogs(params, cb))();
        return newLogs;
      }
      matchLog(log2) {
        if (hexToInt(this.params.fromBlock) >= hexToInt(log2.blockNumber))
          return false;
        if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log2.blockNumber))
          return false;
        const normalizedLogAddress = log2.address && log2.address.toLowerCase();
        if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress))
          return false;
        const topicsMatch = this.params.topics.every((topicPattern, index) => {
          let logTopic = log2.topics[index];
          if (!logTopic)
            return false;
          logTopic = logTopic.toLowerCase();
          let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
          const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
          if (subtopicsIncludeWildcard)
            return true;
          subtopicsToMatch = subtopicsToMatch.map((topic) => topic.toLowerCase());
          const topicDoesMatch = subtopicsToMatch.includes(logTopic);
          return topicDoesMatch;
        });
        return topicsMatch;
      }
    };
    module.exports = LogFilter;
  }
});

// node_modules/eth-json-rpc-filters/getBlocksForRange.js
var require_getBlocksForRange = __commonJS({
  "node_modules/eth-json-rpc-filters/getBlocksForRange.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = getBlocksForRange;
    async function getBlocksForRange({ provider, fromBlock, toBlock }) {
      if (!fromBlock)
        fromBlock = toBlock;
      const fromBlockNumber = hexToInt(fromBlock);
      const toBlockNumber = hexToInt(toBlock);
      const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
      const missingBlockNumbers = Array(blockCountToQuery).fill().map((_6, index) => fromBlockNumber + index).map(intToHex);
      const blockBodies = await Promise.all(
        missingBlockNumbers.map((blockNum) => query(provider, "eth_getBlockByNumber", [blockNum, false]))
      );
      return blockBodies;
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      const hexString = int.toString(16);
      return "0x" + hexString;
    }
    function query(provider, method, params) {
      return new Promise((resolve, reject) => {
        provider.sendAsync({ id: 1, jsonrpc: "2.0", method, params }, (err, res) => {
          if (err)
            return reject(err);
          resolve(res.result);
        });
      });
    }
  }
});

// node_modules/eth-json-rpc-filters/block-filter.js
var require_block_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/block-filter.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var BlockFilter = class extends BaseFilter {
      constructor({ provider, params }) {
        super();
        this.type = "block";
        this.provider = provider;
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blockBodies = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockHashes = blockBodies.map((block) => block.hash);
        this.addResults(blockHashes);
      }
    };
    module.exports = BlockFilter;
  }
});

// node_modules/eth-json-rpc-filters/tx-filter.js
var require_tx_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/tx-filter.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var TxFilter = class extends BaseFilter {
      constructor({ provider }) {
        super();
        this.type = "tx";
        this.provider = provider;
      }
      async update({ oldBlock }) {
        const toBlock = oldBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blocks = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockTxHashes = [];
        for (const block of blocks) {
          blockTxHashes.push(...block.transactions);
        }
        this.addResults(blockTxHashes);
      }
    };
    module.exports = TxFilter;
  }
});

// node_modules/eth-json-rpc-filters/index.js
var require_eth_json_rpc_filters = __commonJS({
  "node_modules/eth-json-rpc-filters/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Mutex = require_lib2().Mutex;
    var { createAsyncMiddleware } = require_dist3();
    var createJsonRpcMiddleware = require_scaffold();
    var LogFilter = require_log_filter();
    var BlockFilter = require_block_filter();
    var TxFilter = require_tx_filter();
    var { intToHex, hexToInt } = require_hexUtils();
    module.exports = createEthFilterMiddleware;
    function createEthFilterMiddleware({ blockTracker, provider }) {
      let filterIndex = 0;
      let filters = {};
      const mutex = new Mutex();
      const waitForFree = mutexMiddlewareWrapper({ mutex });
      const middleware = createJsonRpcMiddleware({
        eth_newFilter: waitForFree(toFilterCreationMiddleware(newLogFilter)),
        eth_newBlockFilter: waitForFree(toFilterCreationMiddleware(newBlockFilter)),
        eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
        eth_uninstallFilter: waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
        eth_getFilterChanges: waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
        eth_getFilterLogs: waitForFree(toAsyncRpcMiddleware(getFilterLogs))
      });
      const filterUpdater = async ({ oldBlock, newBlock }) => {
        if (filters.length === 0)
          return;
        const releaseLock = await mutex.acquire();
        try {
          await Promise.all(objValues(filters).map(async (filter2) => {
            try {
              await filter2.update({ oldBlock, newBlock });
            } catch (err) {
              console.error(err);
            }
          }));
        } catch (err) {
          console.error(err);
        }
        releaseLock();
      };
      middleware.newLogFilter = newLogFilter;
      middleware.newBlockFilter = newBlockFilter;
      middleware.newPendingTransactionFilter = newPendingTransactionFilter;
      middleware.uninstallFilter = uninstallFilterHandler;
      middleware.getFilterChanges = getFilterChanges;
      middleware.getFilterLogs = getFilterLogs;
      middleware.destroy = () => {
        uninstallAllFilters();
      };
      return middleware;
      async function newLogFilter(params) {
        const filter2 = new LogFilter({ provider, params });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function newBlockFilter() {
        const filter2 = new BlockFilter({ provider });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function newPendingTransactionFilter() {
        const filter2 = new TxFilter({ provider });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function getFilterChanges(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        if (!filter2) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        const results2 = filter2.getChangesAndClear();
        return results2;
      }
      async function getFilterLogs(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        if (!filter2) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        if (filter2.type === "log") {
          results = filter2.getAllResults();
        } else {
          results = [];
        }
        return results;
      }
      async function uninstallFilterHandler(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        const result = Boolean(filter2);
        if (result) {
          await uninstallFilter(filterIndex2);
        }
        return result;
      }
      async function installFilter(filter2) {
        const prevFilterCount = objValues(filters).length;
        const currentBlock = await blockTracker.getLatestBlock();
        await filter2.initialize({ currentBlock });
        filterIndex++;
        filters[filterIndex] = filter2;
        filter2.id = filterIndex;
        filter2.idHex = intToHex(filterIndex);
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
        return filterIndex;
      }
      async function uninstallFilter(filterIndex2) {
        const prevFilterCount = objValues(filters).length;
        delete filters[filterIndex2];
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
      }
      async function uninstallAllFilters() {
        const prevFilterCount = objValues(filters).length;
        filters = {};
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 });
      }
      function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
        if (prevFilterCount === 0 && newFilterCount > 0) {
          blockTracker.on("sync", filterUpdater);
          return;
        }
        if (prevFilterCount > 0 && newFilterCount === 0) {
          blockTracker.removeListener("sync", filterUpdater);
          return;
        }
      }
    }
    function toFilterCreationMiddleware(createFilterFn) {
      return toAsyncRpcMiddleware(async (...args) => {
        const filter2 = await createFilterFn(...args);
        const result = intToHex(filter2.id);
        return result;
      });
    }
    function toAsyncRpcMiddleware(asyncFn) {
      return createAsyncMiddleware(async (req, res) => {
        const result = await asyncFn.apply(null, req.params);
        res.result = result;
      });
    }
    function mutexMiddlewareWrapper({ mutex }) {
      return (middleware) => {
        return async (req, res, next, end) => {
          const releaseLock = await mutex.acquire();
          releaseLock();
          middleware(req, res, next, end);
        };
      };
    }
    function objValues(obj, fn) {
      const values = [];
      for (let key in obj) {
        values.push(obj[key]);
      }
      return values;
    }
  }
});

// node_modules/eth-json-rpc-filters/subscriptionManager.js
var require_subscriptionManager = __commonJS({
  "node_modules/eth-json-rpc-filters/subscriptionManager.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var SafeEventEmitter = require_safe_event_emitter().default;
    var createScaffoldMiddleware = require_scaffold();
    var { createAsyncMiddleware } = require_dist3();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var { unsafeRandomBytes, incrementHexInt } = require_hexUtils();
    var getBlocksForRange = require_getBlocksForRange();
    module.exports = createSubscriptionMiddleware;
    function createSubscriptionMiddleware({ blockTracker, provider }) {
      const subscriptions = {};
      const filterManager = createFilterMiddleware({ blockTracker, provider });
      let isDestroyed = false;
      const events = new SafeEventEmitter();
      const middleware = createScaffoldMiddleware({
        eth_subscribe: createAsyncMiddleware(subscribe),
        eth_unsubscribe: createAsyncMiddleware(unsubscribe)
      });
      middleware.destroy = destroy;
      return { events, middleware };
      async function subscribe(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const subscriptionType = req.params[0];
        const subId = unsafeRandomBytes(16);
        let sub;
        switch (subscriptionType) {
          case "newHeads":
            sub = createSubNewHeads({ subId });
            break;
          case "logs":
            const filterParams = req.params[1];
            const filter2 = await filterManager.newLogFilter(filterParams);
            sub = createSubFromFilter({ subId, filter: filter2 });
            break;
          default:
            throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`);
        }
        subscriptions[subId] = sub;
        res.result = subId;
        return;
        function createSubNewHeads({ subId: subId2 }) {
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              blockTracker.removeListener("sync", sub2.update);
            },
            update: async ({ oldBlock, newBlock }) => {
              const toBlock = newBlock;
              const fromBlock = incrementHexInt(oldBlock);
              const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock });
              const results2 = rawBlocks.map(normalizeBlock);
              results2.forEach((value) => {
                _emitSubscriptionResult(subId2, value);
              });
            }
          };
          blockTracker.on("sync", sub2.update);
          return sub2;
        }
        function createSubFromFilter({ subId: subId2, filter: filter2 }) {
          filter2.on("update", (result) => _emitSubscriptionResult(subId2, result));
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              return await filterManager.uninstallFilter(filter2.idHex);
            }
          };
          return sub2;
        }
      }
      async function unsubscribe(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const id = req.params[0];
        const subscription = subscriptions[id];
        if (!subscription) {
          res.result = false;
          return;
        }
        delete subscriptions[id];
        await subscription.destroy();
        res.result = true;
      }
      function _emitSubscriptionResult(filterIdHex, value) {
        events.emit("notification", {
          jsonrpc: "2.0",
          method: "eth_subscription",
          params: {
            subscription: filterIdHex,
            result: value
          }
        });
      }
      function destroy() {
        events.removeAllListeners();
        for (const id in subscriptions) {
          subscriptions[id].destroy();
          delete subscriptions[id];
        }
        isDestroyed = true;
      }
    }
    function normalizeBlock(block) {
      return {
        hash: block.hash,
        parentHash: block.parentHash,
        sha3Uncles: block.sha3Uncles,
        miner: block.miner,
        stateRoot: block.stateRoot,
        transactionsRoot: block.transactionsRoot,
        receiptsRoot: block.receiptsRoot,
        logsBloom: block.logsBloom,
        difficulty: block.difficulty,
        number: block.number,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed,
        nonce: block.nonce,
        mixHash: block.mixHash,
        timestamp: block.timestamp,
        extraData: block.extraData
      };
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/SubscriptionManager.js
var require_SubscriptionManager = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/SubscriptionManager.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionManager = void 0;
    var PollingBlockTracker = require_polling();
    var createSubscriptionManager = require_subscriptionManager();
    var noop4 = () => {
    };
    var SubscriptionManager = class {
      constructor(provider) {
        const blockTracker = new PollingBlockTracker({
          provider,
          pollingInterval: 15 * 1e3,
          setSkipCacheFlag: true
        });
        const { events, middleware } = createSubscriptionManager({
          blockTracker,
          provider
        });
        this.events = events;
        this.subscriptionMiddleware = middleware;
      }
      async handleRequest(request3) {
        const result = {};
        await this.subscriptionMiddleware(request3, result, noop4, noop4);
        return result;
      }
      destroy() {
        this.subscriptionMiddleware.destroy();
      }
    };
    exports.SubscriptionManager = SubscriptionManager;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/CoinbaseWalletProvider.js
var require_CoinbaseWalletProvider = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/CoinbaseWalletProvider.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinbaseWalletProvider = void 0;
    var safe_event_emitter_1 = __importDefault2(require_safe_event_emitter());
    var bn_js_1 = __importDefault2(require_bn3());
    var eth_rpc_errors_1 = require_dist();
    var DiagnosticLogger_1 = require_DiagnosticLogger();
    var Session_1 = require_Session();
    var WalletSDKRelayAbstract_1 = require_WalletSDKRelayAbstract();
    var util_1 = require_util3();
    var eth_eip712_util_1 = __importDefault2(require_eth_eip712_util());
    var FilterPolyfill_1 = require_FilterPolyfill();
    var JSONRPC_1 = require_JSONRPC();
    var SubscriptionManager_1 = require_SubscriptionManager();
    var DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
    var DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
    var WHITELISTED_NETWORK_CHAIN_ID = [
      1,
      10,
      137,
      61,
      56,
      250,
      42161,
      100,
      43114,
      3,
      4,
      5,
      42,
      69,
      80001,
      97,
      4002,
      421611,
      43113
    ];
    var CoinbaseWalletProvider2 = class extends safe_event_emitter_1.default {
      constructor(options) {
        var _a, _b;
        super();
        this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);
        this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);
        this._relay = null;
        this._addresses = [];
        this.hasMadeFirstChainChangedEmission = false;
        this._send = this.send.bind(this);
        this._sendAsync = this.sendAsync.bind(this);
        this.setProviderInfo = this.setProviderInfo.bind(this);
        this.updateProviderInfo = this.updateProviderInfo.bind(this);
        this.getChainId = this.getChainId.bind(this);
        this.setAppInfo = this.setAppInfo.bind(this);
        this.enable = this.enable.bind(this);
        this.close = this.close.bind(this);
        this.send = this.send.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        this.request = this.request.bind(this);
        this._setAddresses = this._setAddresses.bind(this);
        this.scanQRCode = this.scanQRCode.bind(this);
        this.genericRequest = this.genericRequest.bind(this);
        this._chainIdFromOpts = options.chainId;
        this._jsonRpcUrlFromOpts = options.jsonRpcUrl;
        this._overrideIsMetaMask = options.overrideIsMetaMask;
        this._relayProvider = options.relayProvider;
        this._storage = options.storage;
        this._relayEventManager = options.relayEventManager;
        this.diagnostic = options.diagnosticLogger;
        this.reloadOnDisconnect = true;
        this.isCoinbaseWallet = (_a = options.overrideIsCoinbaseWallet) !== null && _a !== void 0 ? _a : true;
        this.isCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
        this.qrUrl = options.qrUrl;
        this.supportsAddressSwitching = options.supportsAddressSwitching;
        this.isLedger = options.isLedger;
        const chainId = this.getChainId();
        const chainIdStr = (0, util_1.prepend0x)(chainId.toString(16));
        this.emit("connect", { chainIdStr });
        const cachedAddresses = this._storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
        if (cachedAddresses) {
          const addresses = cachedAddresses.split(" ");
          if (addresses[0] !== "") {
            this._addresses = addresses.map((address) => (0, util_1.ensureAddressString)(address));
            this.emit("accountsChanged", addresses);
          }
        }
        this._subscriptionManager.events.on("notification", (notification) => {
          this.emit("message", {
            type: notification.method,
            data: notification.params
          });
        });
        if (this._addresses.length > 0) {
          void this.initializeRelay();
        }
        window.addEventListener("message", (event) => {
          var _a2;
          if (event.origin !== location.origin || event.source !== window) {
            return;
          }
          if (event.data.type !== "walletLinkMessage")
            return;
          if (event.data.data.action === "defaultChainChanged" || event.data.data.action === "dappChainSwitched") {
            const _chainId = event.data.data.chainId;
            const jsonRpcUrl = (_a2 = event.data.data.jsonRpcUrl) !== null && _a2 !== void 0 ? _a2 : this.jsonRpcUrl;
            this.updateProviderInfo(jsonRpcUrl, Number(_chainId));
          }
          if (event.data.data.action === "addressChanged") {
            this._setAddresses([event.data.data.address]);
          }
        });
      }
      get selectedAddress() {
        return this._addresses[0] || void 0;
      }
      get networkVersion() {
        return this.getChainId().toString(10);
      }
      get chainId() {
        return (0, util_1.prepend0x)(this.getChainId().toString(16));
      }
      get isWalletLink() {
        return true;
      }
      get isMetaMask() {
        return this._overrideIsMetaMask;
      }
      get host() {
        return this.jsonRpcUrl;
      }
      get connected() {
        return true;
      }
      isConnected() {
        return true;
      }
      get jsonRpcUrl() {
        var _a;
        return (_a = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a !== void 0 ? _a : this._jsonRpcUrlFromOpts;
      }
      set jsonRpcUrl(value) {
        this._storage.setItem(DEFAULT_JSON_RPC_URL, value);
      }
      disableReloadOnDisconnect() {
        this.reloadOnDisconnect = false;
      }
      setProviderInfo(jsonRpcUrl, chainId) {
        if (!(this.isLedger || this.isCoinbaseBrowser)) {
          this._chainIdFromOpts = chainId;
          this._jsonRpcUrlFromOpts = jsonRpcUrl;
        }
        this.updateProviderInfo(this._jsonRpcUrlFromOpts, this._chainIdFromOpts);
      }
      updateProviderInfo(jsonRpcUrl, chainId) {
        this.jsonRpcUrl = jsonRpcUrl;
        const originalChainId = this.getChainId();
        this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
        const chainChanged = (0, util_1.ensureIntNumber)(chainId) !== originalChainId;
        if (chainChanged || !this.hasMadeFirstChainChangedEmission) {
          this.emit("chainChanged", this.getChainId());
          this.hasMadeFirstChainChangedEmission = true;
        }
      }
      async watchAsset(type2, address, symbol, decimals, image, chainId) {
        const relay = await this.initializeRelay();
        const result = await relay.watchAsset(type2, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString()).promise;
        return !!result.result;
      }
      async addEthereumChain(chainId, rpcUrls, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {
        var _a, _b;
        if ((0, util_1.ensureIntNumber)(chainId) === this.getChainId()) {
          return false;
        }
        const relay = await this.initializeRelay();
        const isWhitelistedNetworkOrStandalone = relay.inlineAddEthereumChain(chainId.toString());
        if (!this._isAuthorized() && !isWhitelistedNetworkOrStandalone) {
          await relay.requestEthereumAccounts().promise;
        }
        const res = await relay.addEthereumChain(chainId.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency).promise;
        if (((_a = res.result) === null || _a === void 0 ? void 0 : _a.isApproved) === true) {
          this.updateProviderInfo(rpcUrls[0], chainId);
        }
        return ((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true;
      }
      async switchEthereumChain(chainId) {
        if (WHITELISTED_NETWORK_CHAIN_ID.includes(chainId)) {
          this.updateProviderInfo(this.jsonRpcUrl, chainId);
        }
        const relay = await this.initializeRelay();
        const res = await relay.switchEthereumChain(chainId.toString(10), this.selectedAddress || void 0).promise;
        if (res.errorCode) {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: res.errorCode
          });
        }
        const switchResponse = res.result;
        if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
          this.updateProviderInfo(switchResponse.rpcUrl, chainId);
        }
      }
      setAppInfo(appName, appLogoUrl) {
        void this.initializeRelay().then((relay) => relay.setAppInfo(appName, appLogoUrl));
      }
      async enable() {
        var _a;
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::enable",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : void 0
        });
        if (this._addresses.length > 0) {
          return [...this._addresses];
        }
        return await this._send(JSONRPC_1.JSONRPCMethod.eth_requestAccounts);
      }
      async close() {
        const relay = await this.initializeRelay();
        relay.resetAndReload();
      }
      send(requestOrMethod, callbackOrParams) {
        if (typeof requestOrMethod === "string") {
          const method = requestOrMethod;
          const params = Array.isArray(callbackOrParams) ? callbackOrParams : callbackOrParams !== void 0 ? [callbackOrParams] : [];
          const request3 = {
            jsonrpc: "2.0",
            id: 0,
            method,
            params
          };
          return this._sendRequestAsync(request3).then((res) => res.result);
        }
        if (typeof callbackOrParams === "function") {
          const request3 = requestOrMethod;
          const callback = callbackOrParams;
          return this._sendAsync(request3, callback);
        }
        if (Array.isArray(requestOrMethod)) {
          const requests = requestOrMethod;
          return requests.map((r6) => this._sendRequest(r6));
        }
        const req = requestOrMethod;
        return this._sendRequest(req);
      }
      async sendAsync(request3, callback) {
        if (typeof callback !== "function") {
          throw new Error("callback is required");
        }
        if (Array.isArray(request3)) {
          const arrayCb = callback;
          this._sendMultipleRequestsAsync(request3).then((responses) => arrayCb(null, responses)).catch((err) => arrayCb(err, null));
          return;
        }
        const cb = callback;
        return this._sendRequestAsync(request3).then((response) => cb(null, response)).catch((err) => cb(err, null));
      }
      async request(args) {
        if (!args || typeof args !== "object" || Array.isArray(args)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "Expected a single, non-array, object argument.",
            data: args
          });
        }
        const { method, params } = args;
        if (typeof method !== "string" || method.length === 0) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "'args.method' must be a non-empty string.",
            data: args
          });
        }
        if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "'args.params' must be an object or array if provided.",
            data: args
          });
        }
        const newParams = params === void 0 ? [] : params;
        const id = this._relayEventManager.makeRequestId();
        const result = await this._sendRequestAsync({
          method,
          params: newParams,
          jsonrpc: "2.0",
          id
        });
        return result.result;
      }
      async scanQRCode(match) {
        const relay = await this.initializeRelay();
        const res = await relay.scanQRCode((0, util_1.ensureRegExpString)(match)).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      async genericRequest(data, action) {
        const relay = await this.initializeRelay();
        const res = await relay.genericRequest(data, action).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      async selectProvider(providerOptions) {
        const relay = await this.initializeRelay();
        const res = await relay.selectProvider(providerOptions).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      supportsSubscriptions() {
        return false;
      }
      subscribe() {
        throw new Error("Subscriptions are not supported");
      }
      unsubscribe() {
        throw new Error("Subscriptions are not supported");
      }
      disconnect() {
        return true;
      }
      _sendRequest(request3) {
        const response = {
          jsonrpc: "2.0",
          id: request3.id
        };
        const { method } = request3;
        response.result = this._handleSynchronousMethods(request3);
        if (response.result === void 0) {
          throw new Error(`Coinbase Wallet does not support calling ${method} synchronously without a callback. Please provide a callback parameter to call ${method} asynchronously.`);
        }
        return response;
      }
      _setAddresses(addresses, isDisconnect) {
        if (!Array.isArray(addresses)) {
          throw new Error("addresses is not an array");
        }
        const newAddresses = addresses.map((address) => (0, util_1.ensureAddressString)(address));
        if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
          return;
        }
        if (this._addresses.length > 0 && this.supportsAddressSwitching === false && !isDisconnect) {
          return;
        }
        this._addresses = newAddresses;
        this.emit("accountsChanged", this._addresses);
        this._storage.setItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
      }
      _sendRequestAsync(request3) {
        return new Promise((resolve, reject) => {
          try {
            const syncResult = this._handleSynchronousMethods(request3);
            if (syncResult !== void 0) {
              return resolve({
                jsonrpc: "2.0",
                id: request3.id,
                result: syncResult
              });
            }
            const filterPromise = this._handleAsynchronousFilterMethods(request3);
            if (filterPromise !== void 0) {
              filterPromise.then((res) => resolve(Object.assign(Object.assign({}, res), { id: request3.id }))).catch((err) => reject(err));
              return;
            }
            const subscriptionPromise = this._handleSubscriptionMethods(request3);
            if (subscriptionPromise !== void 0) {
              subscriptionPromise.then((res) => resolve({
                jsonrpc: "2.0",
                id: request3.id,
                result: res.result
              })).catch((err) => reject(err));
              return;
            }
          } catch (err) {
            return reject(err);
          }
          this._handleAsynchronousMethods(request3).then((res) => res && resolve(Object.assign(Object.assign({}, res), { id: request3.id }))).catch((err) => reject(err));
        });
      }
      _sendMultipleRequestsAsync(requests) {
        return Promise.all(requests.map((r6) => this._sendRequestAsync(r6)));
      }
      _handleSynchronousMethods(request3) {
        const { method } = request3;
        const params = request3.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_accounts:
            return this._eth_accounts();
          case JSONRPC_1.JSONRPCMethod.eth_coinbase:
            return this._eth_coinbase();
          case JSONRPC_1.JSONRPCMethod.eth_uninstallFilter:
            return this._eth_uninstallFilter(params);
          case JSONRPC_1.JSONRPCMethod.net_version:
            return this._net_version();
          case JSONRPC_1.JSONRPCMethod.eth_chainId:
            return this._eth_chainId();
          default:
            return void 0;
        }
      }
      async _handleAsynchronousMethods(request3) {
        const { method } = request3;
        const params = request3.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_requestAccounts:
            return this._eth_requestAccounts();
          case JSONRPC_1.JSONRPCMethod.eth_sign:
            return this._eth_sign(params);
          case JSONRPC_1.JSONRPCMethod.eth_ecRecover:
            return this._eth_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.personal_sign:
            return this._personal_sign(params);
          case JSONRPC_1.JSONRPCMethod.personal_ecRecover:
            return this._personal_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTransaction:
            return this._eth_signTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:
            return this._eth_sendRawTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:
            return this._eth_sendTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v1:
            return this._eth_signTypedData_v1(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v2:
            return this._throwUnsupportedMethodError();
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v3:
            return this._eth_signTypedData_v3(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v4:
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData:
            return this._eth_signTypedData_v4(params);
          case JSONRPC_1.JSONRPCMethod.cbWallet_arbitrary:
            return this._cbwallet_arbitrary(params);
          case JSONRPC_1.JSONRPCMethod.wallet_addEthereumChain:
            return this._wallet_addEthereumChain(params);
          case JSONRPC_1.JSONRPCMethod.wallet_switchEthereumChain:
            return this._wallet_switchEthereumChain(params);
          case JSONRPC_1.JSONRPCMethod.wallet_watchAsset:
            return this._wallet_watchAsset(params);
        }
        const relay = await this.initializeRelay();
        return relay.makeEthereumJSONRPCRequest(request3, this.jsonRpcUrl);
      }
      _handleAsynchronousFilterMethods(request3) {
        const { method } = request3;
        const params = request3.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_newFilter:
            return this._eth_newFilter(params);
          case JSONRPC_1.JSONRPCMethod.eth_newBlockFilter:
            return this._eth_newBlockFilter();
          case JSONRPC_1.JSONRPCMethod.eth_newPendingTransactionFilter:
            return this._eth_newPendingTransactionFilter();
          case JSONRPC_1.JSONRPCMethod.eth_getFilterChanges:
            return this._eth_getFilterChanges(params);
          case JSONRPC_1.JSONRPCMethod.eth_getFilterLogs:
            return this._eth_getFilterLogs(params);
        }
        return void 0;
      }
      _handleSubscriptionMethods(request3) {
        switch (request3.method) {
          case JSONRPC_1.JSONRPCMethod.eth_subscribe:
          case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:
            return this._subscriptionManager.handleRequest(request3);
        }
        return void 0;
      }
      _isKnownAddress(addressString) {
        try {
          const addressStr = (0, util_1.ensureAddressString)(addressString);
          const lowercaseAddresses = this._addresses.map((address) => (0, util_1.ensureAddressString)(address));
          return lowercaseAddresses.includes(addressStr);
        } catch (_a) {
        }
        return false;
      }
      _ensureKnownAddress(addressString) {
        var _a;
        if (!this._isKnownAddress(addressString)) {
          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED);
          throw new Error("Unknown Ethereum address");
        }
      }
      _prepareTransactionParams(tx) {
        const fromAddress = tx.from ? (0, util_1.ensureAddressString)(tx.from) : this.selectedAddress;
        if (!fromAddress) {
          throw new Error("Ethereum address is unavailable");
        }
        this._ensureKnownAddress(fromAddress);
        const toAddress = tx.to ? (0, util_1.ensureAddressString)(tx.to) : null;
        const weiValue = tx.value != null ? (0, util_1.ensureBN)(tx.value) : new bn_js_1.default(0);
        const data = tx.data ? (0, util_1.ensureBuffer)(tx.data) : Buffer2.alloc(0);
        const nonce = tx.nonce != null ? (0, util_1.ensureIntNumber)(tx.nonce) : null;
        const gasPriceInWei = tx.gasPrice != null ? (0, util_1.ensureBN)(tx.gasPrice) : null;
        const maxFeePerGas = tx.maxFeePerGas != null ? (0, util_1.ensureBN)(tx.maxFeePerGas) : null;
        const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? (0, util_1.ensureBN)(tx.maxPriorityFeePerGas) : null;
        const gasLimit = tx.gas != null ? (0, util_1.ensureBN)(tx.gas) : null;
        const chainId = this.getChainId();
        return {
          fromAddress,
          toAddress,
          weiValue,
          data,
          nonce,
          gasPriceInWei,
          maxFeePerGas,
          maxPriorityFeePerGas,
          gasLimit,
          chainId
        };
      }
      _isAuthorized() {
        return this._addresses.length > 0;
      }
      _requireAuthorization() {
        if (!this._isAuthorized()) {
          throw eth_rpc_errors_1.ethErrors.provider.unauthorized({});
        }
      }
      _throwUnsupportedMethodError() {
        throw eth_rpc_errors_1.ethErrors.provider.unsupportedMethod({});
      }
      async _signEthereumMessage(message, address, addPrefix, typedDataJson) {
        this._ensureKnownAddress(address);
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumMessage(message, address, addPrefix, typedDataJson).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied message signature");
          }
          throw err;
        }
      }
      async _ethereumAddressFromSignedMessage(message, signature, addPrefix) {
        const relay = await this.initializeRelay();
        const res = await relay.ethereumAddressFromSignedMessage(message, signature, addPrefix).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      _eth_accounts() {
        return [...this._addresses];
      }
      _eth_coinbase() {
        return this.selectedAddress || null;
      }
      _net_version() {
        return this.getChainId().toString(10);
      }
      _eth_chainId() {
        return (0, util_1.hexStringFromIntNumber)(this.getChainId());
      }
      getChainId() {
        const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY);
        if (!chainIdStr) {
          return (0, util_1.ensureIntNumber)(this._chainIdFromOpts);
        }
        const chainId = parseInt(chainIdStr, 10);
        return (0, util_1.ensureIntNumber)(chainId);
      }
      async _eth_requestAccounts() {
        var _a;
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::_eth_requestAccounts",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : void 0
        });
        if (this._addresses.length > 0) {
          return Promise.resolve({
            jsonrpc: "2.0",
            id: 0,
            result: this._addresses
          });
        }
        let res;
        try {
          const relay = await this.initializeRelay();
          res = await relay.requestEthereumAccounts().promise;
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied account authorization");
          }
          throw err;
        }
        if (!res.result) {
          throw new Error("accounts received is empty");
        }
        this._setAddresses(res.result);
        if (!(this.isLedger || this.isCoinbaseBrowser)) {
          await this.switchEthereumChain(this.getChainId());
        }
        return { jsonrpc: "2.0", id: 0, result: this._addresses };
      }
      _eth_sign(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const message = (0, util_1.ensureBuffer)(params[1]);
        return this._signEthereumMessage(message, address, false);
      }
      _eth_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature, false);
      }
      _personal_sign(params) {
        this._requireAuthorization();
        const message = (0, util_1.ensureBuffer)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        return this._signEthereumMessage(message, address, true);
      }
      _personal_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature, true);
      }
      async _eth_signTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_sendRawTransaction(params) {
        const signedTransaction = (0, util_1.ensureBuffer)(params[0]);
        const relay = await this.initializeRelay();
        const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId()).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      async _eth_sendTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signAndSubmitEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_signTypedData_v1(params) {
        this._requireAuthorization();
        const typedData = (0, util_1.ensureParsedJSONObject)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v3(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v3({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v4(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v4({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _cbwallet_arbitrary(params) {
        const action = params[0];
        const data = params[1];
        if (typeof data !== "string") {
          throw new Error("parameter must be a string");
        }
        if (typeof action !== "object" || action === null) {
          throw new Error("parameter must be an object");
        }
        const result = await this.genericRequest(action, data);
        return { jsonrpc: "2.0", id: 0, result };
      }
      async _wallet_addEthereumChain(params) {
        var _a, _b, _c, _d;
        const request3 = params[0];
        if (((_a = request3.rpcUrls) === null || _a === void 0 ? void 0 : _a.length) === 0) {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `please pass in at least 1 rpcUrl` }
          };
        }
        if (!request3.chainName || request3.chainName.trim() === "") {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: 0,
            message: "chainName is a required field"
          });
        }
        if (!request3.nativeCurrency) {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: 0,
            message: "nativeCurrency is a required field"
          });
        }
        const chainIdNumber = parseInt(request3.chainId, 16);
        const success = await this.addEthereumChain(chainIdNumber, (_b = request3.rpcUrls) !== null && _b !== void 0 ? _b : [], (_c = request3.blockExplorerUrls) !== null && _c !== void 0 ? _c : [], request3.chainName, (_d = request3.iconUrls) !== null && _d !== void 0 ? _d : [], request3.nativeCurrency);
        if (success) {
          return { jsonrpc: "2.0", id: 0, result: null };
        } else {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `unable to add ethereum chain` }
          };
        }
      }
      async _wallet_switchEthereumChain(params) {
        const request3 = params[0];
        await this.switchEthereumChain(parseInt(request3.chainId, 16));
        return { jsonrpc: "2.0", id: 0, result: null };
      }
      async _wallet_watchAsset(params) {
        const request3 = Array.isArray(params) ? params[0] : params;
        if (!request3.type) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "Type is required"
          });
        }
        if ((request3 === null || request3 === void 0 ? void 0 : request3.type) !== "ERC20") {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Asset of type '${request3.type}' is not supported`
          });
        }
        if (!(request3 === null || request3 === void 0 ? void 0 : request3.options)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "Options are required"
          });
        }
        if (!(request3 === null || request3 === void 0 ? void 0 : request3.options.address)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "Address is required"
          });
        }
        const chainId = this.getChainId();
        const { address, symbol, image, decimals } = request3.options;
        const res = await this.watchAsset(request3.type, address, symbol, decimals, image, chainId);
        return { jsonrpc: "2.0", id: 0, result: res };
      }
      _eth_uninstallFilter(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.uninstallFilter(filterId);
      }
      async _eth_newFilter(params) {
        const param = params[0];
        const filterId = await this._filterPolyfill.newFilter(param);
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newBlockFilter() {
        const filterId = await this._filterPolyfill.newBlockFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newPendingTransactionFilter() {
        const filterId = await this._filterPolyfill.newPendingTransactionFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      _eth_getFilterChanges(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterChanges(filterId);
      }
      _eth_getFilterLogs(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterLogs(filterId);
      }
      initializeRelay() {
        if (this._relay) {
          return Promise.resolve(this._relay);
        }
        return this._relayProvider().then((relay) => {
          relay.setAccountsCallback((accounts, isDisconnect) => this._setAddresses(accounts, isDisconnect));
          relay.setChainCallback((chainId, jsonRpcUrl) => {
            this.updateProviderInfo(jsonRpcUrl, parseInt(chainId, 10));
          });
          relay.setDappDefaultChainCallback(this._chainIdFromOpts);
          this._relay = relay;
          return relay;
        });
      }
    };
    exports.CoinbaseWalletProvider = CoinbaseWalletProvider2;
  }
});

// node_modules/preact/dist/preact.module.js
var preact_module_exports = {};
__export(preact_module_exports, {
  Component: () => d,
  Fragment: () => p,
  cloneElement: () => q,
  createContext: () => B,
  createElement: () => h,
  createRef: () => y,
  h: () => h,
  hydrate: () => S,
  isValidElement: () => i,
  options: () => l,
  render: () => P,
  toChildArray: () => x
});
function s(n3, l5) {
  for (var u5 in l5)
    n3[u5] = l5[u5];
  return n3;
}
function a(n3) {
  var l5 = n3.parentNode;
  l5 && l5.removeChild(n3);
}
function h(l5, u5, i5) {
  var t5, o5, r6, f5 = {};
  for (r6 in u5)
    "key" == r6 ? t5 = u5[r6] : "ref" == r6 ? o5 = u5[r6] : f5[r6] = u5[r6];
  if (arguments.length > 2 && (f5.children = arguments.length > 3 ? n.call(arguments, 2) : i5), "function" == typeof l5 && null != l5.defaultProps)
    for (r6 in l5.defaultProps)
      void 0 === f5[r6] && (f5[r6] = l5.defaultProps[r6]);
  return v(l5, f5, t5, o5, null);
}
function v(n3, i5, t5, o5, r6) {
  var f5 = { type: n3, props: i5, key: t5, ref: o5, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == r6 ? ++u : r6 };
  return null == r6 && null != l.vnode && l.vnode(f5), f5;
}
function y() {
  return { current: null };
}
function p(n3) {
  return n3.children;
}
function d(n3, l5) {
  this.props = n3, this.context = l5;
}
function _(n3, l5) {
  if (null == l5)
    return n3.__ ? _(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
  for (var u5; l5 < n3.__k.length; l5++)
    if (null != (u5 = n3.__k[l5]) && null != u5.__e)
      return u5.__e;
  return "function" == typeof n3.type ? _(n3) : null;
}
function k(n3) {
  var l5, u5;
  if (null != (n3 = n3.__) && null != n3.__c) {
    for (n3.__e = n3.__c.base = null, l5 = 0; l5 < n3.__k.length; l5++)
      if (null != (u5 = n3.__k[l5]) && null != u5.__e) {
        n3.__e = n3.__c.base = u5.__e;
        break;
      }
    return k(n3);
  }
}
function b(n3) {
  (!n3.__d && (n3.__d = true) && t.push(n3) && !g.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || setTimeout)(g);
}
function g() {
  for (var n3; g.__r = t.length; )
    n3 = t.sort(function(n4, l5) {
      return n4.__v.__b - l5.__v.__b;
    }), t = [], n3.some(function(n4) {
      var l5, u5, i5, t5, o5, r6;
      n4.__d && (o5 = (t5 = (l5 = n4).__v).__e, (r6 = l5.__P) && (u5 = [], (i5 = s({}, t5)).__v = t5.__v + 1, j(r6, t5, i5, l5.__n, void 0 !== r6.ownerSVGElement, null != t5.__h ? [o5] : null, u5, null == o5 ? _(t5) : o5, t5.__h), z(u5, t5), t5.__e != o5 && k(t5)));
    });
}
function w(n3, l5, u5, i5, t5, o5, r6, c5, s5, a5) {
  var h5, y5, d5, k5, b4, g5, w6, x5 = i5 && i5.__k || e, C4 = x5.length;
  for (u5.__k = [], h5 = 0; h5 < l5.length; h5++)
    if (null != (k5 = u5.__k[h5] = null == (k5 = l5[h5]) || "boolean" == typeof k5 ? null : "string" == typeof k5 || "number" == typeof k5 || "bigint" == typeof k5 ? v(null, k5, null, null, k5) : Array.isArray(k5) ? v(p, { children: k5 }, null, null, null) : k5.__b > 0 ? v(k5.type, k5.props, k5.key, k5.ref ? k5.ref : null, k5.__v) : k5)) {
      if (k5.__ = u5, k5.__b = u5.__b + 1, null === (d5 = x5[h5]) || d5 && k5.key == d5.key && k5.type === d5.type)
        x5[h5] = void 0;
      else
        for (y5 = 0; y5 < C4; y5++) {
          if ((d5 = x5[y5]) && k5.key == d5.key && k5.type === d5.type) {
            x5[y5] = void 0;
            break;
          }
          d5 = null;
        }
      j(n3, k5, d5 = d5 || f, t5, o5, r6, c5, s5, a5), b4 = k5.__e, (y5 = k5.ref) && d5.ref != y5 && (w6 || (w6 = []), d5.ref && w6.push(d5.ref, null, k5), w6.push(y5, k5.__c || b4, k5)), null != b4 ? (null == g5 && (g5 = b4), "function" == typeof k5.type && k5.__k === d5.__k ? k5.__d = s5 = m(k5, s5, n3) : s5 = A(n3, k5, d5, x5, b4, s5), "function" == typeof u5.type && (u5.__d = s5)) : s5 && d5.__e == s5 && s5.parentNode != n3 && (s5 = _(d5));
    }
  for (u5.__e = g5, h5 = C4; h5--; )
    null != x5[h5] && N(x5[h5], x5[h5]);
  if (w6)
    for (h5 = 0; h5 < w6.length; h5++)
      M(w6[h5], w6[++h5], w6[++h5]);
}
function m(n3, l5, u5) {
  for (var i5, t5 = n3.__k, o5 = 0; t5 && o5 < t5.length; o5++)
    (i5 = t5[o5]) && (i5.__ = n3, l5 = "function" == typeof i5.type ? m(i5, l5, u5) : A(u5, i5, i5, t5, i5.__e, l5));
  return l5;
}
function x(n3, l5) {
  return l5 = l5 || [], null == n3 || "boolean" == typeof n3 || (Array.isArray(n3) ? n3.some(function(n4) {
    x(n4, l5);
  }) : l5.push(n3)), l5;
}
function A(n3, l5, u5, i5, t5, o5) {
  var r6, f5, e5;
  if (void 0 !== l5.__d)
    r6 = l5.__d, l5.__d = void 0;
  else if (null == u5 || t5 != o5 || null == t5.parentNode)
    n:
      if (null == o5 || o5.parentNode !== n3)
        n3.appendChild(t5), r6 = null;
      else {
        for (f5 = o5, e5 = 0; (f5 = f5.nextSibling) && e5 < i5.length; e5 += 2)
          if (f5 == t5)
            break n;
        n3.insertBefore(t5, o5), r6 = o5;
      }
  return void 0 !== r6 ? r6 : t5.nextSibling;
}
function C(n3, l5, u5, i5, t5) {
  var o5;
  for (o5 in u5)
    "children" === o5 || "key" === o5 || o5 in l5 || H(n3, o5, null, u5[o5], i5);
  for (o5 in l5)
    t5 && "function" != typeof l5[o5] || "children" === o5 || "key" === o5 || "value" === o5 || "checked" === o5 || u5[o5] === l5[o5] || H(n3, o5, l5[o5], u5[o5], i5);
}
function $(n3, l5, u5) {
  "-" === l5[0] ? n3.setProperty(l5, u5) : n3[l5] = null == u5 ? "" : "number" != typeof u5 || c.test(l5) ? u5 : u5 + "px";
}
function H(n3, l5, u5, i5, t5) {
  var o5;
  n:
    if ("style" === l5)
      if ("string" == typeof u5)
        n3.style.cssText = u5;
      else {
        if ("string" == typeof i5 && (n3.style.cssText = i5 = ""), i5)
          for (l5 in i5)
            u5 && l5 in u5 || $(n3.style, l5, "");
        if (u5)
          for (l5 in u5)
            i5 && u5[l5] === i5[l5] || $(n3.style, l5, u5[l5]);
      }
    else if ("o" === l5[0] && "n" === l5[1])
      o5 = l5 !== (l5 = l5.replace(/Capture$/, "")), l5 = l5.toLowerCase() in n3 ? l5.toLowerCase().slice(2) : l5.slice(2), n3.l || (n3.l = {}), n3.l[l5 + o5] = u5, u5 ? i5 || n3.addEventListener(l5, o5 ? T : I, o5) : n3.removeEventListener(l5, o5 ? T : I, o5);
    else if ("dangerouslySetInnerHTML" !== l5) {
      if (t5)
        l5 = l5.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("href" !== l5 && "list" !== l5 && "form" !== l5 && "tabIndex" !== l5 && "download" !== l5 && l5 in n3)
        try {
          n3[l5] = null == u5 ? "" : u5;
          break n;
        } catch (n4) {
        }
      "function" == typeof u5 || (null == u5 || false === u5 && -1 == l5.indexOf("-") ? n3.removeAttribute(l5) : n3.setAttribute(l5, u5));
    }
}
function I(n3) {
  this.l[n3.type + false](l.event ? l.event(n3) : n3);
}
function T(n3) {
  this.l[n3.type + true](l.event ? l.event(n3) : n3);
}
function j(n3, u5, i5, t5, o5, r6, f5, e5, c5) {
  var a5, h5, v5, y5, _6, k5, b4, g5, m5, x5, A6, C4, $4, H4, I4, T6 = u5.type;
  if (void 0 !== u5.constructor)
    return null;
  null != i5.__h && (c5 = i5.__h, e5 = u5.__e = i5.__e, u5.__h = null, r6 = [e5]), (a5 = l.__b) && a5(u5);
  try {
    n:
      if ("function" == typeof T6) {
        if (g5 = u5.props, m5 = (a5 = T6.contextType) && t5[a5.__c], x5 = a5 ? m5 ? m5.props.value : a5.__ : t5, i5.__c ? b4 = (h5 = u5.__c = i5.__c).__ = h5.__E : ("prototype" in T6 && T6.prototype.render ? u5.__c = h5 = new T6(g5, x5) : (u5.__c = h5 = new d(g5, x5), h5.constructor = T6, h5.render = O), m5 && m5.sub(h5), h5.props = g5, h5.state || (h5.state = {}), h5.context = x5, h5.__n = t5, v5 = h5.__d = true, h5.__h = [], h5._sb = []), null == h5.__s && (h5.__s = h5.state), null != T6.getDerivedStateFromProps && (h5.__s == h5.state && (h5.__s = s({}, h5.__s)), s(h5.__s, T6.getDerivedStateFromProps(g5, h5.__s))), y5 = h5.props, _6 = h5.state, v5)
          null == T6.getDerivedStateFromProps && null != h5.componentWillMount && h5.componentWillMount(), null != h5.componentDidMount && h5.__h.push(h5.componentDidMount);
        else {
          if (null == T6.getDerivedStateFromProps && g5 !== y5 && null != h5.componentWillReceiveProps && h5.componentWillReceiveProps(g5, x5), !h5.__e && null != h5.shouldComponentUpdate && false === h5.shouldComponentUpdate(g5, h5.__s, x5) || u5.__v === i5.__v) {
            for (h5.props = g5, h5.state = h5.__s, u5.__v !== i5.__v && (h5.__d = false), h5.__v = u5, u5.__e = i5.__e, u5.__k = i5.__k, u5.__k.forEach(function(n4) {
              n4 && (n4.__ = u5);
            }), A6 = 0; A6 < h5._sb.length; A6++)
              h5.__h.push(h5._sb[A6]);
            h5._sb = [], h5.__h.length && f5.push(h5);
            break n;
          }
          null != h5.componentWillUpdate && h5.componentWillUpdate(g5, h5.__s, x5), null != h5.componentDidUpdate && h5.__h.push(function() {
            h5.componentDidUpdate(y5, _6, k5);
          });
        }
        if (h5.context = x5, h5.props = g5, h5.__v = u5, h5.__P = n3, C4 = l.__r, $4 = 0, "prototype" in T6 && T6.prototype.render) {
          for (h5.state = h5.__s, h5.__d = false, C4 && C4(u5), a5 = h5.render(h5.props, h5.state, h5.context), H4 = 0; H4 < h5._sb.length; H4++)
            h5.__h.push(h5._sb[H4]);
          h5._sb = [];
        } else
          do {
            h5.__d = false, C4 && C4(u5), a5 = h5.render(h5.props, h5.state, h5.context), h5.state = h5.__s;
          } while (h5.__d && ++$4 < 25);
        h5.state = h5.__s, null != h5.getChildContext && (t5 = s(s({}, t5), h5.getChildContext())), v5 || null == h5.getSnapshotBeforeUpdate || (k5 = h5.getSnapshotBeforeUpdate(y5, _6)), I4 = null != a5 && a5.type === p && null == a5.key ? a5.props.children : a5, w(n3, Array.isArray(I4) ? I4 : [I4], u5, i5, t5, o5, r6, f5, e5, c5), h5.base = u5.__e, u5.__h = null, h5.__h.length && f5.push(h5), b4 && (h5.__E = h5.__ = null), h5.__e = false;
      } else
        null == r6 && u5.__v === i5.__v ? (u5.__k = i5.__k, u5.__e = i5.__e) : u5.__e = L(i5.__e, u5, i5, t5, o5, r6, f5, c5);
    (a5 = l.diffed) && a5(u5);
  } catch (n4) {
    u5.__v = null, (c5 || null != r6) && (u5.__e = e5, u5.__h = !!c5, r6[r6.indexOf(e5)] = null), l.__e(n4, u5, i5);
  }
}
function z(n3, u5) {
  l.__c && l.__c(u5, n3), n3.some(function(u6) {
    try {
      n3 = u6.__h, u6.__h = [], n3.some(function(n4) {
        n4.call(u6);
      });
    } catch (n4) {
      l.__e(n4, u6.__v);
    }
  });
}
function L(l5, u5, i5, t5, o5, r6, e5, c5) {
  var s5, h5, v5, y5 = i5.props, p5 = u5.props, d5 = u5.type, k5 = 0;
  if ("svg" === d5 && (o5 = true), null != r6) {
    for (; k5 < r6.length; k5++)
      if ((s5 = r6[k5]) && "setAttribute" in s5 == !!d5 && (d5 ? s5.localName === d5 : 3 === s5.nodeType)) {
        l5 = s5, r6[k5] = null;
        break;
      }
  }
  if (null == l5) {
    if (null === d5)
      return document.createTextNode(p5);
    l5 = o5 ? document.createElementNS("http://www.w3.org/2000/svg", d5) : document.createElement(d5, p5.is && p5), r6 = null, c5 = false;
  }
  if (null === d5)
    y5 === p5 || c5 && l5.data === p5 || (l5.data = p5);
  else {
    if (r6 = r6 && n.call(l5.childNodes), h5 = (y5 = i5.props || f).dangerouslySetInnerHTML, v5 = p5.dangerouslySetInnerHTML, !c5) {
      if (null != r6)
        for (y5 = {}, k5 = 0; k5 < l5.attributes.length; k5++)
          y5[l5.attributes[k5].name] = l5.attributes[k5].value;
      (v5 || h5) && (v5 && (h5 && v5.__html == h5.__html || v5.__html === l5.innerHTML) || (l5.innerHTML = v5 && v5.__html || ""));
    }
    if (C(l5, p5, y5, o5, c5), v5)
      u5.__k = [];
    else if (k5 = u5.props.children, w(l5, Array.isArray(k5) ? k5 : [k5], u5, i5, t5, o5 && "foreignObject" !== d5, r6, e5, r6 ? r6[0] : i5.__k && _(i5, 0), c5), null != r6)
      for (k5 = r6.length; k5--; )
        null != r6[k5] && a(r6[k5]);
    c5 || ("value" in p5 && void 0 !== (k5 = p5.value) && (k5 !== l5.value || "progress" === d5 && !k5 || "option" === d5 && k5 !== y5.value) && H(l5, "value", k5, y5.value, false), "checked" in p5 && void 0 !== (k5 = p5.checked) && k5 !== l5.checked && H(l5, "checked", k5, y5.checked, false));
  }
  return l5;
}
function M(n3, u5, i5) {
  try {
    "function" == typeof n3 ? n3(u5) : n3.current = u5;
  } catch (n4) {
    l.__e(n4, i5);
  }
}
function N(n3, u5, i5) {
  var t5, o5;
  if (l.unmount && l.unmount(n3), (t5 = n3.ref) && (t5.current && t5.current !== n3.__e || M(t5, null, u5)), null != (t5 = n3.__c)) {
    if (t5.componentWillUnmount)
      try {
        t5.componentWillUnmount();
      } catch (n4) {
        l.__e(n4, u5);
      }
    t5.base = t5.__P = null, n3.__c = void 0;
  }
  if (t5 = n3.__k)
    for (o5 = 0; o5 < t5.length; o5++)
      t5[o5] && N(t5[o5], u5, i5 || "function" != typeof n3.type);
  i5 || null == n3.__e || a(n3.__e), n3.__ = n3.__e = n3.__d = void 0;
}
function O(n3, l5, u5) {
  return this.constructor(n3, u5);
}
function P(u5, i5, t5) {
  var o5, r6, e5;
  l.__ && l.__(u5, i5), r6 = (o5 = "function" == typeof t5) ? null : t5 && t5.__k || i5.__k, e5 = [], j(i5, u5 = (!o5 && t5 || i5).__k = h(p, null, [u5]), r6 || f, f, void 0 !== i5.ownerSVGElement, !o5 && t5 ? [t5] : r6 ? null : i5.firstChild ? n.call(i5.childNodes) : null, e5, !o5 && t5 ? t5 : r6 ? r6.__e : i5.firstChild, o5), z(e5, u5);
}
function S(n3, l5) {
  P(n3, l5, S);
}
function q(l5, u5, i5) {
  var t5, o5, r6, f5 = s({}, l5.props);
  for (r6 in u5)
    "key" == r6 ? t5 = u5[r6] : "ref" == r6 ? o5 = u5[r6] : f5[r6] = u5[r6];
  return arguments.length > 2 && (f5.children = arguments.length > 3 ? n.call(arguments, 2) : i5), v(l5.type, f5, t5 || l5.key, o5 || l5.ref, null);
}
function B(n3, l5) {
  var u5 = { __c: l5 = "__cC" + r++, __: n3, Consumer: function(n4, l6) {
    return n4.children(l6);
  }, Provider: function(n4) {
    var u6, i5;
    return this.getChildContext || (u6 = [], (i5 = {})[l5] = this, this.getChildContext = function() {
      return i5;
    }, this.shouldComponentUpdate = function(n5) {
      this.props.value !== n5.value && u6.some(b);
    }, this.sub = function(n5) {
      u6.push(n5);
      var l6 = n5.componentWillUnmount;
      n5.componentWillUnmount = function() {
        u6.splice(u6.indexOf(n5), 1), l6 && l6.call(n5);
      };
    }), n4.children;
  } };
  return u5.Provider.__ = u5.Consumer.contextType = u5;
}
var n, l, u, i, t, o, r, f, e, c;
var init_preact_module = __esm({
  "node_modules/preact/dist/preact.module.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    f = {};
    e = [];
    c = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    n = e.slice, l = { __e: function(n3, l5, u5, i5) {
      for (var t5, o5, r6; l5 = l5.__; )
        if ((t5 = l5.__c) && !t5.__)
          try {
            if ((o5 = t5.constructor) && null != o5.getDerivedStateFromError && (t5.setState(o5.getDerivedStateFromError(n3)), r6 = t5.__d), null != t5.componentDidCatch && (t5.componentDidCatch(n3, i5 || {}), r6 = t5.__d), r6)
              return t5.__E = t5;
          } catch (l6) {
            n3 = l6;
          }
      throw n3;
    } }, u = 0, i = function(n3) {
      return null != n3 && void 0 === n3.constructor;
    }, d.prototype.setState = function(n3, l5) {
      var u5;
      u5 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s({}, this.state), "function" == typeof n3 && (n3 = n3(s({}, u5), this.props)), n3 && s(u5, n3), null != n3 && this.__v && (l5 && this._sb.push(l5), b(this));
    }, d.prototype.forceUpdate = function(n3) {
      this.__v && (this.__e = true, n3 && this.__h.push(n3), b(this));
    }, d.prototype.render = p, t = [], g.__r = 0, r = 0;
  }
});

// node_modules/clsx/dist/clsx.m.js
var clsx_m_exports = {};
__export(clsx_m_exports, {
  clsx: () => clsx,
  default: () => clsx_m_default
});
function r2(e5) {
  var t5, f5, n3 = "";
  if ("string" == typeof e5 || "number" == typeof e5)
    n3 += e5;
  else if ("object" == typeof e5)
    if (Array.isArray(e5))
      for (t5 = 0; t5 < e5.length; t5++)
        e5[t5] && (f5 = r2(e5[t5])) && (n3 && (n3 += " "), n3 += f5);
    else
      for (t5 in e5)
        e5[t5] && (n3 && (n3 += " "), n3 += t5);
  return n3;
}
function clsx() {
  for (var e5, t5, f5 = 0, n3 = ""; f5 < arguments.length; )
    (e5 = arguments[f5++]) && (t5 = r2(e5)) && (n3 && (n3 += " "), n3 += t5);
  return n3;
}
var clsx_m_default;
var init_clsx_m = __esm({
  "node_modules/clsx/dist/clsx.m.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    clsx_m_default = clsx;
  }
});

// node_modules/preact/hooks/dist/hooks.module.js
var hooks_module_exports = {};
__export(hooks_module_exports, {
  useCallback: () => T2,
  useContext: () => q2,
  useDebugValue: () => x2,
  useEffect: () => h2,
  useErrorBoundary: () => P2,
  useId: () => V,
  useImperativeHandle: () => A2,
  useLayoutEffect: () => s2,
  useMemo: () => F,
  useReducer: () => y2,
  useRef: () => _2,
  useState: () => p2
});
function d2(t5, u5) {
  l.__h && l.__h(r3, t5, o2 || u5), o2 = 0;
  var i5 = r3.__H || (r3.__H = { __: [], __h: [] });
  return t5 >= i5.__.length && i5.__.push({ __V: c2 }), i5.__[t5];
}
function p2(n3) {
  return o2 = 1, y2(B2, n3);
}
function y2(n3, u5, i5) {
  var o5 = d2(t2++, 2);
  if (o5.t = n3, !o5.__c && (o5.__ = [i5 ? i5(u5) : B2(void 0, u5), function(n4) {
    var t5 = o5.__N ? o5.__N[0] : o5.__[0], r6 = o5.t(t5, n4);
    t5 !== r6 && (o5.__N = [r6, o5.__[1]], o5.__c.setState({}));
  }], o5.__c = r3, !r3.u)) {
    r3.u = true;
    var f5 = r3.shouldComponentUpdate;
    r3.shouldComponentUpdate = function(n4, t5, r6) {
      if (!o5.__c.__H)
        return true;
      var u6 = o5.__c.__H.__.filter(function(n5) {
        return n5.__c;
      });
      if (u6.every(function(n5) {
        return !n5.__N;
      }))
        return !f5 || f5.call(this, n4, t5, r6);
      var i6 = false;
      return u6.forEach(function(n5) {
        if (n5.__N) {
          var t6 = n5.__[0];
          n5.__ = n5.__N, n5.__N = void 0, t6 !== n5.__[0] && (i6 = true);
        }
      }), !(!i6 && o5.__c.props === n4) && (!f5 || f5.call(this, n4, t5, r6));
    };
  }
  return o5.__N || o5.__;
}
function h2(u5, i5) {
  var o5 = d2(t2++, 3);
  !l.__s && z2(o5.__H, i5) && (o5.__ = u5, o5.i = i5, r3.__H.__h.push(o5));
}
function s2(u5, i5) {
  var o5 = d2(t2++, 4);
  !l.__s && z2(o5.__H, i5) && (o5.__ = u5, o5.i = i5, r3.__h.push(o5));
}
function _2(n3) {
  return o2 = 5, F(function() {
    return { current: n3 };
  }, []);
}
function A2(n3, t5, r6) {
  o2 = 6, s2(function() {
    return "function" == typeof n3 ? (n3(t5()), function() {
      return n3(null);
    }) : n3 ? (n3.current = t5(), function() {
      return n3.current = null;
    }) : void 0;
  }, null == r6 ? r6 : r6.concat(n3));
}
function F(n3, r6) {
  var u5 = d2(t2++, 7);
  return z2(u5.__H, r6) ? (u5.__V = n3(), u5.i = r6, u5.__h = n3, u5.__V) : u5.__;
}
function T2(n3, t5) {
  return o2 = 8, F(function() {
    return n3;
  }, t5);
}
function q2(n3) {
  var u5 = r3.context[n3.__c], i5 = d2(t2++, 9);
  return i5.c = n3, u5 ? (null == i5.__ && (i5.__ = true, u5.sub(r3)), u5.props.value) : n3.__;
}
function x2(t5, r6) {
  l.useDebugValue && l.useDebugValue(r6 ? r6(t5) : t5);
}
function P2(n3) {
  var u5 = d2(t2++, 10), i5 = p2();
  return u5.__ = n3, r3.componentDidCatch || (r3.componentDidCatch = function(n4, t5) {
    u5.__ && u5.__(n4, t5), i5[1](n4);
  }), [i5[0], function() {
    i5[1](void 0);
  }];
}
function V() {
  var n3 = d2(t2++, 11);
  return n3.__ || (n3.__ = "P" + function(n4) {
    for (var t5 = 0, r6 = n4.length; r6 > 0; )
      t5 = (t5 << 5) - t5 + n4.charCodeAt(--r6) | 0;
    return t5;
  }(r3.__v.__m) + t2), n3.__;
}
function b2() {
  for (var t5; t5 = f2.shift(); )
    if (t5.__P && t5.__H)
      try {
        t5.__H.__h.forEach(k2), t5.__H.__h.forEach(w2), t5.__H.__h = [];
      } catch (r6) {
        t5.__H.__h = [], l.__e(r6, t5.__v);
      }
}
function j2(n3) {
  var t5, r6 = function() {
    clearTimeout(u5), g2 && cancelAnimationFrame(t5), setTimeout(n3);
  }, u5 = setTimeout(r6, 100);
  g2 && (t5 = requestAnimationFrame(r6));
}
function k2(n3) {
  var t5 = r3, u5 = n3.__c;
  "function" == typeof u5 && (n3.__c = void 0, u5()), r3 = t5;
}
function w2(n3) {
  var t5 = r3;
  n3.__c = n3.__(), r3 = t5;
}
function z2(n3, t5) {
  return !n3 || n3.length !== t5.length || t5.some(function(t6, r6) {
    return t6 !== n3[r6];
  });
}
function B2(n3, t5) {
  return "function" == typeof t5 ? t5(n3) : t5;
}
var t2, r3, u2, i2, o2, f2, c2, e2, a2, v2, l2, m2, g2;
var init_hooks_module = __esm({
  "node_modules/preact/hooks/dist/hooks.module.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_preact_module();
    o2 = 0;
    f2 = [];
    c2 = [];
    e2 = l.__b;
    a2 = l.__r;
    v2 = l.diffed;
    l2 = l.__c;
    m2 = l.unmount;
    l.__b = function(n3) {
      "function" != typeof n3.type || n3.__m || null === n3.__ ? n3.__m || (n3.__m = n3.__ && n3.__.__m ? n3.__.__m : "") : n3.__m = (n3.__ && n3.__.__m ? n3.__.__m : "") + (n3.__ && n3.__.__k ? n3.__.__k.indexOf(n3) : 0), r3 = null, e2 && e2(n3);
    }, l.__r = function(n3) {
      a2 && a2(n3), t2 = 0;
      var i5 = (r3 = n3.__c).__H;
      i5 && (u2 === r3 ? (i5.__h = [], r3.__h = [], i5.__.forEach(function(n4) {
        n4.__N && (n4.__ = n4.__N), n4.__V = c2, n4.__N = n4.i = void 0;
      })) : (i5.__h.forEach(k2), i5.__h.forEach(w2), i5.__h = [])), u2 = r3;
    }, l.diffed = function(t5) {
      v2 && v2(t5);
      var o5 = t5.__c;
      o5 && o5.__H && (o5.__H.__h.length && (1 !== f2.push(o5) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o5.__H.__.forEach(function(n3) {
        n3.i && (n3.__H = n3.i), n3.__V !== c2 && (n3.__ = n3.__V), n3.i = void 0, n3.__V = c2;
      })), u2 = r3 = null;
    }, l.__c = function(t5, r6) {
      r6.some(function(t6) {
        try {
          t6.__h.forEach(k2), t6.__h = t6.__h.filter(function(n3) {
            return !n3.__ || w2(n3);
          });
        } catch (u5) {
          r6.some(function(n3) {
            n3.__h && (n3.__h = []);
          }), r6 = [], l.__e(u5, t6.__v);
        }
      }), l2 && l2(t5, r6);
    }, l.unmount = function(t5) {
      m2 && m2(t5);
      var r6, u5 = t5.__c;
      u5 && u5.__H && (u5.__H.__.forEach(function(n3) {
        try {
          k2(n3);
        } catch (n4) {
          r6 = n4;
        }
      }), u5.__H = void 0, r6 && l.__e(r6, u5.__v));
    };
    g2 = "function" == typeof requestAnimationFrame;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/version.js
var require_version = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/version.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LIB_VERSION = void 0;
    exports.LIB_VERSION = "3.5.4";
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/globe-icon-svg.js
var require_globe_icon_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/globe-icon-svg.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTggMEMzLjU4IDAgMCAzLjU4IDAgOHMzLjU4IDggOCA4IDgtMy41OCA4LTgtMy41OC04LTgtOFptNS45MSA3aC0xLjk0Yy0uMS0xLjU3LS40Mi0zLS45MS00LjE1IDEuNDguODggMi41NSAyLjM4IDIuODUgNC4xNVpNOCAxNGMtLjQ1IDAtMS43Mi0xLjc3LTEuOTUtNWgzLjljLS4yMyAzLjIzLTEuNSA1LTEuOTUgNVpNNi4wNSA3QzYuMjggMy43NyA3LjU1IDIgOCAyYy40NSAwIDEuNzIgMS43NyAxLjk1IDVoLTMuOVpNNC45NCAyLjg1QzQuNDYgNCA0LjEzIDUuNDMgNC4wMyA3SDIuMDljLjMtMS43NyAxLjM3LTMuMjcgMi44NS00LjE1Wk0yLjA5IDloMS45NGMuMSAxLjU3LjQyIDMgLjkxIDQuMTVBNS45OTggNS45OTggMCAwIDEgMi4wOSA5Wm04Ljk3IDQuMTVjLjQ4LTEuMTUuODEtMi41OC45MS00LjE1aDEuOTRhNS45OTggNS45OTggMCAwIDEtMi44NSA0LjE1WiIgZmlsbD0iIzE2NTJGMCIvPjwvc3ZnPg==`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/link-icon-svg.js
var require_link_icon_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/link-icon-svg.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE1LjYzNSAyLjExN2EzLjg4OSAzLjg4OSAwIDAgMC01LjUyMSAwTDYuODkgNS4zMzVBMy44OTQgMy44OTQgMCAwIDAgNS44IDguNzM5Yy4wODMuNTA2LjI2OCAxLjAxMS41NTMgMS40NjYuMTUxLjI1My4zMzYuNDcyLjUzNy42OTFsLjYyMS42MjQgMS4xNDEtMS4xNDYtLjYyLS42MjRhMi4xMDUgMi4xMDUgMCAwIDEtLjQ4Ny0uNzQxIDIuMzQgMi4zNCAwIDAgMSAuNTAzLTIuNTFsMy4yMDYtMy4yMmEyLjI5MyAyLjI5MyAwIDAgMSAzLjIzOSAwYy44OS44OTQuODkgMi4zNDMgMCAzLjI1M2wtMS41MjcgMS41MzNjLjIzNC42NC4zMzUgMS4zMzEuMzAyIDIuMDA1bDIuMzgzLTIuMzkyYzEuNTEtMS41MzQgMS40OTMtNC4wMjgtLjAxNy01LjU2MVoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBkPSJNMTEuMjcxIDcuNzQ1YTMuMTMgMy4xMyAwIDAgMC0uNTU0LS42OWwtLjYyLS42MjQtMS4xNDIgMS4xNDYuNjIxLjYyM2MuMjE4LjIyLjM4Ni40ODkuNDg3Ljc1OC4zMzUuODI2LjE2NyAxLjgyLS41MDQgMi40OTRsLTMuMjA1IDMuMjE5YTIuMjkzIDIuMjkzIDAgMCAxLTMuMjQgMCAyLjMxNiAyLjMxNiAwIDAgMSAwLTMuMjUybDEuNTI4LTEuNTM0YTQuODE1IDQuODE1IDAgMCAxLS4yODUtMi4wMDVsLTIuMzgzIDIuMzkzYTMuOTI3IDMuOTI3IDAgMCAwIDAgNS41NDQgMy45MDkgMy45MDkgMCAwIDAgNS41MzggMGwzLjIwNS0zLjIxOWEzLjk1OCAzLjk1OCAwIDAgMCAxLjA5MS0zLjQwNCA0LjIxMSA0LjIxMSAwIDAgMC0uNTM3LTEuNDQ5WiIgZmlsbD0iIzE2NTJGMCIvPjwvc3ZnPg==`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/lock-icon-svg.js
var require_lock_icon_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/lock-icon-svg.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEgN3Y5aDE0VjdIMVptNy41IDQuMzlWMTRoLTF2LTIuNjFjLS40NC0uMTktLjc1LS42My0uNzUtMS4xNGExLjI1IDEuMjUgMCAwIDEgMi41IDBjMCAuNTEtLjMxLjk1LS43NSAxLjE0Wk01LjY3IDZWNC4zM0M1LjY3IDMuMDUgNi43MSAyIDggMnMyLjMzIDEuMDUgMi4zMyAyLjMzVjZoMlY0LjMzQzEyLjMzIDEuOTQgMTAuMzkgMCA4IDBTMy42NyAxLjk0IDMuNjcgNC4zM1Y2aDJaIiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogo.js
var require_QRLogo = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogo.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `<svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="50" cy="50" r="50" fill="white"/>
<circle cx="49.9996" cy="49.9996" r="43.6363" fill="#1B53E4"/>
<circle cx="49.9996" cy="49.9996" r="43.6363" stroke="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M19.3379 49.9484C19.3379 66.8508 33.04 80.553 49.9425 80.553C66.8449 80.553 80.5471 66.8508 80.5471 49.9484C80.5471 33.0459 66.8449 19.3438 49.9425 19.3438C33.04 19.3438 19.3379 33.0459 19.3379 49.9484ZM44.0817 40.0799C41.8725 40.0799 40.0817 41.8708 40.0817 44.0799V55.8029C40.0817 58.012 41.8725 59.8029 44.0817 59.8029H55.8046C58.0138 59.8029 59.8046 58.012 59.8046 55.8029V44.0799C59.8046 41.8708 58.0138 40.0799 55.8046 40.0799H44.0817Z" fill="white"/>
</svg>

`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/qrcode-svg/index.js
var require_qrcode_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/qrcode-svg/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function QR8bitByte(data) {
      this.mode = QRMode.MODE_8BIT_BYTE;
      this.data = data;
      this.parsedData = [];
      for (var i6 = 0, l5 = this.data.length; i6 < l5; i6++) {
        var byteArray = [];
        var code = this.data.charCodeAt(i6);
        if (code > 65536) {
          byteArray[0] = 240 | (code & 1835008) >>> 18;
          byteArray[1] = 128 | (code & 258048) >>> 12;
          byteArray[2] = 128 | (code & 4032) >>> 6;
          byteArray[3] = 128 | code & 63;
        } else if (code > 2048) {
          byteArray[0] = 224 | (code & 61440) >>> 12;
          byteArray[1] = 128 | (code & 4032) >>> 6;
          byteArray[2] = 128 | code & 63;
        } else if (code > 128) {
          byteArray[0] = 192 | (code & 1984) >>> 6;
          byteArray[1] = 128 | code & 63;
        } else {
          byteArray[0] = code;
        }
        this.parsedData.push(byteArray);
      }
      this.parsedData = Array.prototype.concat.apply([], this.parsedData);
      if (this.parsedData.length != this.data.length) {
        this.parsedData.unshift(191);
        this.parsedData.unshift(187);
        this.parsedData.unshift(239);
      }
    }
    QR8bitByte.prototype = {
      getLength: function(buffer2) {
        return this.parsedData.length;
      },
      write: function(buffer2) {
        for (var i6 = 0, l5 = this.parsedData.length; i6 < l5; i6++) {
          buffer2.put(this.parsedData[i6], 8);
        }
      }
    };
    function QRCodeModel(typeNumber, errorCorrectLevel) {
      this.typeNumber = typeNumber;
      this.errorCorrectLevel = errorCorrectLevel;
      this.modules = null;
      this.moduleCount = 0;
      this.dataCache = null;
      this.dataList = [];
    }
    QRCodeModel.prototype = { addData: function(data) {
      var newData = new QR8bitByte(data);
      this.dataList.push(newData);
      this.dataCache = null;
    }, isDark: function(row, col) {
      if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
        throw new Error(row + "," + col);
      }
      return this.modules[row][col];
    }, getModuleCount: function() {
      return this.moduleCount;
    }, make: function() {
      this.makeImpl(false, this.getBestMaskPattern());
    }, makeImpl: function(test, maskPattern) {
      this.moduleCount = this.typeNumber * 4 + 17;
      this.modules = new Array(this.moduleCount);
      for (var row = 0; row < this.moduleCount; row++) {
        this.modules[row] = new Array(this.moduleCount);
        for (var col = 0; col < this.moduleCount; col++) {
          this.modules[row][col] = null;
        }
      }
      this.setupPositionProbePattern(0, 0);
      this.setupPositionProbePattern(this.moduleCount - 7, 0);
      this.setupPositionProbePattern(0, this.moduleCount - 7);
      this.setupPositionAdjustPattern();
      this.setupTimingPattern();
      this.setupTypeInfo(test, maskPattern);
      if (this.typeNumber >= 7) {
        this.setupTypeNumber(test);
      }
      if (this.dataCache == null) {
        this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
      }
      this.mapData(this.dataCache, maskPattern);
    }, setupPositionProbePattern: function(row, col) {
      for (var r6 = -1; r6 <= 7; r6++) {
        if (row + r6 <= -1 || this.moduleCount <= row + r6)
          continue;
        for (var c5 = -1; c5 <= 7; c5++) {
          if (col + c5 <= -1 || this.moduleCount <= col + c5)
            continue;
          if (0 <= r6 && r6 <= 6 && (c5 == 0 || c5 == 6) || 0 <= c5 && c5 <= 6 && (r6 == 0 || r6 == 6) || 2 <= r6 && r6 <= 4 && 2 <= c5 && c5 <= 4) {
            this.modules[row + r6][col + c5] = true;
          } else {
            this.modules[row + r6][col + c5] = false;
          }
        }
      }
    }, getBestMaskPattern: function() {
      var minLostPoint = 0;
      var pattern = 0;
      for (var i6 = 0; i6 < 8; i6++) {
        this.makeImpl(true, i6);
        var lostPoint = QRUtil.getLostPoint(this);
        if (i6 == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i6;
        }
      }
      return pattern;
    }, createMovieClip: function(target_mc, instance_name, depth) {
      var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
      var cs = 1;
      this.make();
      for (var row = 0; row < this.modules.length; row++) {
        var y5 = row * cs;
        for (var col = 0; col < this.modules[row].length; col++) {
          var x5 = col * cs;
          var dark = this.modules[row][col];
          if (dark) {
            qr_mc.beginFill(0, 100);
            qr_mc.moveTo(x5, y5);
            qr_mc.lineTo(x5 + cs, y5);
            qr_mc.lineTo(x5 + cs, y5 + cs);
            qr_mc.lineTo(x5, y5 + cs);
            qr_mc.endFill();
          }
        }
      }
      return qr_mc;
    }, setupTimingPattern: function() {
      for (var r6 = 8; r6 < this.moduleCount - 8; r6++) {
        if (this.modules[r6][6] != null) {
          continue;
        }
        this.modules[r6][6] = r6 % 2 == 0;
      }
      for (var c5 = 8; c5 < this.moduleCount - 8; c5++) {
        if (this.modules[6][c5] != null) {
          continue;
        }
        this.modules[6][c5] = c5 % 2 == 0;
      }
    }, setupPositionAdjustPattern: function() {
      var pos = QRUtil.getPatternPosition(this.typeNumber);
      for (var i6 = 0; i6 < pos.length; i6++) {
        for (var j5 = 0; j5 < pos.length; j5++) {
          var row = pos[i6];
          var col = pos[j5];
          if (this.modules[row][col] != null) {
            continue;
          }
          for (var r6 = -2; r6 <= 2; r6++) {
            for (var c5 = -2; c5 <= 2; c5++) {
              if (r6 == -2 || r6 == 2 || c5 == -2 || c5 == 2 || r6 == 0 && c5 == 0) {
                this.modules[row + r6][col + c5] = true;
              } else {
                this.modules[row + r6][col + c5] = false;
              }
            }
          }
        }
      }
    }, setupTypeNumber: function(test) {
      var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
      for (var i6 = 0; i6 < 18; i6++) {
        var mod = !test && (bits >> i6 & 1) == 1;
        this.modules[Math.floor(i6 / 3)][i6 % 3 + this.moduleCount - 8 - 3] = mod;
      }
      for (var i6 = 0; i6 < 18; i6++) {
        var mod = !test && (bits >> i6 & 1) == 1;
        this.modules[i6 % 3 + this.moduleCount - 8 - 3][Math.floor(i6 / 3)] = mod;
      }
    }, setupTypeInfo: function(test, maskPattern) {
      var data = this.errorCorrectLevel << 3 | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);
      for (var i6 = 0; i6 < 15; i6++) {
        var mod = !test && (bits >> i6 & 1) == 1;
        if (i6 < 6) {
          this.modules[i6][8] = mod;
        } else if (i6 < 8) {
          this.modules[i6 + 1][8] = mod;
        } else {
          this.modules[this.moduleCount - 15 + i6][8] = mod;
        }
      }
      for (var i6 = 0; i6 < 15; i6++) {
        var mod = !test && (bits >> i6 & 1) == 1;
        if (i6 < 8) {
          this.modules[8][this.moduleCount - i6 - 1] = mod;
        } else if (i6 < 9) {
          this.modules[8][15 - i6 - 1 + 1] = mod;
        } else {
          this.modules[8][15 - i6 - 1] = mod;
        }
      }
      this.modules[this.moduleCount - 8][8] = !test;
    }, mapData: function(data, maskPattern) {
      var inc = -1;
      var row = this.moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = this.moduleCount - 1; col > 0; col -= 2) {
        if (col == 6)
          col--;
        while (true) {
          for (var c5 = 0; c5 < 2; c5++) {
            if (this.modules[row][col - c5] == null) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) == 1;
              }
              var mask = QRUtil.getMask(maskPattern, row, col - c5);
              if (mask) {
                dark = !dark;
              }
              this.modules[row][col - c5] = dark;
              bitIndex--;
              if (bitIndex == -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || this.moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    } };
    QRCodeModel.PAD0 = 236;
    QRCodeModel.PAD1 = 17;
    QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
      var buffer2 = new QRBitBuffer();
      for (var i6 = 0; i6 < dataList.length; i6++) {
        var data = dataList[i6];
        buffer2.put(data.mode, 4);
        buffer2.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
        data.write(buffer2);
      }
      var totalDataCount = 0;
      for (var i6 = 0; i6 < rsBlocks.length; i6++) {
        totalDataCount += rsBlocks[i6].dataCount;
      }
      if (buffer2.getLengthInBits() > totalDataCount * 8) {
        throw new Error("code length overflow. (" + buffer2.getLengthInBits() + ">" + totalDataCount * 8 + ")");
      }
      if (buffer2.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer2.put(0, 4);
      }
      while (buffer2.getLengthInBits() % 8 != 0) {
        buffer2.putBit(false);
      }
      while (true) {
        if (buffer2.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer2.put(QRCodeModel.PAD0, 8);
        if (buffer2.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer2.put(QRCodeModel.PAD1, 8);
      }
      return QRCodeModel.createBytes(buffer2, rsBlocks);
    };
    QRCodeModel.createBytes = function(buffer2, rsBlocks) {
      var offset = 0;
      var maxDcCount = 0;
      var maxEcCount = 0;
      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);
      for (var r6 = 0; r6 < rsBlocks.length; r6++) {
        var dcCount = rsBlocks[r6].dataCount;
        var ecCount = rsBlocks[r6].totalCount - dcCount;
        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);
        dcdata[r6] = new Array(dcCount);
        for (var i6 = 0; i6 < dcdata[r6].length; i6++) {
          dcdata[r6][i6] = 255 & buffer2.buffer[i6 + offset];
        }
        offset += dcCount;
        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = new QRPolynomial(dcdata[r6], rsPoly.getLength() - 1);
        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r6] = new Array(rsPoly.getLength() - 1);
        for (var i6 = 0; i6 < ecdata[r6].length; i6++) {
          var modIndex = i6 + modPoly.getLength() - ecdata[r6].length;
          ecdata[r6][i6] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
        }
      }
      var totalCodeCount = 0;
      for (var i6 = 0; i6 < rsBlocks.length; i6++) {
        totalCodeCount += rsBlocks[i6].totalCount;
      }
      var data = new Array(totalCodeCount);
      var index = 0;
      for (var i6 = 0; i6 < maxDcCount; i6++) {
        for (var r6 = 0; r6 < rsBlocks.length; r6++) {
          if (i6 < dcdata[r6].length) {
            data[index++] = dcdata[r6][i6];
          }
        }
      }
      for (var i6 = 0; i6 < maxEcCount; i6++) {
        for (var r6 = 0; r6 < rsBlocks.length; r6++) {
          if (i6 < ecdata[r6].length) {
            data[index++] = ecdata[r6][i6];
          }
        }
      }
      return data;
    };
    var QRMode = { MODE_NUMBER: 1 << 0, MODE_ALPHA_NUM: 1 << 1, MODE_8BIT_BYTE: 1 << 2, MODE_KANJI: 1 << 3 };
    var QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };
    var QRMaskPattern = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
    var QRUtil = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0, G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0, G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1, getBCHTypeInfo: function(data) {
      var d5 = data << 10;
      while (QRUtil.getBCHDigit(d5) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d5 ^= QRUtil.G15 << QRUtil.getBCHDigit(d5) - QRUtil.getBCHDigit(QRUtil.G15);
      }
      return (data << 10 | d5) ^ QRUtil.G15_MASK;
    }, getBCHTypeNumber: function(data) {
      var d5 = data << 12;
      while (QRUtil.getBCHDigit(d5) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d5 ^= QRUtil.G18 << QRUtil.getBCHDigit(d5) - QRUtil.getBCHDigit(QRUtil.G18);
      }
      return data << 12 | d5;
    }, getBCHDigit: function(data) {
      var digit = 0;
      while (data != 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    }, getPatternPosition: function(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    }, getMask: function(maskPattern, i6, j5) {
      switch (maskPattern) {
        case QRMaskPattern.PATTERN000:
          return (i6 + j5) % 2 == 0;
        case QRMaskPattern.PATTERN001:
          return i6 % 2 == 0;
        case QRMaskPattern.PATTERN010:
          return j5 % 3 == 0;
        case QRMaskPattern.PATTERN011:
          return (i6 + j5) % 3 == 0;
        case QRMaskPattern.PATTERN100:
          return (Math.floor(i6 / 2) + Math.floor(j5 / 3)) % 2 == 0;
        case QRMaskPattern.PATTERN101:
          return i6 * j5 % 2 + i6 * j5 % 3 == 0;
        case QRMaskPattern.PATTERN110:
          return (i6 * j5 % 2 + i6 * j5 % 3) % 2 == 0;
        case QRMaskPattern.PATTERN111:
          return (i6 * j5 % 3 + (i6 + j5) % 2) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }, getErrorCorrectPolynomial: function(errorCorrectLength) {
      var a5 = new QRPolynomial([1], 0);
      for (var i6 = 0; i6 < errorCorrectLength; i6++) {
        a5 = a5.multiply(new QRPolynomial([1, QRMath.gexp(i6)], 0));
      }
      return a5;
    }, getLengthInBits: function(mode, type2) {
      if (1 <= type2 && type2 < 10) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 10;
          case QRMode.MODE_ALPHA_NUM:
            return 9;
          case QRMode.MODE_8BIT_BYTE:
            return 8;
          case QRMode.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type2 < 27) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 12;
          case QRMode.MODE_ALPHA_NUM:
            return 11;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type2 < 41) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 14;
          case QRMode.MODE_ALPHA_NUM:
            return 13;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + mode);
        }
      } else {
        throw new Error("type:" + type2);
      }
    }, getLostPoint: function(qrCode) {
      var moduleCount = qrCode.getModuleCount();
      var lostPoint = 0;
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount; col++) {
          var sameCount = 0;
          var dark = qrCode.isDark(row, col);
          for (var r6 = -1; r6 <= 1; r6++) {
            if (row + r6 < 0 || moduleCount <= row + r6) {
              continue;
            }
            for (var c5 = -1; c5 <= 1; c5++) {
              if (col + c5 < 0 || moduleCount <= col + c5) {
                continue;
              }
              if (r6 == 0 && c5 == 0) {
                continue;
              }
              if (dark == qrCode.isDark(row + r6, col + c5)) {
                sameCount++;
              }
            }
          }
          if (sameCount > 5) {
            lostPoint += 3 + sameCount - 5;
          }
        }
      }
      for (var row = 0; row < moduleCount - 1; row++) {
        for (var col = 0; col < moduleCount - 1; col++) {
          var count2 = 0;
          if (qrCode.isDark(row, col))
            count2++;
          if (qrCode.isDark(row + 1, col))
            count2++;
          if (qrCode.isDark(row, col + 1))
            count2++;
          if (qrCode.isDark(row + 1, col + 1))
            count2++;
          if (count2 == 0 || count2 == 4) {
            lostPoint += 3;
          }
        }
      }
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount - 6; col++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
            lostPoint += 40;
          }
        }
      }
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount - 6; row++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
            lostPoint += 40;
          }
        }
      }
      var darkCount = 0;
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount; row++) {
          if (qrCode.isDark(row, col)) {
            darkCount++;
          }
        }
      }
      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    } };
    var QRMath = { glog: function(n3) {
      if (n3 < 1) {
        throw new Error("glog(" + n3 + ")");
      }
      return QRMath.LOG_TABLE[n3];
    }, gexp: function(n3) {
      while (n3 < 0) {
        n3 += 255;
      }
      while (n3 >= 256) {
        n3 -= 255;
      }
      return QRMath.EXP_TABLE[n3];
    }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) };
    for (i5 = 0; i5 < 8; i5++) {
      QRMath.EXP_TABLE[i5] = 1 << i5;
    }
    var i5;
    for (i5 = 8; i5 < 256; i5++) {
      QRMath.EXP_TABLE[i5] = QRMath.EXP_TABLE[i5 - 4] ^ QRMath.EXP_TABLE[i5 - 5] ^ QRMath.EXP_TABLE[i5 - 6] ^ QRMath.EXP_TABLE[i5 - 8];
    }
    var i5;
    for (i5 = 0; i5 < 255; i5++) {
      QRMath.LOG_TABLE[QRMath.EXP_TABLE[i5]] = i5;
    }
    var i5;
    function QRPolynomial(num, shift) {
      if (num.length == void 0) {
        throw new Error(num.length + "/" + shift);
      }
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset++;
      }
      this.num = new Array(num.length - offset + shift);
      for (var i6 = 0; i6 < num.length - offset; i6++) {
        this.num[i6] = num[i6 + offset];
      }
    }
    QRPolynomial.prototype = { get: function(index) {
      return this.num[index];
    }, getLength: function() {
      return this.num.length;
    }, multiply: function(e5) {
      var num = new Array(this.getLength() + e5.getLength() - 1);
      for (var i6 = 0; i6 < this.getLength(); i6++) {
        for (var j5 = 0; j5 < e5.getLength(); j5++) {
          num[i6 + j5] ^= QRMath.gexp(QRMath.glog(this.get(i6)) + QRMath.glog(e5.get(j5)));
        }
      }
      return new QRPolynomial(num, 0);
    }, mod: function(e5) {
      if (this.getLength() - e5.getLength() < 0) {
        return this;
      }
      var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e5.get(0));
      var num = new Array(this.getLength());
      for (var i6 = 0; i6 < this.getLength(); i6++) {
        num[i6] = this.get(i6);
      }
      for (var i6 = 0; i6 < e5.getLength(); i6++) {
        num[i6] ^= QRMath.gexp(QRMath.glog(e5.get(i6)) + ratio);
      }
      return new QRPolynomial(num, 0).mod(e5);
    } };
    function QRRSBlock(totalCount, dataCount) {
      this.totalCount = totalCount;
      this.dataCount = dataCount;
    }
    QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
    QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
      var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
      if (rsBlock == void 0) {
        throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
      }
      var length = rsBlock.length / 3;
      var list = [];
      for (var i6 = 0; i6 < length; i6++) {
        var count2 = rsBlock[i6 * 3 + 0];
        var totalCount = rsBlock[i6 * 3 + 1];
        var dataCount = rsBlock[i6 * 3 + 2];
        for (var j5 = 0; j5 < count2; j5++) {
          list.push(new QRRSBlock(totalCount, dataCount));
        }
      }
      return list;
    };
    QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
      switch (errorCorrectLevel) {
        case QRErrorCorrectLevel.L:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
        case QRErrorCorrectLevel.M:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
        case QRErrorCorrectLevel.Q:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
        case QRErrorCorrectLevel.H:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    function QRBitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    QRBitBuffer.prototype = { get: function(index) {
      var bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
    }, put: function(num, length) {
      for (var i6 = 0; i6 < length; i6++) {
        this.putBit((num >>> length - i6 - 1 & 1) == 1);
      }
    }, getLengthInBits: function() {
      return this.length;
    }, putBit: function(bit) {
      var bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    } };
    var QRCodeLimitLength = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
    function QRCode(options) {
      var instance = this;
      this.options = {
        padding: 4,
        width: 256,
        height: 256,
        typeNumber: 4,
        color: "#000000",
        background: "#ffffff",
        ecl: "M",
        image: {
          svg: "",
          width: 0,
          height: 0
        }
      };
      if (typeof options === "string") {
        options = {
          content: options
        };
      }
      if (options) {
        for (var i6 in options) {
          this.options[i6] = options[i6];
        }
      }
      if (typeof this.options.content !== "string") {
        throw new Error("Expected 'content' as string!");
      }
      if (this.options.content.length === 0) {
        throw new Error("Expected 'content' to be non-empty!");
      }
      if (!(this.options.padding >= 0)) {
        throw new Error("Expected 'padding' value to be non-negative!");
      }
      if (!(this.options.width > 0) || !(this.options.height > 0)) {
        throw new Error("Expected 'width' or 'height' value to be higher than zero!");
      }
      function _getErrorCorrectLevel(ecl2) {
        switch (ecl2) {
          case "L":
            return QRErrorCorrectLevel.L;
          case "M":
            return QRErrorCorrectLevel.M;
          case "Q":
            return QRErrorCorrectLevel.Q;
          case "H":
            return QRErrorCorrectLevel.H;
          default:
            throw new Error("Unknwon error correction level: " + ecl2);
        }
      }
      function _getTypeNumber(content2, ecl2) {
        var length = _getUTF8Length(content2);
        var type3 = 1;
        var limit = 0;
        for (var i7 = 0, len = QRCodeLimitLength.length; i7 <= len; i7++) {
          var table = QRCodeLimitLength[i7];
          if (!table) {
            throw new Error("Content too long: expected " + limit + " but got " + length);
          }
          switch (ecl2) {
            case "L":
              limit = table[0];
              break;
            case "M":
              limit = table[1];
              break;
            case "Q":
              limit = table[2];
              break;
            case "H":
              limit = table[3];
              break;
            default:
              throw new Error("Unknwon error correction level: " + ecl2);
          }
          if (length <= limit) {
            break;
          }
          type3++;
        }
        if (type3 > QRCodeLimitLength.length) {
          throw new Error("Content too long");
        }
        return type3;
      }
      function _getUTF8Length(content2) {
        var result = encodeURI(content2).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
        return result.length + (result.length != content2 ? 3 : 0);
      }
      var content = this.options.content;
      var type2 = _getTypeNumber(content, this.options.ecl);
      var ecl = _getErrorCorrectLevel(this.options.ecl);
      this.qrcode = new QRCodeModel(type2, ecl);
      this.qrcode.addData(content);
      this.qrcode.make();
    }
    QRCode.prototype.svg = function(opt) {
      var options = this.options || {};
      var modules = this.qrcode.modules;
      if (typeof opt == "undefined") {
        opt = { container: options.container || "svg" };
      }
      var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;
      var indent = pretty ? "  " : "";
      var EOL2 = pretty ? "\r\n" : "";
      var width = options.width;
      var height = options.height;
      var length = modules.length;
      var xsize = width / (length + 2 * options.padding);
      var ysize = height / (length + 2 * options.padding);
      var join = typeof options.join != "undefined" ? !!options.join : false;
      var swap3 = typeof options.swap != "undefined" ? !!options.swap : false;
      var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;
      var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
      var defs = predefined ? indent + '<defs><path id="qrmodule" d="M0 0 h' + ysize + " v" + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL2 : "";
      var bgrect = indent + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL2;
      var modrect = "";
      var pathdata = "";
      for (var y5 = 0; y5 < length; y5++) {
        for (var x5 = 0; x5 < length; x5++) {
          var module2 = modules[x5][y5];
          if (module2) {
            var px = x5 * xsize + options.padding * xsize;
            var py = y5 * ysize + options.padding * ysize;
            if (swap3) {
              var t5 = px;
              px = py;
              py = t5;
            }
            if (join) {
              var w6 = xsize + px;
              var h5 = ysize + py;
              px = Number.isInteger(px) ? Number(px) : px.toFixed(2);
              py = Number.isInteger(py) ? Number(py) : py.toFixed(2);
              w6 = Number.isInteger(w6) ? Number(w6) : w6.toFixed(2);
              h5 = Number.isInteger(h5) ? Number(h5) : h5.toFixed(2);
              pathdata += "M" + px + "," + py + " V" + h5 + " H" + w6 + " V" + py + " H" + px + " Z ";
            } else if (predefined) {
              modrect += indent + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL2;
            } else {
              modrect += indent + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL2;
            }
          }
        }
      }
      if (join) {
        modrect = indent + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
      }
      let imgSvg = "";
      if (this.options.image !== void 0 && this.options.image.svg) {
        const imgWidth = width * this.options.image.width / 100;
        const imgHeight = height * this.options.image.height / 100;
        const imgX = width / 2 - imgWidth / 2;
        const imgY = height / 2 - imgHeight / 2;
        imgSvg += `<svg x="${imgX}" y="${imgY}" width="${imgWidth}" height="${imgHeight}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`;
        imgSvg += this.options.image.svg + EOL2;
        imgSvg += "</svg>";
      }
      var svg = "";
      switch (opt.container) {
        case "svg":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL2;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL2;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "svg-viewbox":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL2;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + " " + height + '">' + EOL2;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "g":
          svg += '<g width="' + width + '" height="' + height + '">' + EOL2;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</g>";
          break;
        default:
          svg += (defs + bgrect + modrect + imgSvg).replace(/^\s+/, "");
          break;
      }
      return svg;
    };
    module.exports = QRCode;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/QRCode.js
var require_QRCode = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/QRCode.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QRCode = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var qrcode_svg_1 = __importDefault2(require_qrcode_svg());
    var QRCode = (props) => {
      const [svg, setSvg] = (0, hooks_1.useState)("");
      (0, hooks_1.useEffect)(() => {
        var _a, _b;
        const qrcode = new qrcode_svg_1.default({
          content: props.content,
          background: props.bgColor || "#ffffff",
          color: props.fgColor || "#000000",
          container: "svg",
          ecl: "M",
          width: (_a = props.width) !== null && _a !== void 0 ? _a : 256,
          height: (_b = props.height) !== null && _b !== void 0 ? _b : 256,
          padding: 0,
          image: props.image
        });
        const base64 = Buffer2.from(qrcode.svg(), "utf8").toString("base64");
        setSvg(`data:image/svg+xml;base64,${base64}`);
      });
      return svg ? (0, preact_1.h)("img", { src: svg, alt: "QR Code" }) : null;
    };
    exports.QRCode = QRCode;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Spinner-css.js
var require_Spinner_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Spinner-css.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Spinner.js
var require_Spinner = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Spinner.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Spinner = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var Spinner_css_1 = __importDefault2(require_Spinner_css());
    var Spinner = (props) => {
      var _a;
      const size = (_a = props.size) !== null && _a !== void 0 ? _a : 64;
      const color = props.color || "#000";
      return (0, preact_1.h)(
        "div",
        { class: "-cbwsdk-spinner" },
        (0, preact_1.h)("style", null, Spinner_css_1.default),
        (0, preact_1.h)(
          "svg",
          { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: size, height: size } },
          (0, preact_1.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: color } })
        )
      );
    };
    exports.Spinner = Spinner;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionLinkDialog-css.js
var require_TryExtensionLinkDialog_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionLinkDialog-css.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-cbwsdk-extension-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box{display:flex;position:relative;max-width:500px;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top{display:flex;flex-direction:row;border-radius:8px;overflow:hidden;min-height:300px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top.dark{color:#fff;background-color:#000;box-shadow:0 4px 16px rgba(255,255,255,.05)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top.light{background-color:#fff}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-subtext{margin-top:15px;font-size:12px;line-height:1.5}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-install-region{display:flex;flex-basis:50%;flex-direction:column;justify-content:center;padding:32px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-install-region button{display:block;border-radius:8px;background-color:#1652f0;color:#fff;width:90%;min-width:fit-content;height:44px;margin-top:16px;font-size:16px;padding-left:16px;padding-right:16px;cursor:pointer;font-weight:500;text-align:center}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-install-region button.dark{background-color:#3773f5}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-info-region{display:flex;flex-basis:50%;flex-direction:column;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-info-region.light{background-color:#fafbfc}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-info-region.dark{background-color:#141519}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-description{display:flex;flex-direction:row;align-items:center;padding-top:14px;padding-bottom:14px;padding-left:24px;padding-right:32px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-description-icon-wrapper{display:block;position:relative;width:40px;height:40px;flex-shrink:0;flex-grow:0;border-radius:20px;background-color:#fff;box-shadow:0px 0px 8px rgba(0,0,0,.04),0px 16px 24px rgba(0,0,0,.06)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-description-icon-wrapper img{position:absolute;top:0;bottom:0;left:0;right:0;margin:auto}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-description-text{margin-left:16px;flex-grow:1;font-size:13px;line-height:19px;align-self:center}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-description-text.light{color:#000}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-top-description-text.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom{display:flex;flex-direction:row;overflow:hidden;border-radius:8px;margin-top:8px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom.light{background-color:#fff}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom.dark{background-color:#000;box-shadow:0 4px 16px rgba(255,255,255,.05)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-description-region{display:flex;flex-direction:column;justify-content:center;padding:32px;flex-grow:1}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-description{font-size:13px;line-height:19px;margin-top:12px;color:#aaa}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-description.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-description.dark a{color:#3773f5}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-description a{font-size:inherit;line-height:inherit;color:#1652f0;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-region{position:relative;flex-shrink:0;display:flex;flex-direction:column;justify-content:center;padding-left:24px;padding-right:24px;padding-top:16px;padding-bottom:16px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-wrapper{position:relative;display:block;padding:8px;border-radius:8px;box-shadow:0px 4px 12px rgba(0,0,0,.1);background-color:#fff}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-wrapper img{display:block}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-connecting.light>p{color:#000}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-connecting.dark{background-color:rgba(20,21,25,.9)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-bottom-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel{position:absolute;-webkit-appearance:none;display:flex;align-items:center;justify-content:center;top:16px;right:16px;width:24px;height:24px;border-radius:12px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel.light{background-color:#fafbfc}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel.dark{background-color:#141519}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x.light::before,.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x.light::after{background-color:#000}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x.dark::before,.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x.dark::after{background-color:#fff}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x::before,.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x::after{content:"";position:absolute;display:block;top:-1px;left:-7px;width:14px;height:1px;transition:background-color .2s}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x::before{transform:rotate(45deg)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel-x::after{transform:rotate(135deg)}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel:hover .-cbwsdk-link-dialog-box-cancel-x-a,.-cbwsdk-css-reset .-cbwsdk-extension-dialog-box-cancel:hover .-cbwsdk-link-dialog-box-cancel-x-b{background-color:#000}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-extension-dialog-container-hidden{display:none}.-cbwsdk-css-reset .-cbwsdk-extension-dialog h2{display:block;text-align:left;font-size:22px;font-weight:600;line-height:28px}.-cbwsdk-css-reset .-cbwsdk-extension-dialog h2.light{color:#000}.-cbwsdk-css-reset .-cbwsdk-extension-dialog h2.dark{color:#fff}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionLinkDialog.js
var require_TryExtensionLinkDialog = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionLinkDialog.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TryExtensionLinkDialog = void 0;
    var clsx_1 = __importDefault2((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var util_1 = require_util3();
    var version_1 = require_version();
    var globe_icon_svg_1 = __importDefault2(require_globe_icon_svg());
    var link_icon_svg_1 = __importDefault2(require_link_icon_svg());
    var lock_icon_svg_1 = __importDefault2(require_lock_icon_svg());
    var QRLogo_1 = __importDefault2(require_QRLogo());
    var QRCode_1 = require_QRCode();
    var Spinner_1 = require_Spinner();
    var TryExtensionLinkDialog_css_1 = __importDefault2(require_TryExtensionLinkDialog_css());
    var TryExtensionLinkDialog = (props) => {
      const { isOpen, darkMode } = props;
      const [isContainerHidden, setContainerHidden] = (0, hooks_1.useState)(!isOpen);
      const [isDialogHidden, setDialogHidden] = (0, hooks_1.useState)(!isOpen);
      (0, hooks_1.useEffect)(() => {
        const timers = [
          window.setTimeout(() => {
            setDialogHidden(!isOpen);
          }, 10)
        ];
        if (isOpen) {
          setContainerHidden(false);
        } else {
          timers.push(window.setTimeout(() => {
            setContainerHidden(true);
          }, 360));
        }
        return () => {
          timers.forEach(window.clearTimeout);
        };
      }, [props.isOpen]);
      const theme = darkMode ? "dark" : "light";
      return (0, preact_1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-extension-dialog-container", isContainerHidden && "-cbwsdk-extension-dialog-container-hidden") },
        (0, preact_1.h)("style", null, TryExtensionLinkDialog_css_1.default),
        (0, preact_1.h)("div", { class: (0, clsx_1.default)("-cbwsdk-extension-dialog-backdrop", theme, isDialogHidden && "-cbwsdk-extension-dialog-backdrop-hidden") }),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-extension-dialog" },
          (0, preact_1.h)(
            "div",
            { class: (0, clsx_1.default)("-cbwsdk-extension-dialog-box", isDialogHidden && "-cbwsdk-extension-dialog-box-hidden") },
            (0, preact_1.h)(TryExtensionBox, { darkMode, onInstallClick: () => {
              window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
            } }),
            !props.connectDisabled ? (0, preact_1.h)(ScanQRBox, { darkMode, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, linkAPIUrl: props.linkAPIUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection, chainId: props.chainId }) : null,
            props.onCancel && (0, preact_1.h)(CancelButton, { darkMode, onClick: props.onCancel })
          )
        )
      );
    };
    exports.TryExtensionLinkDialog = TryExtensionLinkDialog;
    var TryExtensionBox = ({ darkMode, onInstallClick }) => {
      const [isClicked, setIsClicked] = (0, hooks_1.useState)(false);
      const clickHandler = (0, hooks_1.useCallback)(() => {
        if (isClicked) {
          window.location.reload();
        } else {
          onInstallClick();
          setIsClicked(true);
        }
      }, [onInstallClick, isClicked]);
      const theme = darkMode ? "dark" : "light";
      return (0, preact_1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-extension-dialog-box-top", theme) },
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-extension-dialog-box-top-install-region" },
          (0, preact_1.h)("h2", { class: theme }, "Try the Coinbase Wallet extension"),
          isClicked && (0, preact_1.h)("div", { class: "-cbwsdk-extension-dialog-box-top-subtext" }, "After installing Coinbase Wallet, refresh the page and connect again."),
          (0, preact_1.h)("button", { type: "button", onClick: clickHandler }, isClicked ? "Refresh" : "Install")
        ),
        (0, preact_1.h)(
          "div",
          { class: (0, clsx_1.default)("-cbwsdk-extension-dialog-box-top-info-region", theme) },
          (0, preact_1.h)(DescriptionItem, { darkMode, icon: link_icon_svg_1.default, text: "Connect to crypto apps with one click" }),
          (0, preact_1.h)(DescriptionItem, { darkMode, icon: lock_icon_svg_1.default, text: "Your private key is stored securely" }),
          (0, preact_1.h)(DescriptionItem, { darkMode, icon: globe_icon_svg_1.default, text: "Works with Ethereum, Polygon, and more" })
        )
      );
    };
    var ScanQRBox = (props) => {
      const qrUrl = (0, util_1.createQrUrl)(props.sessionId, props.sessionSecret, props.linkAPIUrl, props.isParentConnection, props.version, props.chainId);
      const theme = props.darkMode ? "dark" : "light";
      return (0, preact_1.h)(
        "div",
        { "data-testid": "scan-qr-box", class: (0, clsx_1.default)(`-cbwsdk-extension-dialog-box-bottom`, theme) },
        (0, preact_1.h)(
          "div",
          { class: `-cbwsdk-extension-dialog-box-bottom-description-region` },
          (0, preact_1.h)("h2", { class: theme }, "Or scan to connect"),
          (0, preact_1.h)(
            "body",
            { class: (0, clsx_1.default)(`-cbwsdk-extension-dialog-box-bottom-description`, theme) },
            "Open",
            " ",
            (0, preact_1.h)("a", { href: "https://wallet.coinbase.com/", target: "_blank", rel: "noopener noreferrer" }, "Coinbase Wallet"),
            " ",
            "on your mobile phone and scan"
          )
        ),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-extension-dialog-box-bottom-qr-region" },
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-extension-dialog-box-bottom-qr-wrapper" },
            (0, preact_1.h)(QRCode_1.QRCode, { content: qrUrl, width: 150, height: 150, fgColor: "#000", bgColor: "transparent", image: {
              svg: QRLogo_1.default,
              width: 34,
              height: 34
            } })
          ),
          (0, preact_1.h)("input", { type: "hidden", name: "cbwsdk-version", value: version_1.LIB_VERSION }),
          (0, preact_1.h)("input", { type: "hidden", value: qrUrl }),
          !props.isConnected && (0, preact_1.h)(
            "div",
            { "data-testid": "connecting-spinner", class: (0, clsx_1.default)("-cbwsdk-extension-dialog-box-bottom-qr-connecting", theme) },
            (0, preact_1.h)(Spinner_1.Spinner, { size: 36, color: props.darkMode ? "#FFF" : "#000" }),
            (0, preact_1.h)("p", null, "Connecting...")
          )
        )
      );
    };
    var DescriptionItem = (props) => {
      const theme = props.darkMode ? "dark" : "light";
      return (0, preact_1.h)(
        "div",
        { class: "-cbwsdk-extension-dialog-box-top-description" },
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-extension-dialog-box-top-description-icon-wrapper" },
          (0, preact_1.h)("img", { src: props.icon })
        ),
        (0, preact_1.h)("body", { class: (0, clsx_1.default)("-cbwsdk-extension-dialog-box-top-description-text", theme) }, props.text)
      );
    };
    var CancelButton = (props) => {
      const theme = props.darkMode ? "dark" : "light";
      return (0, preact_1.h)(
        "button",
        { type: "button", class: (0, clsx_1.default)("-cbwsdk-extension-dialog-box-cancel", theme), onClick: props.onClick },
        (0, preact_1.h)("div", { class: (0, clsx_1.default)("-cbwsdk-extension-dialog-box-cancel-x", theme) })
      );
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/LinkFlow.js
var require_LinkFlow = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/LinkFlow.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkFlow = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var TryExtensionLinkDialog_1 = require_TryExtensionLinkDialog();
    var LinkFlow = class {
      constructor(options) {
        this.extensionUI$ = new rxjs_1.BehaviorSubject({});
        this.subscriptions = new rxjs_1.Subscription();
        this.isConnected = false;
        this.chainId = 1;
        this.isOpen = false;
        this.onCancel = null;
        this.root = null;
        this.connectDisabled = false;
        this.darkMode = options.darkMode;
        this.version = options.version;
        this.sessionId = options.sessionId;
        this.sessionSecret = options.sessionSecret;
        this.linkAPIUrl = options.linkAPIUrl;
        this.isParentConnection = options.isParentConnection;
        this.connected$ = options.connected$;
        this.chainId$ = options.chainId$;
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-cbwsdk-link-flow-root";
        el.appendChild(this.root);
        this.render();
        this.subscriptions.add(this.connected$.subscribe((v5) => {
          if (this.isConnected !== v5) {
            this.isConnected = v5;
            this.render();
          }
        }));
        this.subscriptions.add(this.chainId$.subscribe((chainId) => {
          if (this.chainId !== chainId) {
            this.chainId = chainId;
            this.render();
          }
        }));
      }
      detach() {
        var _a;
        if (!this.root) {
          return;
        }
        this.subscriptions.unsubscribe();
        (0, preact_1.render)(null, this.root);
        (_a = this.root.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this.root);
      }
      setConnectDisabled(connectDisabled) {
        this.connectDisabled = connectDisabled;
      }
      open(options) {
        this.isOpen = true;
        this.onCancel = options.onCancel;
        this.render();
      }
      close() {
        this.isOpen = false;
        this.onCancel = null;
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        const subscription = this.extensionUI$.subscribe(() => {
          if (!this.root) {
            return;
          }
          (0, preact_1.render)((0, preact_1.h)(TryExtensionLinkDialog_1.TryExtensionLinkDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, linkAPIUrl: this.linkAPIUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, chainId: this.chainId, onCancel: this.onCancel, connectDisabled: this.connectDisabled }), this.root);
        });
        this.subscriptions.add(subscription);
      }
    };
    exports.LinkFlow = LinkFlow;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Snackbar-css.js
var require_Snackbar_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Snackbar-css.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Snackbar.js
var require_Snackbar = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Snackbar.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SnackbarInstance = exports.SnackbarContainer = exports.Snackbar = void 0;
    var clsx_1 = __importDefault2((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var Snackbar_css_1 = __importDefault2(require_Snackbar_css());
    var cblogo = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
    var gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
    var Snackbar = class {
      constructor(options) {
        this.items = /* @__PURE__ */ new Map();
        this.nextItemKey = 0;
        this.root = null;
        this.darkMode = options.darkMode;
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-cbwsdk-snackbar-root";
        el.appendChild(this.root);
        this.render();
      }
      presentItem(itemProps) {
        const key = this.nextItemKey++;
        this.items.set(key, itemProps);
        this.render();
        return () => {
          this.items.delete(key);
          this.render();
        };
      }
      clear() {
        this.items.clear();
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        (0, preact_1.render)((0, preact_1.h)(
          "div",
          null,
          (0, preact_1.h)(exports.SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key, itemProps]) => (0, preact_1.h)(exports.SnackbarInstance, Object.assign({}, itemProps, { key }))))
        ), this.root);
      }
    };
    exports.Snackbar = Snackbar;
    var SnackbarContainer = (props) => (0, preact_1.h)(
      "div",
      { class: (0, clsx_1.default)("-cbwsdk-snackbar-container") },
      (0, preact_1.h)("style", null, Snackbar_css_1.default),
      (0, preact_1.h)("div", { class: "-cbwsdk-snackbar" }, props.children)
    );
    exports.SnackbarContainer = SnackbarContainer;
    var SnackbarInstance = ({ autoExpand, message, menuItems }) => {
      const [hidden, setHidden] = (0, hooks_1.useState)(true);
      const [expanded, setExpanded] = (0, hooks_1.useState)(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
      (0, hooks_1.useEffect)(() => {
        const timers = [
          window.setTimeout(() => {
            setHidden(false);
          }, 1),
          window.setTimeout(() => {
            setExpanded(true);
          }, 1e4)
        ];
        return () => {
          timers.forEach(window.clearTimeout);
        };
      });
      const toggleExpanded = () => {
        setExpanded(!expanded);
      };
      return (0, preact_1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance", hidden && "-cbwsdk-snackbar-instance-hidden", expanded && "-cbwsdk-snackbar-instance-expanded") },
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-snackbar-instance-header", onClick: toggleExpanded },
          (0, preact_1.h)("img", { src: cblogo, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
          (0, preact_1.h)("div", { class: "-cbwsdk-snackbar-instance-header-message" }, message),
          (0, preact_1.h)(
            "div",
            { class: "-gear-container" },
            !expanded && (0, preact_1.h)(
              "svg",
              { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              (0, preact_1.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
            ),
            (0, preact_1.h)("img", { src: gearIcon, class: "-gear-icon", title: "Expand" })
          )
        ),
        menuItems && menuItems.length > 0 && (0, preact_1.h)("div", { class: "-cbwsdk-snackbar-instance-menu" }, menuItems.map((action, i5) => (0, preact_1.h)(
          "div",
          { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance-menu-item", action.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: action.onClick, key: i5 },
          (0, preact_1.h)(
            "svg",
            { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            (0, preact_1.h)("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })
          ),
          (0, preact_1.h)("span", { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance-menu-item-info", action.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, action.info)
        )))
      );
    };
    exports.SnackbarInstance = SnackbarInstance;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/cssReset-css.js
var require_cssReset_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/cssReset-css.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;bottom:auto;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;content:normal;counter-increment:none;counter-reset:none;cursor:auto;direction:ltr;display:block;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;left:auto;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;max-height:none;max-width:none;min-height:0;min-width:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";right:auto;tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;top:auto;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;width:auto;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset *{box-sizing:border-box;display:initial;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/cssReset.js
var require_cssReset = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/cssReset.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.injectCssReset = void 0;
    var cssReset_css_1 = __importDefault2(require_cssReset_css());
    function injectCssReset() {
      const styleEl = document.createElement("style");
      styleEl.type = "text/css";
      styleEl.appendChild(document.createTextNode(cssReset_css_1.default));
      document.documentElement.appendChild(styleEl);
    }
    exports.injectCssReset = injectCssReset;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/WalletSDKUI.js
var require_WalletSDKUI = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/WalletSDKUI.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKUI = void 0;
    var LinkFlow_1 = require_LinkFlow();
    var Snackbar_1 = require_Snackbar();
    var cssReset_1 = require_cssReset();
    var WalletSDKUI = class {
      constructor(options) {
        this.standalone = null;
        this.attached = false;
        this.snackbar = new Snackbar_1.Snackbar({
          darkMode: options.darkMode
        });
        this.linkFlow = new LinkFlow_1.LinkFlow({
          darkMode: options.darkMode,
          version: options.version,
          sessionId: options.session.id,
          sessionSecret: options.session.secret,
          linkAPIUrl: options.linkAPIUrl,
          connected$: options.connected$,
          chainId$: options.chainId$,
          isParentConnection: false
        });
      }
      attach() {
        if (this.attached) {
          throw new Error("Coinbase Wallet SDK UI is already attached");
        }
        const el = document.documentElement;
        const container = document.createElement("div");
        container.className = "-cbwsdk-css-reset";
        el.appendChild(container);
        this.linkFlow.attach(container);
        this.snackbar.attach(container);
        this.attached = true;
        (0, cssReset_1.injectCssReset)();
      }
      setConnectDisabled(connectDisabled) {
        this.linkFlow.setConnectDisabled(connectDisabled);
      }
      addEthereumChain(_options) {
      }
      watchAsset(_options) {
      }
      switchEthereumChain(_options) {
      }
      requestEthereumAccounts(options) {
        this.linkFlow.open({ onCancel: options.onCancel });
      }
      hideRequestEthereumAccounts() {
        this.linkFlow.close();
      }
      signEthereumMessage(_6) {
      }
      signEthereumTransaction(_6) {
      }
      submitEthereumTransaction(_6) {
      }
      ethereumAddressFromSignedMessage(_6) {
      }
      showConnecting(options) {
        let snackbarProps;
        if (options.isUnlinkedErrorState) {
          snackbarProps = {
            autoExpand: true,
            message: "Connection lost",
            menuItems: [
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        } else {
          snackbarProps = {
            message: "Confirm on phone",
            menuItems: [
              {
                isRed: true,
                info: "Cancel transaction",
                svgWidth: "11",
                svgHeight: "11",
                path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
                defaultFillRule: "inherit",
                defaultClipRule: "inherit",
                onClick: options.onCancel
              },
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        }
        return this.snackbar.presentItem(snackbarProps);
      }
      reloadUI() {
        document.location.reload();
      }
      inlineAccountsResponse() {
        return false;
      }
      inlineAddEthereumChain(_chainId) {
        return false;
      }
      inlineWatchAsset() {
        return false;
      }
      inlineSwitchEthereumChain() {
        return false;
      }
      setStandalone(status) {
        this.standalone = status;
      }
      isStandalone() {
        var _a;
        return (_a = this.standalone) !== null && _a !== void 0 ? _a : false;
      }
    };
    exports.WalletSDKUI = WalletSDKUI;
  }
});

// node_modules/bind-decorator/index.js
var require_bind_decorator = __commonJS({
  "node_modules/bind-decorator/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants;
    (function(constants2) {
      constants2.typeOfFunction = "function";
      constants2.boolTrue = true;
    })(constants || (constants = {}));
    function bind(target, propertyKey, descriptor) {
      if (!descriptor || typeof descriptor.value !== constants.typeOfFunction) {
        throw new TypeError("Only methods can be decorated with @bind. <" + propertyKey + "> is not a method!");
      }
      return {
        configurable: constants.boolTrue,
        get: function() {
          var bound = descriptor.value.bind(this);
          Object.defineProperty(this, propertyKey, {
            value: bound,
            configurable: constants.boolTrue,
            writable: constants.boolTrue
          });
          return bound;
        }
      };
    }
    exports.bind = bind;
    exports.default = bind;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/ClientMessage.js
var require_ClientMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/ClientMessage.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientMessagePublishEvent = exports.ClientMessageSetSessionConfig = exports.ClientMessageGetSessionConfig = exports.ClientMessageIsLinked = exports.ClientMessageHostSession = void 0;
    function ClientMessageHostSession(params) {
      return Object.assign({ type: "HostSession" }, params);
    }
    exports.ClientMessageHostSession = ClientMessageHostSession;
    function ClientMessageIsLinked(params) {
      return Object.assign({ type: "IsLinked" }, params);
    }
    exports.ClientMessageIsLinked = ClientMessageIsLinked;
    function ClientMessageGetSessionConfig(params) {
      return Object.assign({ type: "GetSessionConfig" }, params);
    }
    exports.ClientMessageGetSessionConfig = ClientMessageGetSessionConfig;
    function ClientMessageSetSessionConfig(params) {
      return Object.assign({ type: "SetSessionConfig" }, params);
    }
    exports.ClientMessageSetSessionConfig = ClientMessageSetSessionConfig;
    function ClientMessagePublishEvent(params) {
      return Object.assign({ type: "PublishEvent" }, params);
    }
    exports.ClientMessagePublishEvent = ClientMessagePublishEvent;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/RxWebSocket.js
var require_RxWebSocket = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/RxWebSocket.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RxWebSocket = exports.ConnectionState = void 0;
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
      ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
    })(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
    var RxWebSocket = class {
      constructor(url, WebSocketClass = WebSocket) {
        this.WebSocketClass = WebSocketClass;
        this.webSocket = null;
        this.connectionStateSubject = new rxjs_1.BehaviorSubject(ConnectionState.DISCONNECTED);
        this.incomingDataSubject = new rxjs_1.Subject();
        this.url = url.replace(/^http/, "ws");
      }
      connect() {
        if (this.webSocket) {
          return (0, rxjs_1.throwError)(new Error("webSocket object is not null"));
        }
        return new rxjs_1.Observable((obs) => {
          let webSocket;
          try {
            this.webSocket = webSocket = new this.WebSocketClass(this.url);
          } catch (err) {
            obs.error(err);
            return;
          }
          this.connectionStateSubject.next(ConnectionState.CONNECTING);
          webSocket.onclose = (evt) => {
            this.clearWebSocket();
            obs.error(new Error(`websocket error ${evt.code}: ${evt.reason}`));
            this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
          };
          webSocket.onopen = (_6) => {
            obs.next();
            obs.complete();
            this.connectionStateSubject.next(ConnectionState.CONNECTED);
          };
          webSocket.onmessage = (evt) => {
            this.incomingDataSubject.next(evt.data);
          };
        }).pipe((0, operators_1.take)(1));
      }
      disconnect() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.clearWebSocket();
        this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
        try {
          webSocket.close();
        } catch (_a) {
        }
      }
      get connectionState$() {
        return this.connectionStateSubject.asObservable();
      }
      get incomingData$() {
        return this.incomingDataSubject.asObservable();
      }
      get incomingJSONData$() {
        return this.incomingData$.pipe((0, operators_1.flatMap)((m5) => {
          let j5;
          try {
            j5 = JSON.parse(m5);
          } catch (err) {
            return (0, rxjs_1.empty)();
          }
          return (0, rxjs_1.of)(j5);
        }));
      }
      sendData(data) {
        const { webSocket } = this;
        if (!webSocket) {
          throw new Error("websocket is not connected");
        }
        webSocket.send(data);
      }
      clearWebSocket() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.webSocket = null;
        webSocket.onclose = null;
        webSocket.onerror = null;
        webSocket.onmessage = null;
        webSocket.onopen = null;
      }
    };
    exports.RxWebSocket = RxWebSocket;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/ServerMessage.js
var require_ServerMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/ServerMessage.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isServerMessageFail = void 0;
    function isServerMessageFail(msg) {
      return msg && msg.type === "Fail" && typeof msg.id === "number" && typeof msg.sessionId === "string" && typeof msg.error === "string";
    }
    exports.isServerMessageFail = isServerMessageFail;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js
var require_WalletSDKConnection = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKConnection = void 0;
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var Session_1 = require_Session();
    var types_1 = require_types();
    var ClientMessage_1 = require_ClientMessage();
    var DiagnosticLogger_1 = require_DiagnosticLogger();
    var RxWebSocket_1 = require_RxWebSocket();
    var ServerMessage_1 = require_ServerMessage();
    var HEARTBEAT_INTERVAL = 1e4;
    var REQUEST_TIMEOUT = 6e4;
    var WalletSDKConnection = class {
      constructor(sessionId, sessionKey, linkAPIUrl, diagnostic, WebSocketClass = WebSocket) {
        this.sessionId = sessionId;
        this.sessionKey = sessionKey;
        this.diagnostic = diagnostic;
        this.subscriptions = new rxjs_1.Subscription();
        this.destroyed = false;
        this.lastHeartbeatResponse = 0;
        this.nextReqId = (0, types_1.IntNumber)(1);
        this.connectedSubject = new rxjs_1.BehaviorSubject(false);
        this.linkedSubject = new rxjs_1.BehaviorSubject(false);
        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);
        const ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + "/rpc", WebSocketClass);
        this.ws = ws;
        this.subscriptions.add(ws.connectionState$.pipe(
          (0, operators_1.tap)((state) => {
            var _a;
            return (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {
              state,
              sessionIdHash: Session_1.Session.hash(sessionId)
            });
          }),
          (0, operators_1.skip)(1),
          (0, operators_1.filter)((cs) => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed),
          (0, operators_1.delay)(5e3),
          (0, operators_1.filter)((_6) => !this.destroyed),
          (0, operators_1.flatMap)((_6) => ws.connect()),
          (0, operators_1.retry)()
        ).subscribe());
        this.subscriptions.add(ws.connectionState$.pipe(
          (0, operators_1.skip)(2),
          (0, operators_1.switchMap)((cs) => (0, rxjs_1.iif)(
            () => cs === RxWebSocket_1.ConnectionState.CONNECTED,
            this.authenticate().pipe((0, operators_1.tap)((_6) => this.sendIsLinked()), (0, operators_1.tap)((_6) => this.sendGetSessionConfig()), (0, operators_1.map)((_6) => true)),
            (0, rxjs_1.of)(false)
          )),
          (0, operators_1.distinctUntilChanged)(),
          (0, operators_1.catchError)((_6) => (0, rxjs_1.of)(false))
        ).subscribe((connected) => this.connectedSubject.next(connected)));
        this.subscriptions.add(ws.connectionState$.pipe(
          (0, operators_1.skip)(1),
          (0, operators_1.switchMap)((cs) => (0, rxjs_1.iif)(
            () => cs === RxWebSocket_1.ConnectionState.CONNECTED,
            (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL)
          ))
        ).subscribe((i5) => i5 === 0 ? this.updateLastHeartbeat() : this.heartbeat()));
        this.subscriptions.add(ws.incomingData$.pipe((0, operators_1.filter)((m5) => m5 === "h")).subscribe((_6) => this.updateLastHeartbeat()));
        this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)((m5) => ["IsLinkedOK", "Linked"].includes(m5.type))).subscribe((m5) => {
          var _a;
          const msg = m5;
          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            linked: msg.linked,
            type: m5.type,
            onlineGuests: msg.onlineGuests
          });
          this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);
        }));
        this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)((m5) => ["GetSessionConfigOK", "SessionConfigUpdated"].includes(m5.type))).subscribe((m5) => {
          var _a;
          const msg = m5;
          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : void 0
          });
          this.sessionConfigSubject.next({
            webhookId: msg.webhookId,
            webhookUrl: msg.webhookUrl,
            metadata: msg.metadata
          });
        }));
      }
      connect() {
        var _a;
        if (this.destroyed) {
          throw new Error("instance is destroyed");
        }
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.ws.connect().subscribe();
      }
      destroy() {
        var _a;
        this.subscriptions.unsubscribe();
        this.ws.disconnect();
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.destroyed = true;
      }
      get isDestroyed() {
        return this.destroyed;
      }
      get connected$() {
        return this.connectedSubject.asObservable();
      }
      get onceConnected$() {
        return this.connected$.pipe((0, operators_1.filter)((v5) => v5), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      get linked$() {
        return this.linkedSubject.asObservable();
      }
      get onceLinked$() {
        return this.linked$.pipe((0, operators_1.filter)((v5) => v5), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      get sessionConfig$() {
        return this.sessionConfigSubject.asObservable();
      }
      get incomingEvent$() {
        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)((m5) => {
          if (m5.type !== "Event") {
            return false;
          }
          const sme = m5;
          return typeof sme.sessionId === "string" && typeof sme.eventId === "string" && typeof sme.event === "string" && typeof sme.data === "string";
        }), (0, operators_1.map)((m5) => m5));
      }
      setSessionMetadata(key, value) {
        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          metadata: { [key]: value }
        });
        return this.onceConnected$.pipe((0, operators_1.flatMap)((_6) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to set session metadata");
          }
        }));
      }
      publishEvent(event, data, callWebhook = false) {
        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          event,
          data,
          callWebhook
        });
        return this.onceLinked$.pipe((0, operators_1.flatMap)((_6) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to publish event");
          }
          return res.eventId;
        }));
      }
      sendData(message) {
        this.ws.sendData(JSON.stringify(message));
      }
      updateLastHeartbeat() {
        this.lastHeartbeatResponse = Date.now();
      }
      heartbeat() {
        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
          this.ws.disconnect();
          return;
        }
        try {
          this.ws.sendData("h");
        } catch (_a) {
        }
      }
      makeRequest(message, timeout2 = REQUEST_TIMEOUT) {
        const reqId = message.id;
        try {
          this.sendData(message);
        } catch (err) {
          return (0, rxjs_1.throwError)(err);
        }
        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout2, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)((m5) => m5.id === reqId), (0, operators_1.take)(1));
      }
      authenticate() {
        const msg = (0, ClientMessage_1.ClientMessageHostSession)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          sessionKey: this.sessionKey
        });
        return this.makeRequest(msg).pipe((0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to authentcate");
          }
        }));
      }
      sendIsLinked() {
        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
      sendGetSessionConfig() {
        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
    };
    exports.WalletSDKConnection = WalletSDKConnection;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/WalletUIError.js
var require_WalletUIError = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/WalletUIError.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletUIError = void 0;
    var WalletUIError = class extends Error {
      constructor(message, errorCode) {
        super(message);
        this.message = message;
        this.errorCode = errorCode;
      }
    };
    exports.WalletUIError = WalletUIError;
    WalletUIError.UserRejectedRequest = new WalletUIError("User rejected request");
    WalletUIError.SwitchEthereumChainUnsupportedChainId = new WalletUIError("Unsupported chainId", 4902);
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/aes256gcm.js
var require_aes256gcm = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/aes256gcm.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = void 0;
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var util_1 = require_util3();
    async function encrypt2(plainText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      const ivBytes = crypto.getRandomValues(new Uint8Array(12));
      const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
      const enc = new TextEncoder();
      const encryptedResult = await window.crypto.subtle.encrypt({
        name: "AES-GCM",
        iv: ivBytes
      }, secretKey, enc.encode(plainText));
      const tagLength = 16;
      const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
      const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
      const authTagBytes = new Uint8Array(authTag);
      const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
      const concatted = new Uint8Array([
        ...ivBytes,
        ...authTagBytes,
        ...encryptedPlaintextBytes
      ]);
      return (0, util_1.uint8ArrayToHex)(concatted);
    }
    exports.encrypt = encrypt2;
    function decrypt2(cipherText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      return new rxjs_1.Observable((subscriber) => {
        void async function() {
          const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
          const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);
          const ivBytes = encrypted.slice(0, 12);
          const authTagBytes = encrypted.slice(12, 28);
          const encryptedPlaintextBytes = encrypted.slice(28);
          const concattedBytes = new Uint8Array([
            ...encryptedPlaintextBytes,
            ...authTagBytes
          ]);
          const algo = {
            name: "AES-GCM",
            iv: new Uint8Array(ivBytes)
          };
          try {
            const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
            const decoder = new TextDecoder();
            subscriber.next(decoder.decode(decrypted));
            subscriber.complete();
          } catch (err) {
            subscriber.error(err);
          }
        }();
      });
    }
    exports.decrypt = decrypt2;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3Method.js
var require_Web3Method = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3Method.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3Method = void 0;
    var Web3Method;
    (function(Web3Method2) {
      Web3Method2["requestEthereumAccounts"] = "requestEthereumAccounts";
      Web3Method2["signEthereumMessage"] = "signEthereumMessage";
      Web3Method2["signEthereumTransaction"] = "signEthereumTransaction";
      Web3Method2["submitEthereumTransaction"] = "submitEthereumTransaction";
      Web3Method2["ethereumAddressFromSignedMessage"] = "ethereumAddressFromSignedMessage";
      Web3Method2["scanQRCode"] = "scanQRCode";
      Web3Method2["generic"] = "generic";
      Web3Method2["childRequestEthereumAccounts"] = "childRequestEthereumAccounts";
      Web3Method2["addEthereumChain"] = "addEthereumChain";
      Web3Method2["switchEthereumChain"] = "switchEthereumChain";
      Web3Method2["makeEthereumJSONRPCRequest"] = "makeEthereumJSONRPCRequest";
      Web3Method2["watchAsset"] = "watchAsset";
      Web3Method2["selectProvider"] = "selectProvider";
    })(Web3Method = exports.Web3Method || (exports.Web3Method = {}));
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/RelayMessage.js
var require_RelayMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/RelayMessage.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelayMessageType = void 0;
    var RelayMessageType;
    (function(RelayMessageType2) {
      RelayMessageType2["SESSION_ID_REQUEST"] = "SESSION_ID_REQUEST";
      RelayMessageType2["SESSION_ID_RESPONSE"] = "SESSION_ID_RESPONSE";
      RelayMessageType2["LINKED"] = "LINKED";
      RelayMessageType2["UNLINKED"] = "UNLINKED";
      RelayMessageType2["WEB3_REQUEST"] = "WEB3_REQUEST";
      RelayMessageType2["WEB3_REQUEST_CANCELED"] = "WEB3_REQUEST_CANCELED";
      RelayMessageType2["WEB3_RESPONSE"] = "WEB3_RESPONSE";
    })(RelayMessageType = exports.RelayMessageType || (exports.RelayMessageType = {}));
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestCanceledMessage.js
var require_Web3RequestCanceledMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestCanceledMessage.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3RequestCanceledMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestCanceledMessage(id) {
      return { type: RelayMessage_1.RelayMessageType.WEB3_REQUEST_CANCELED, id };
    }
    exports.Web3RequestCanceledMessage = Web3RequestCanceledMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestMessage.js
var require_Web3RequestMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestMessage.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3RequestMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_REQUEST }, params);
    }
    exports.Web3RequestMessage = Web3RequestMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3Response.js
var require_Web3Response = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3Response.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumAddressFromSignedMessageResponse = exports.SubmitEthereumTransactionResponse = exports.SignEthereumTransactionResponse = exports.SignEthereumMessageResponse = exports.isRequestEthereumAccountsResponse = exports.SelectProviderResponse = exports.WatchAssetReponse = exports.RequestEthereumAccountsResponse = exports.SwitchEthereumChainResponse = exports.AddEthereumChainResponse = exports.ErrorResponse = void 0;
    var Web3Method_1 = require_Web3Method();
    function ErrorResponse(method, errorMessage, errorCode) {
      return { method, errorMessage, errorCode };
    }
    exports.ErrorResponse = ErrorResponse;
    function AddEthereumChainResponse(addResponse) {
      return {
        method: Web3Method_1.Web3Method.addEthereumChain,
        result: addResponse
      };
    }
    exports.AddEthereumChainResponse = AddEthereumChainResponse;
    function SwitchEthereumChainResponse(switchResponse) {
      return {
        method: Web3Method_1.Web3Method.switchEthereumChain,
        result: switchResponse
      };
    }
    exports.SwitchEthereumChainResponse = SwitchEthereumChainResponse;
    function RequestEthereumAccountsResponse(addresses) {
      return { method: Web3Method_1.Web3Method.requestEthereumAccounts, result: addresses };
    }
    exports.RequestEthereumAccountsResponse = RequestEthereumAccountsResponse;
    function WatchAssetReponse(success) {
      return { method: Web3Method_1.Web3Method.watchAsset, result: success };
    }
    exports.WatchAssetReponse = WatchAssetReponse;
    function SelectProviderResponse(selectedProviderKey) {
      return { method: Web3Method_1.Web3Method.selectProvider, result: selectedProviderKey };
    }
    exports.SelectProviderResponse = SelectProviderResponse;
    function isRequestEthereumAccountsResponse(res) {
      return res && res.method === Web3Method_1.Web3Method.requestEthereumAccounts;
    }
    exports.isRequestEthereumAccountsResponse = isRequestEthereumAccountsResponse;
    function SignEthereumMessageResponse(signature) {
      return { method: Web3Method_1.Web3Method.signEthereumMessage, result: signature };
    }
    exports.SignEthereumMessageResponse = SignEthereumMessageResponse;
    function SignEthereumTransactionResponse(signedData) {
      return { method: Web3Method_1.Web3Method.signEthereumTransaction, result: signedData };
    }
    exports.SignEthereumTransactionResponse = SignEthereumTransactionResponse;
    function SubmitEthereumTransactionResponse(txHash) {
      return { method: Web3Method_1.Web3Method.submitEthereumTransaction, result: txHash };
    }
    exports.SubmitEthereumTransactionResponse = SubmitEthereumTransactionResponse;
    function EthereumAddressFromSignedMessageResponse(address) {
      return {
        method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
        result: address
      };
    }
    exports.EthereumAddressFromSignedMessageResponse = EthereumAddressFromSignedMessageResponse;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3ResponseMessage.js
var require_Web3ResponseMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3ResponseMessage.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWeb3ResponseMessage = exports.Web3ResponseMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3ResponseMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_RESPONSE }, params);
    }
    exports.Web3ResponseMessage = Web3ResponseMessage;
    function isWeb3ResponseMessage(msg) {
      return msg && msg.type === RelayMessage_1.RelayMessageType.WEB3_RESPONSE;
    }
    exports.isWeb3ResponseMessage = isWeb3ResponseMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelay.js
var require_WalletSDKRelay = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelay.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o5, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o5[k22] = m5[k5];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o5, v5) {
      Object.defineProperty(o5, "default", { enumerable: true, value: v5 });
    } : function(o5, v5) {
      o5["default"] = v5;
    });
    var __decorate2 = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d5;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r6 = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i5 = decorators.length - 1; i5 >= 0; i5--)
          if (d5 = decorators[i5])
            r6 = (c5 < 3 ? d5(r6) : c5 > 3 ? d5(target, key, r6) : d5(target, key)) || r6;
      return c5 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
    };
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k5 in mod)
          if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k5))
            __createBinding2(result, mod, k5);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKRelay = void 0;
    var bind_decorator_1 = __importDefault2(require_bind_decorator());
    var eth_rpc_errors_1 = require_dist();
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var DiagnosticLogger_1 = require_DiagnosticLogger();
    var WalletSDKConnection_1 = require_WalletSDKConnection();
    var WalletUIError_1 = require_WalletUIError();
    var types_1 = require_types();
    var util_1 = require_util3();
    var aes256gcm = __importStar2(require_aes256gcm());
    var Session_1 = require_Session();
    var WalletSDKRelayAbstract_1 = require_WalletSDKRelayAbstract();
    var Web3Method_1 = require_Web3Method();
    var Web3RequestCanceledMessage_1 = require_Web3RequestCanceledMessage();
    var Web3RequestMessage_1 = require_Web3RequestMessage();
    var Web3Response_1 = require_Web3Response();
    var Web3ResponseMessage_1 = require_Web3ResponseMessage();
    var WalletSDKRelay = class extends WalletSDKRelayAbstract_1.WalletSDKRelayAbstract {
      constructor(options) {
        var _a;
        super();
        this.accountsCallback = null;
        this.chainCallback = null;
        this.dappDefaultChainSubject = new rxjs_1.BehaviorSubject(1);
        this.dappDefaultChain = 1;
        this.appName = "";
        this.appLogoUrl = null;
        this.subscriptions = new rxjs_1.Subscription();
        this.linkAPIUrl = options.linkAPIUrl;
        this.storage = options.storage;
        this.options = options;
        const { session, ui, connection } = this.subscribe();
        this._session = session;
        this.connection = connection;
        this.relayEventManager = options.relayEventManager;
        if (options.diagnosticLogger && options.eventListener) {
          throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
        }
        if (options.eventListener) {
          this.diagnostic = {
            log: options.eventListener.onEvent
          };
        } else {
          this.diagnostic = options.diagnosticLogger;
        }
        this._reloadOnDisconnect = (_a = options.reloadOnDisconnect) !== null && _a !== void 0 ? _a : true;
        this.ui = ui;
      }
      subscribe() {
        this.subscriptions.add(this.dappDefaultChainSubject.subscribe((chainId) => {
          if (this.dappDefaultChain !== chainId) {
            this.dappDefaultChain = chainId;
          }
        }));
        const session = Session_1.Session.load(this.storage) || new Session_1.Session(this.storage).save();
        const connection = new WalletSDKConnection_1.WalletSDKConnection(session.id, session.key, this.linkAPIUrl, this.diagnostic);
        this.subscriptions.add(connection.sessionConfig$.subscribe({
          next: (sessionConfig) => {
            this.onSessionConfigChanged(sessionConfig);
          },
          error: () => {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "error while invoking session config callback"
            });
          }
        }));
        this.subscriptions.add(connection.incomingEvent$.pipe((0, operators_1.filter)((m5) => m5.event === "Web3Response")).subscribe({ next: this.handleIncomingEvent }));
        this.subscriptions.add(connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)((linked) => {
          var _a;
          this.isLinked = linked;
          const cachedAddresses = this.storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
          if (linked) {
            this.session.linked = linked;
          }
          this.isUnlinkedErrorState = false;
          if (cachedAddresses) {
            const addresses = cachedAddresses.split(" ");
            const wasConnectedViaStandalone = this.storage.getItem("IsStandaloneSigning") === "true";
            if (addresses[0] !== "" && !linked && this.session.linked && !wasConnectedViaStandalone) {
              this.isUnlinkedErrorState = true;
              const sessionIdHash = this.getSessionIdHash();
              (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.UNLINKED_ERROR_STATE, {
                sessionIdHash
              });
            }
          }
        })).subscribe());
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => !!c5.metadata && c5.metadata.__destroyed === "1")).subscribe(() => {
          var _a;
          const alreadyDestroyed = connection.isDestroyed;
          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.METADATA_DESTROYED, {
            alreadyDestroyed,
            sessionIdHash: this.getSessionIdHash()
          });
          return this.resetAndReload();
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.WalletUsername !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.WalletUsername, session.secret))).subscribe({
          next: (walletUsername) => {
            this.storage.setItem(WalletSDKRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);
          },
          error: () => {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "username"
            });
          }
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.AppVersion !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.AppVersion, session.secret))).subscribe({
          next: (appVersion) => {
            this.storage.setItem(WalletSDKRelayAbstract_1.APP_VERSION_KEY, appVersion);
          },
          error: () => {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "appversion"
            });
          }
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.ChainId !== void 0 && c5.metadata.JsonRpcUrl !== void 0)).pipe((0, operators_1.mergeMap)((c5) => (0, rxjs_1.zip)(aes256gcm.decrypt(c5.metadata.ChainId, session.secret), aes256gcm.decrypt(c5.metadata.JsonRpcUrl, session.secret)))).pipe((0, operators_1.distinctUntilChanged)()).subscribe({
          next: ([chainId, jsonRpcUrl]) => {
            if (this.chainCallback) {
              this.chainCallback(chainId, jsonRpcUrl);
            }
          },
          error: () => {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "chainId|jsonRpcUrl"
            });
          }
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.EthereumAddress !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.EthereumAddress, session.secret))).subscribe({
          next: (selectedAddress) => {
            if (this.accountsCallback) {
              this.accountsCallback([selectedAddress]);
            }
            if (WalletSDKRelay.accountRequestCallbackIds.size > 0) {
              Array.from(WalletSDKRelay.accountRequestCallbackIds.values()).forEach((id) => {
                const message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({
                  id,
                  response: (0, Web3Response_1.RequestEthereumAccountsResponse)([
                    selectedAddress
                  ])
                });
                this.invokeCallback(Object.assign(Object.assign({}, message), { id }));
              });
              WalletSDKRelay.accountRequestCallbackIds.clear();
            }
          },
          error: () => {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "selectedAddress"
            });
          }
        }));
        const ui = this.options.uiConstructor({
          linkAPIUrl: this.options.linkAPIUrl,
          version: this.options.version,
          darkMode: this.options.darkMode,
          session,
          connected$: connection.connected$,
          chainId$: this.dappDefaultChainSubject
        });
        connection.connect();
        return { session, ui, connection };
      }
      attachUI() {
        this.ui.attach();
      }
      resetAndReload() {
        this.connection.setSessionMetadata("__destroyed", "1").pipe((0, operators_1.timeout)(1e3), (0, operators_1.catchError)((_6) => (0, rxjs_1.of)(null))).subscribe((_6) => {
          var _a, _b, _c;
          const isStandalone = this.ui.isStandalone();
          try {
            this.subscriptions.unsubscribe();
          } catch (err) {
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error unsubscribing"
            });
          }
          (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.SESSION_STATE_CHANGE, {
            method: "relay::resetAndReload",
            sessionMetadataChange: "__destroyed, 1",
            sessionIdHash: this.getSessionIdHash()
          });
          this.connection.destroy();
          const storedSession = Session_1.Session.load(this.storage);
          if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
            this.storage.clear();
          } else if (storedSession) {
            (_c = this.diagnostic) === null || _c === void 0 ? void 0 : _c.log(DiagnosticLogger_1.EVENTS.SKIPPED_CLEARING_SESSION, {
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: Session_1.Session.hash(storedSession.id)
            });
          }
          if (this._reloadOnDisconnect) {
            this.ui.reloadUI();
            return;
          }
          if (this.accountsCallback) {
            this.accountsCallback([], true);
          }
          const { session, ui, connection } = this.subscribe();
          this._session = session;
          this.connection = connection;
          this.ui = ui;
          if (isStandalone && this.ui.setStandalone)
            this.ui.setStandalone(true);
          this.attachUI();
        }, (err) => {
          var _a;
          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.FAILURE, {
            method: "relay::resetAndReload",
            message: `failed to reset and reload with ${err}`,
            sessionIdHash: this.getSessionIdHash()
          });
        });
      }
      setAppInfo(appName, appLogoUrl) {
        this.appName = appName;
        this.appLogoUrl = appLogoUrl;
      }
      getStorageItem(key) {
        return this.storage.getItem(key);
      }
      get session() {
        return this._session;
      }
      setStorageItem(key, value) {
        this.storage.setItem(key, value);
      }
      signEthereumMessage(message, address, addPrefix, typedDataJson) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            address,
            addPrefix,
            typedDataJson: typedDataJson || null
          }
        });
      }
      ethereumAddressFromSignedMessage(message, signature, addPrefix) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            signature: (0, util_1.hexStringFromBuffer)(signature, true),
            addPrefix
          }
        });
      }
      signEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: false
          }
        });
      }
      signAndSubmitEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.maxFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxFeePerGas) : null,
            maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: true
          }
        });
      }
      submitEthereumTransaction(signedTransaction, chainId) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.submitEthereumTransaction,
          params: {
            signedTransaction: (0, util_1.hexStringFromBuffer)(signedTransaction, true),
            chainId
          }
        });
      }
      scanQRCode(regExp) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.scanQRCode,
          params: { regExp }
        });
      }
      getQRCodeUrl() {
        return (0, util_1.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, false, this.options.version, this.dappDefaultChain);
      }
      genericRequest(data, action) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.generic,
          params: {
            action,
            data
          }
        });
      }
      sendGenericMessage(request3) {
        return this.sendRequest(request3);
      }
      sendRequest(request3) {
        let hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error2) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request3.method, error2);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          if (!this.ui.isStandalone()) {
            hideSnackbarItem = this.ui.showConnecting({
              isUnlinkedErrorState: this.isUnlinkedErrorState,
              onCancel: cancel,
              onResetConnection: this.resetAndReload
            });
          }
          this.relayEventManager.callbacks.set(id, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          if (this.ui.isStandalone()) {
            this.sendRequestStandalone(id, request3);
          } else {
            this.publishWeb3RequestEvent(id, request3);
          }
        });
        return { promise, cancel };
      }
      setConnectDisabled(disabled) {
        this.ui.setConnectDisabled(disabled);
      }
      setAccountsCallback(accountsCallback) {
        this.accountsCallback = accountsCallback;
      }
      setChainCallback(chainCallback) {
        this.chainCallback = chainCallback;
      }
      setDappDefaultChainCallback(chainId) {
        this.dappDefaultChainSubject.next(chainId);
      }
      publishWeb3RequestEvent(id, request3) {
        var _a;
        const message = (0, Web3RequestMessage_1.Web3RequestMessage)({ id, request: request3 });
        const storedSession = Session_1.Session.load(this.storage);
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST, {
          eventId: message.id,
          method: `relay::${message.request.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
          isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
        });
        this.subscriptions.add(this.publishEvent("Web3Request", message, true).subscribe({
          next: (_6) => {
            var _a2;
            (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST_PUBLISHED, {
              eventId: message.id,
              method: `relay::${message.request.method}`,
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
              isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
            });
          },
          error: (err) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: message.id,
              response: {
                method: message.request.method,
                errorMessage: err.message
              }
            }));
          }
        }));
      }
      publishWeb3RequestCanceledEvent(id) {
        const message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id);
        this.subscriptions.add(this.publishEvent("Web3RequestCanceled", message, false).subscribe());
      }
      publishEvent(event, message, callWebhook) {
        const secret = this.session.secret;
        return new rxjs_1.Observable((subscriber) => {
          void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), { origin: location.origin })), secret).then((encrypted) => {
            subscriber.next(encrypted);
            subscriber.complete();
          });
        }).pipe((0, operators_1.mergeMap)((encrypted) => {
          return this.connection.publishEvent(event, encrypted, callWebhook);
        }));
      }
      handleIncomingEvent(event) {
        try {
          this.subscriptions.add(aes256gcm.decrypt(event.data, this.session.secret).pipe((0, operators_1.map)((c5) => JSON.parse(c5))).subscribe({
            next: (json) => {
              const message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json) ? json : null;
              if (!message) {
                return;
              }
              this.handleWeb3ResponseMessage(message);
            },
            error: () => {
              var _a;
              (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
                message: "Had error decrypting",
                value: "incomingEvent"
              });
            }
          }));
        } catch (_a) {
          return;
        }
      }
      handleWeb3ResponseMessage(message) {
        var _a;
        const { response } = message;
        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.WEB3_RESPONSE, {
          eventId: message.id,
          method: `relay::${response.method}`,
          sessionIdHash: this.getSessionIdHash()
        });
        if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {
          WalletSDKRelay.accountRequestCallbackIds.forEach((id) => this.invokeCallback(Object.assign(Object.assign({}, message), { id })));
          WalletSDKRelay.accountRequestCallbackIds.clear();
          return;
        }
        this.invokeCallback(message);
      }
      handleErrorResponse(id, method, error2, errorCode) {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id,
          response: (0, Web3Response_1.ErrorResponse)(method, (error2 !== null && error2 !== void 0 ? error2 : WalletUIError_1.WalletUIError.UserRejectedRequest).message, errorCode)
        }));
      }
      invokeCallback(message) {
        const callback = this.relayEventManager.callbacks.get(message.id);
        if (callback) {
          callback(message.response);
          this.relayEventManager.callbacks.delete(message.id);
        }
      }
      requestEthereumAccounts() {
        const request3 = {
          method: Web3Method_1.Web3Method.requestEthereumAccounts,
          params: {
            appName: this.appName,
            appLogoUrl: this.appLogoUrl || null
          }
        };
        const hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error2) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request3.method, error2);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          var _a;
          this.relayEventManager.callbacks.set(id, (response) => {
            this.ui.hideRequestEthereumAccounts();
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const userAgent = ((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) || null;
          if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
            let location2;
            try {
              if ((0, util_1.isInIFrame)() && window.top) {
                location2 = window.top.location;
              } else {
                location2 = window.location;
              }
            } catch (e5) {
              location2 = window.location;
            }
            location2.href = `https://go.cb-w.com/xoXnYwQimhb?cb_url=${encodeURIComponent(location2.href)}`;
            return;
          }
          if (this.ui.inlineAccountsResponse()) {
            const onAccounts = (accounts) => {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id,
                response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)
              }));
            };
            this.ui.requestEthereumAccounts({
              onCancel: cancel,
              onAccounts
            });
          } else {
            const err = eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied account authorization");
            this.ui.requestEthereumAccounts({
              onCancel: () => cancel(err)
            });
          }
          WalletSDKRelay.accountRequestCallbackIds.add(id);
          if (!this.ui.inlineAccountsResponse() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request3);
          }
        });
        return { promise, cancel };
      }
      selectProvider(providerOptions) {
        const request3 = {
          method: Web3Method_1.Web3Method.selectProvider,
          params: {
            providerOptions
          }
        };
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error2) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request3.method, error2);
        };
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id, (response) => {
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (_error) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.SelectProviderResponse)(types_1.ProviderType.Unselected)
            }));
          };
          const approve = (selectedProviderKey) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.SelectProviderResponse)(selectedProviderKey)
            }));
          };
          if (this.ui.selectProvider)
            this.ui.selectProvider({
              onApprove: approve,
              onCancel: _cancel,
              providerOptions
            });
        });
        return { cancel, promise };
      }
      watchAsset(type2, address, symbol, decimals, image, chainId) {
        const request3 = {
          method: Web3Method_1.Web3Method.watchAsset,
          params: {
            type: type2,
            options: {
              address,
              symbol,
              decimals,
              image
            },
            chainId
          }
        };
        let hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error2) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request3.method, error2);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineWatchAsset()) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (_error) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.WatchAssetReponse)(false)
            }));
          };
          const approve = () => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.WatchAssetReponse)(true)
            }));
          };
          if (this.ui.inlineWatchAsset()) {
            this.ui.watchAsset({
              onApprove: approve,
              onCancel: _cancel,
              type: type2,
              address,
              symbol,
              decimals,
              image,
              chainId
            });
          }
          if (!this.ui.inlineWatchAsset() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request3);
          }
        });
        return { cancel, promise };
      }
      addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
        const request3 = {
          method: Web3Method_1.Web3Method.addEthereumChain,
          params: {
            chainId,
            rpcUrls,
            blockExplorerUrls,
            chainName,
            iconUrls,
            nativeCurrency
          }
        };
        let hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error2) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request3.method, error2);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineAddEthereumChain(chainId)) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (_error) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.AddEthereumChainResponse)({
                isApproved: false,
                rpcUrl: ""
              })
            }));
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.AddEthereumChainResponse)({ isApproved: true, rpcUrl })
            }));
          };
          if (this.ui.inlineAddEthereumChain(chainId)) {
            this.ui.addEthereumChain({
              onCancel: _cancel,
              onApprove: approve,
              chainId: request3.params.chainId,
              rpcUrls: request3.params.rpcUrls,
              blockExplorerUrls: request3.params.blockExplorerUrls,
              chainName: request3.params.chainName,
              iconUrls: request3.params.iconUrls,
              nativeCurrency: request3.params.nativeCurrency
            });
          }
          if (!this.ui.inlineAddEthereumChain(chainId) && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request3);
          }
        });
        return { promise, cancel };
      }
      switchEthereumChain(chainId, address) {
        const request3 = {
          method: Web3Method_1.Web3Method.switchEthereumChain,
          params: Object.assign({ chainId }, { address })
        };
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = (error2) => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleErrorResponse(id, request3.method, error2);
        };
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id, (response) => {
            if (response.errorMessage && response.errorCode) {
              return reject(eth_rpc_errors_1.ethErrors.provider.custom({
                code: response.errorCode,
                message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
              }));
            } else if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (error2) => {
            if (typeof error2 === "number") {
              const errorCode = error2;
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id,
                response: (0, Web3Response_1.ErrorResponse)(Web3Method_1.Web3Method.switchEthereumChain, WalletUIError_1.WalletUIError.SwitchEthereumChainUnsupportedChainId.message, errorCode)
              }));
            } else if (error2 instanceof WalletUIError_1.WalletUIError) {
              this.handleErrorResponse(id, Web3Method_1.Web3Method.switchEthereumChain, error2, error2.errorCode);
            } else {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id,
                response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                  isApproved: false,
                  rpcUrl: ""
                })
              }));
            }
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                isApproved: true,
                rpcUrl
              })
            }));
          };
          this.ui.switchEthereumChain({
            onCancel: _cancel,
            onApprove: approve,
            chainId: request3.params.chainId,
            address: request3.params.address
          });
          if (!this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request3);
          }
        });
        return { promise, cancel };
      }
      inlineAddEthereumChain(chainId) {
        return this.ui.inlineAddEthereumChain(chainId);
      }
      getSessionIdHash() {
        return Session_1.Session.hash(this._session.id);
      }
      sendRequestStandalone(id, request3) {
        const _cancel = (error2) => {
          this.handleErrorResponse(id, request3.method, error2);
        };
        const onSuccess = (response) => {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id,
            response
          }));
        };
        switch (request3.method) {
          case Web3Method_1.Web3Method.signEthereumMessage:
            this.ui.signEthereumMessage({
              request: request3,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.signEthereumTransaction:
            this.ui.signEthereumTransaction({
              request: request3,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.submitEthereumTransaction:
            this.ui.submitEthereumTransaction({
              request: request3,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:
            this.ui.ethereumAddressFromSignedMessage({
              request: request3,
              onSuccess
            });
            break;
          default:
            _cancel();
            break;
        }
      }
      onSessionConfigChanged(_nextSessionConfig) {
      }
    };
    WalletSDKRelay.accountRequestCallbackIds = /* @__PURE__ */ new Set();
    __decorate2([
      bind_decorator_1.default
    ], WalletSDKRelay.prototype, "resetAndReload", null);
    __decorate2([
      bind_decorator_1.default
    ], WalletSDKRelay.prototype, "handleIncomingEvent", null);
    exports.WalletSDKRelay = WalletSDKRelay;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayEventManager.js
var require_WalletSDKRelayEventManager = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayEventManager.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKRelayEventManager = void 0;
    var util_1 = require_util3();
    var WalletSDKRelayEventManager = class {
      constructor() {
        this._nextRequestId = 0;
        this.callbacks = /* @__PURE__ */ new Map();
      }
      makeRequestId() {
        this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
        const id = this._nextRequestId;
        const idStr = (0, util_1.prepend0x)(id.toString(16));
        const callback = this.callbacks.get(idStr);
        if (callback) {
          this.callbacks.delete(idStr);
        }
        return id;
      }
    };
    exports.WalletSDKRelayEventManager = WalletSDKRelayEventManager;
  }
});

// node_modules/@coinbase/wallet-sdk/package.json
var require_package2 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/package.json"(exports, module) {
    module.exports = {
      name: "@coinbase/wallet-sdk",
      version: "3.5.4",
      description: "Coinbase Wallet JavaScript SDK",
      keywords: [
        "cipher",
        "cipherbrowser",
        "coinbase",
        "coinbasewallet",
        "eth",
        "ether",
        "ethereum",
        "etherium",
        "injection",
        "toshi",
        "wallet",
        "walletlink",
        "web3"
      ],
      main: "dist/index.js",
      types: "dist/index.d.ts",
      repository: "https://github.com/coinbase/coinbase-wallet-sdk.git",
      author: "Coinbase, Inc.",
      license: "Apache-2.0",
      scripts: {
        "pretest:unit": "node compile-assets.js",
        "test:unit": "jest",
        "test:unit:coverage": "yarn test:unit && open coverage/lcov-report/index.html",
        "test:karma": "yarn build-npm && karma start",
        prebuild: `node -p "'export const LIB_VERSION = ' + JSON.stringify(require('./package.json').version) + ';'" > src/version.ts`,
        build: "node compile-assets.js && webpack --config webpack.config.js",
        "build-npm": "tsc -p ./tsconfig.build.json",
        "build:dev": "export LINK_API_URL='http://localhost:3000'; yarn build",
        "build:dev:watch": "nodemon -e 'ts,tsx,js,json,css,scss,svg' --ignore 'src/**/*-css.ts' --ignore 'src/**/*-svg.ts' --watch src/ --exec 'yarn build:dev'",
        "build:prod": `yarn prebuild && yarn build && yarn build-npm && cp ./package.json ../../README.md ./LICENSE build/npm && cp -a src/vendor-js build/npm/dist && sed -i.bak 's|  "private": true,||g' build/npm/package.json && rm -f build/npm/package.json.bak`,
        "lint:types": "tsc --noEmit",
        "lint:prettier": 'prettier --check "{src,__tests__}/**/*.(js|ts|tsx)"',
        "lint:eslint": "eslint ./src --ext .ts,.tsx",
        "fix:eslint": "yarn lint:eslint --fix",
        "fix:prettier": "prettier . --write",
        release: "./scripts/release.sh"
      },
      dependencies: {
        "@metamask/safe-event-emitter": "2.0.0",
        "@solana/web3.js": "1.52.0",
        "bind-decorator": "^1.0.11",
        "bn.js": "^5.1.1",
        buffer: "^6.0.3",
        clsx: "^1.1.0",
        "eth-block-tracker": "4.4.3",
        "eth-json-rpc-filters": "4.2.2",
        "eth-rpc-errors": "4.0.2",
        "json-rpc-engine": "6.1.0",
        keccak: "^3.0.1",
        preact: "^10.5.9",
        qs: "^6.10.3",
        rxjs: "^6.6.3",
        "sha.js": "^2.4.11",
        "stream-browserify": "^3.0.0",
        util: "^0.12.4"
      },
      devDependencies: {
        "@babel/core": "^7.17.9",
        "@babel/plugin-proposal-decorators": "^7.17.9",
        "@babel/plugin-transform-react-jsx": "^7.17.3",
        "@babel/preset-env": "^7.16.11",
        "@babel/preset-typescript": "^7.16.7",
        "@peculiar/webcrypto": "^1.3.3",
        "@testing-library/jest-dom": "^5.16.4",
        "@testing-library/preact": "^2.0.1",
        "@types/bn.js": "^4.11.6",
        "@types/jest": "^27.4.1",
        "@types/node": "^14.14.20",
        "@types/qs": "^6.9.7",
        "@types/sha.js": "^2.4.0",
        "@typescript-eslint/eslint-plugin": "^5.7.0",
        "@typescript-eslint/eslint-plugin-tslint": "^5.7.0",
        "@typescript-eslint/parser": "^5.7.0",
        "babel-jest": "^27.5.1",
        browserify: "17.0.0",
        "copy-webpack-plugin": "^6.4.1",
        "core-js": "^3.8.2",
        eslint: "^8.4.1",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-import": "^2.25.3",
        "eslint-plugin-preact": "^0.1.0",
        "eslint-plugin-prettier": "^4.0.0",
        "eslint-plugin-simple-import-sort": "^7.0.0",
        jasmine: "3.8.0",
        jest: "^27.5.1",
        "jest-chrome": "^0.7.2",
        "jest-websocket-mock": "^2.3.0",
        karma: "^6.3.15",
        "karma-browserify": "8.1.0",
        "karma-chrome-launcher": "^3.1.0",
        "karma-jasmine": "^4.0.1",
        nodemon: "^2.0.6",
        prettier: "^2.5.1",
        "raw-loader": "^4.0.2",
        "regenerator-runtime": "^0.13.7",
        sass: "^1.50.0",
        svgo: "^2.8.0",
        "ts-jest": "^27.1.4",
        "ts-loader": "^8.0.13",
        "ts-node": "^10.7.0",
        tslib: "^2.0.3",
        typescript: "^4.1.3",
        watchify: "4.0.0",
        webpack: "^5.72.0",
        "webpack-cli": "^4.9.2",
        "whatwg-fetch": "^3.5.0"
      },
      engines: {
        node: ">= 10.0.0"
      }
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js
var require_CoinbaseWalletSDK = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinbaseWalletSDK = void 0;
    var wallet_logo_1 = require_wallet_logo();
    var ScopedLocalStorage_1 = require_ScopedLocalStorage();
    var CoinbaseWalletProvider_1 = require_CoinbaseWalletProvider();
    var WalletSDKUI_1 = require_WalletSDKUI();
    var WalletSDKRelay_1 = require_WalletSDKRelay();
    var WalletSDKRelayEventManager_1 = require_WalletSDKRelayEventManager();
    var util_1 = require_util3();
    var LINK_API_URL = process.env.LINK_API_URL || "https://www.walletlink.org";
    var SDK_VERSION = process.env.SDK_VERSION || require_package2().version || "unknown";
    var CoinbaseWalletSDK2 = class {
      constructor(options) {
        var _a, _b, _c;
        this._appName = "";
        this._appLogoUrl = null;
        this._relay = null;
        this._relayEventManager = null;
        const linkAPIUrl = options.linkAPIUrl || LINK_API_URL;
        let uiConstructor;
        if (!options.uiConstructor) {
          uiConstructor = (opts) => new WalletSDKUI_1.WalletSDKUI(opts);
        } else {
          uiConstructor = options.uiConstructor;
        }
        if (typeof options.overrideIsMetaMask === "undefined") {
          this._overrideIsMetaMask = false;
        } else {
          this._overrideIsMetaMask = options.overrideIsMetaMask;
        }
        this._overrideIsCoinbaseWallet = (_a = options.overrideIsCoinbaseWallet) !== null && _a !== void 0 ? _a : true;
        this._overrideIsCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
        if (options.diagnosticLogger && options.eventListener) {
          throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
        }
        if (options.eventListener) {
          this._diagnosticLogger = {
            log: options.eventListener.onEvent
          };
        } else {
          this._diagnosticLogger = options.diagnosticLogger;
        }
        this._reloadOnDisconnect = (_c = options.reloadOnDisconnect) !== null && _c !== void 0 ? _c : true;
        const u5 = new URL(linkAPIUrl);
        const origin = `${u5.protocol}//${u5.host}`;
        this._storage = new ScopedLocalStorage_1.ScopedLocalStorage(`-walletlink:${origin}`);
        this._storage.setItem("version", CoinbaseWalletSDK2.VERSION);
        if (this.walletExtension || this.coinbaseBrowser) {
          return;
        }
        this._relayEventManager = new WalletSDKRelayEventManager_1.WalletSDKRelayEventManager();
        this._relay = new WalletSDKRelay_1.WalletSDKRelay({
          linkAPIUrl,
          version: SDK_VERSION,
          darkMode: !!options.darkMode,
          uiConstructor,
          storage: this._storage,
          relayEventManager: this._relayEventManager,
          diagnosticLogger: this._diagnosticLogger
        });
        this.setAppInfo(options.appName, options.appLogoUrl);
        if (!!options.headlessMode)
          return;
        this._relay.attachUI();
      }
      makeWeb3Provider(jsonRpcUrl = "", chainId = 1) {
        const extension = this.walletExtension;
        if (extension) {
          if (!this.isCipherProvider(extension)) {
            extension.setProviderInfo(jsonRpcUrl, chainId);
          }
          if (this._reloadOnDisconnect === false && typeof extension.disableReloadOnDisconnect === "function")
            extension.disableReloadOnDisconnect();
          return extension;
        }
        const dappBrowser = this.coinbaseBrowser;
        if (dappBrowser) {
          return dappBrowser;
        }
        const relay = this._relay;
        if (!relay || !this._relayEventManager || !this._storage) {
          throw new Error("Relay not initialized, should never happen");
        }
        if (!jsonRpcUrl)
          relay.setConnectDisabled(true);
        return new CoinbaseWalletProvider_1.CoinbaseWalletProvider({
          relayProvider: () => Promise.resolve(relay),
          relayEventManager: this._relayEventManager,
          storage: this._storage,
          jsonRpcUrl,
          chainId,
          qrUrl: this.getQrUrl(),
          diagnosticLogger: this._diagnosticLogger,
          overrideIsMetaMask: this._overrideIsMetaMask,
          overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
          overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
        });
      }
      setAppInfo(appName, appLogoUrl) {
        var _a;
        this._appName = appName || "DApp";
        this._appLogoUrl = appLogoUrl || (0, util_1.getFavicon)();
        const extension = this.walletExtension;
        if (extension) {
          if (!this.isCipherProvider(extension)) {
            extension.setAppInfo(this._appName, this._appLogoUrl);
          }
        } else {
          (_a = this._relay) === null || _a === void 0 ? void 0 : _a.setAppInfo(this._appName, this._appLogoUrl);
        }
      }
      disconnect() {
        var _a;
        const extension = this.walletExtension;
        if (extension) {
          void extension.close();
        } else {
          (_a = this._relay) === null || _a === void 0 ? void 0 : _a.resetAndReload();
        }
      }
      getQrUrl() {
        var _a, _b;
        return (_b = (_a = this._relay) === null || _a === void 0 ? void 0 : _a.getQRCodeUrl()) !== null && _b !== void 0 ? _b : null;
      }
      getCoinbaseWalletLogo(type2, width = 240) {
        return (0, wallet_logo_1.walletLogo)(type2, width);
      }
      get walletExtension() {
        var _a;
        return (_a = window.coinbaseWalletExtension) !== null && _a !== void 0 ? _a : window.walletLinkExtension;
      }
      get coinbaseBrowser() {
        var _a, _b;
        try {
          const ethereum = (_a = window.ethereum) !== null && _a !== void 0 ? _a : (_b = window.top) === null || _b === void 0 ? void 0 : _b.ethereum;
          if (!ethereum) {
            return void 0;
          }
          if ("isCoinbaseBrowser" in ethereum && ethereum.isCoinbaseBrowser) {
            return ethereum;
          } else {
            return void 0;
          }
        } catch (e5) {
          return void 0;
        }
      }
      isCipherProvider(provider) {
        return typeof provider.isCipher === "boolean" && provider.isCipher;
      }
    };
    exports.CoinbaseWalletSDK = CoinbaseWalletSDK2;
    CoinbaseWalletSDK2.VERSION = SDK_VERSION;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinbaseWalletProvider = exports.CoinbaseWalletSDK = void 0;
    var CoinbaseWalletSDK_1 = require_CoinbaseWalletSDK();
    var CoinbaseWalletProvider_1 = require_CoinbaseWalletProvider();
    var CoinbaseWalletSDK_2 = require_CoinbaseWalletSDK();
    Object.defineProperty(exports, "CoinbaseWalletSDK", { enumerable: true, get: function() {
      return CoinbaseWalletSDK_2.CoinbaseWalletSDK;
    } });
    var CoinbaseWalletProvider_2 = require_CoinbaseWalletProvider();
    Object.defineProperty(exports, "CoinbaseWalletProvider", { enumerable: true, get: function() {
      return CoinbaseWalletProvider_2.CoinbaseWalletProvider;
    } });
    exports.default = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
    if (typeof window !== "undefined") {
      window.CoinbaseWalletSDK = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
      window.CoinbaseWalletProvider = CoinbaseWalletProvider_1.CoinbaseWalletProvider;
      window.WalletLink = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
      window.WalletLinkProvider = CoinbaseWalletProvider_1.CoinbaseWalletProvider;
    }
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow3(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow3;
    function getFromWindowOrThrow3(name) {
      const res = getFromWindow3(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow3;
    function getDocumentOrThrow3() {
      return getFromWindowOrThrow3("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow3;
    function getDocument3() {
      return getFromWindow3("document");
    }
    exports.getDocument = getDocument3;
    function getNavigatorOrThrow3() {
      return getFromWindowOrThrow3("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow3;
    function getNavigator3() {
      return getFromWindow3("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow3() {
      return getFromWindowOrThrow3("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow3;
    function getLocation3() {
      return getFromWindow3("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow3() {
      return getFromWindowOrThrow3("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow3;
    function getCrypto3() {
      return getFromWindow3("crypto");
    }
    exports.getCrypto = getCrypto3;
    function getLocalStorageOrThrow3() {
      return getFromWindowOrThrow3("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow3;
    function getLocalStorage3() {
      return getFromWindow3("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e5) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i5 = 0; i5 < links.length; i5++) {
          const link = links[i5];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i5 = 0; i5 < metaTags.length; i5++) {
          const tag = metaTags[i5];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName2() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName2();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata2;
  }
});

// node_modules/@walletconnect/browser-utils/node_modules/detect-browser/es/index.js
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser3 = _a[0], regex2 = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex2.exec(ua);
    return !!uaMatch && [browser3, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays2(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version3 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version3, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version3, os);
}
function detectOS(ua) {
  for (var ii = 0, count2 = operatingSystemRules.length; ii < count2; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex2 = _a[1];
    var match = regex2.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode3 = typeof process !== "undefined" && process.version;
  return isNode3 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count2) {
  var output = [];
  for (var ii = 0; ii < count2; ii++) {
    output.push("0");
  }
  return output;
}
var __spreadArrays2, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
var init_es = __esm({
  "node_modules/@walletconnect/browser-utils/node_modules/detect-browser/es/index.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    __spreadArrays2 = function() {
      for (var s5 = 0, i5 = 0, il = arguments.length; i5 < il; i5++)
        s5 += arguments[i5].length;
      for (var r6 = Array(s5), k5 = 0, i5 = 0; i5 < il; i5++)
        for (var a5 = arguments[i5], j5 = 0, jl = a5.length; j5 < jl; j5++, k5++)
          r6[k5] = a5[j5];
      return r6;
    };
    BrowserInfo = function() {
      function BrowserInfo2(name, version3, os) {
        this.name = name;
        this.version = version3;
        this.os = os;
        this.type = "browser";
      }
      return BrowserInfo2;
    }();
    NodeInfo = function() {
      function NodeInfo2(version3) {
        this.version = version3;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo2;
    }();
    SearchBotDeviceInfo = function() {
      function SearchBotDeviceInfo2(name, version3, os, bot) {
        this.name = name;
        this.version = version3;
        this.os = os;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo2;
    }();
    BotInfo = function() {
      function BotInfo2() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo2;
    }();
    ReactNativeInfo = function() {
      function ReactNativeInfo2() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo2;
    }();
    SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    REQUIRED_VERSION_PARTS = 3;
    userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FBAV\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS2() {
  const env5 = detectEnv();
  return env5 && env5.os ? env5.os : void 0;
}
function isAndroid() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os = detectOS2();
  return os ? isAndroid() || isIOS() : false;
}
function isNode() {
  const env5 = detectEnv();
  const result = env5 && env5.name ? env5.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode() && !!getNavigator2();
  return result;
}
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}
var windowMetadata, windowGetters, getFromWindow2, getFromWindowOrThrow2, getDocumentOrThrow2, getDocument2, getNavigatorOrThrow2, getNavigator2, getLocationOrThrow2, getLocation2, getCryptoOrThrow2, getCrypto2, getLocalStorageOrThrow2, getLocalStorage2;
var init_browser = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/browser.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    windowMetadata = __toESM(require_cjs2());
    windowGetters = __toESM(require_cjs());
    init_es();
    getFromWindow2 = windowGetters.getFromWindow;
    getFromWindowOrThrow2 = windowGetters.getFromWindowOrThrow;
    getDocumentOrThrow2 = windowGetters.getDocumentOrThrow;
    getDocument2 = windowGetters.getDocument;
    getNavigatorOrThrow2 = windowGetters.getNavigatorOrThrow;
    getNavigator2 = windowGetters.getNavigator;
    getLocationOrThrow2 = windowGetters.getLocationOrThrow;
    getLocation2 = windowGetters.getLocation;
    getCryptoOrThrow2 = windowGetters.getCryptoOrThrow;
    getCrypto2 = windowGetters.getCrypto;
    getLocalStorageOrThrow2 = windowGetters.getLocalStorageOrThrow;
    getLocalStorage2 = windowGetters.getLocalStorage;
  }
});

// node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}
var init_esm = __esm({
  "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/json.js
var safeJsonParse2, safeJsonStringify2;
var init_json = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/json.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_esm();
    safeJsonParse2 = safeJsonParse;
    safeJsonStringify2 = safeJsonStringify;
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/local.js
function setLocal(key, data) {
  const raw = safeJsonStringify2(data);
  const local = getLocalStorage2();
  if (local) {
    local.setItem(key, raw);
  }
}
function getLocal(key) {
  let data = null;
  let raw = null;
  const local = getLocalStorage2();
  if (local) {
    raw = local.getItem(key);
  }
  data = raw ? safeJsonParse2(raw) : raw;
  return data;
}
function removeLocal(key) {
  const local = getLocalStorage2();
  if (local) {
    local.removeItem(key);
  }
}
var init_local = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/local.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_json();
    init_browser();
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data) {
  const focusUri = data.href.split("?")[0];
  setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name) => getMobileRegistryEntry(registry, name)).filter(Boolean);
  }
  return links;
}
var mobileLinkChoiceKey;
var init_mobile = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/mobile.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_local();
    mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/registry.js
function getWalletRegistryUrl() {
  return API_URL + "/api/v2/wallets";
}
function getDappRegistryUrl() {
  return API_URL + "/api/v2/dapps";
}
function formatMobileRegistryEntry(entry, platform4 = "mobile") {
  var _a;
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: (_a = entry.image_url.sm) !== null && _a !== void 0 ? _a : "",
    universalLink: entry[platform4].universal || "",
    deepLink: entry[platform4].native || ""
  };
}
function formatMobileRegistry(registry, platform4 = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform4].universal || !!entry[platform4].native).map((entry) => formatMobileRegistryEntry(entry, platform4));
}
var API_URL;
var init_registry = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/registry.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    API_URL = "https://registry.walletconnect.com";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  detectEnv: () => detectEnv,
  detectOS: () => detectOS2,
  formatIOSMobile: () => formatIOSMobile,
  formatMobileRegistry: () => formatMobileRegistry,
  formatMobileRegistryEntry: () => formatMobileRegistryEntry,
  getClientMeta: () => getClientMeta,
  getCrypto: () => getCrypto2,
  getCryptoOrThrow: () => getCryptoOrThrow2,
  getDappRegistryUrl: () => getDappRegistryUrl,
  getDocument: () => getDocument2,
  getDocumentOrThrow: () => getDocumentOrThrow2,
  getFromWindow: () => getFromWindow2,
  getFromWindowOrThrow: () => getFromWindowOrThrow2,
  getLocal: () => getLocal,
  getLocalStorage: () => getLocalStorage2,
  getLocalStorageOrThrow: () => getLocalStorageOrThrow2,
  getLocation: () => getLocation2,
  getLocationOrThrow: () => getLocationOrThrow2,
  getMobileLinkRegistry: () => getMobileLinkRegistry,
  getMobileRegistryEntry: () => getMobileRegistryEntry,
  getNavigator: () => getNavigator2,
  getNavigatorOrThrow: () => getNavigatorOrThrow2,
  getWalletRegistryUrl: () => getWalletRegistryUrl,
  isAndroid: () => isAndroid,
  isBrowser: () => isBrowser,
  isIOS: () => isIOS,
  isMobile: () => isMobile,
  isNode: () => isNode,
  mobileLinkChoiceKey: () => mobileLinkChoiceKey,
  removeLocal: () => removeLocal,
  safeJsonParse: () => safeJsonParse2,
  safeJsonStringify: () => safeJsonStringify2,
  saveMobileLinkInfo: () => saveMobileLinkInfo,
  setLocal: () => setLocal
});
var init_esm2 = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/index.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_browser();
    init_json();
    init_local();
    init_mobile();
    init_registry();
  }
});

// node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js
var require_bn8 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base2, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        Buffer4 = require_buffer().Buffer;
      } catch (e5) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base2 === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base2, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i5 = number.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number[i5] | number[i5 - 1] << 8 | number[i5 - 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number.length; i5 += 3) {
            w6 = number[i5] | number[i5 + 1] << 8 | number[i5 + 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 <<= 4;
          if (c5 >= 49 && c5 <= 54) {
            r6 |= c5 - 49 + 10;
          } else if (c5 >= 17 && c5 <= 22) {
            r6 |= c5 - 17 + 10;
          } else {
            r6 |= c5 & 15;
          }
        }
        return r6;
      }
      BN2.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off3 = 0;
        for (i5 = number.length - 6, j5 = 0; i5 >= start; i5 -= 6) {
          w6 = parseHex(number, i5, i5 + 6);
          this.words[j5] |= w6 << off3 & 67108863;
          this.words[j5 + 1] |= w6 >>> 26 - off3 & 4194303;
          off3 += 24;
          if (off3 >= 26) {
            off3 -= 26;
            j5++;
          }
        }
        if (i5 + 6 !== start) {
          w6 = parseHex(number, start, i5 + 6);
          this.words[j5] |= w6 << off3 & 67108863;
          this.words[j5 + 1] |= w6 >>> 26 - off3 & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN2.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i5, number.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN2.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r6 = new BN2(null);
        this.copy(r6);
        return r6;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength3; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN2.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN2.prototype._countBits(N4) - 1;
        for (var i5 = 0; i5 < N4; i5++) {
          t5[i5] = this.revBin(i5, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i5 = 0; i5 < N4; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s5 = 1; s5 < N4; s5 <<= 1) {
          var l5 = s5 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s5; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s5];
              var io = itws[p5 + j5 + s5];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s5] = re - ro;
              itws[p5 + j5 + s5] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N4 = Math.max(m5, n3) | 1;
        var odd = N4 & 1;
        var i5 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N4 - i5 - 1];
          rws[N4 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N4 - i5 - 1];
          iws[N4 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N4) * 8192 + Math.round(ws[2 * i5] / N4) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N4; ++i5) {
          rws[i5] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i5 = 0; i5 < N4; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _6 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _6, rwst, iwst, N4, rbt);
        this.transform(nrws, _6, nrwst, niwst, N4, rbt);
        for (var i5 = 0; i5 < N4; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _6, N4, rbt);
        this.conjugate(rmws, _6, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN2(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s5 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s5] = this.words[i5];
          }
          for (i5 = 0; i5 < s5; i5++) {
            this.words[i5] = 0;
          }
          this.length += s5;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s5 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s5;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s5; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s5;
        }
        if (s5 === 0) {
        } else if (this.length > s5) {
          this.length -= s5;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s5];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5)
          return false;
        var w6 = this.words[s5];
        return !!(w6 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s5) {
          return this;
        }
        if (r6 !== 0) {
          s5++;
        }
        this.length = Math.min(s5, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN2(1);
        var B4 = new BN2(0);
        var C4 = new BN2(0);
        var D3 = new BN2(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B4.isOdd()) {
                A6.iadd(yp);
                B4.isub(xp);
              }
              A6.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D3.isOdd()) {
                C4.iadd(yp);
                D3.isub(xp);
              }
              C4.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B4.isub(D3);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D3.isub(B4);
          }
        }
        return {
          a: C4,
          b: D3,
          gcd: y5.iushln(g5)
        };
      };
      BN2.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5) {
          this._expand(s5 + 1);
          this.words[s5] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s5; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN2(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          r6.strip();
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN2._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s5 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s5++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z5 = this.m.bitLength();
        z5 = new BN2(2 * z5 * z5).toRed(this);
        while (this.pow(z5, lpow).cmp(nOne) !== 0) {
          z5.redIAdd(nOne);
        }
        var c5 = this.pow(z5, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s5;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert3(i5 < m5);
          var b4 = this.pow(c5, new BN2(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = isTypedArray2;
    isTypedArray2.strict = isStrictTypedArray;
    isTypedArray2.loose = isLooseTypedArray;
    var toString4 = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray2(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString4.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var isTypedArray2 = require_is_typedarray().strict;
    module.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray2(arr)) {
        var buf = Buffer2.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer2.from(arr);
      }
    };
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha32 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING2 = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n3, s5) {
          return methods["cshake" + bits2].update(message, outputBits, n3, s5)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s5) {
          return methods["kmac" + bits2].update(key, message, outputBits, s5)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i6 = 0; i6 < OUTPUT_TYPES.length; ++i6) {
          var type2 = OUTPUT_TYPES[i6];
          method[type2] = createMethod2(bits2, padding, type2);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w6 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n3, s5) {
          if (!n3 && !s5) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n3, s5], w6);
          }
        };
        method.update = function(message, outputBits, n3, s5) {
          return method.create(outputBits, n3, s5).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w6 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s5) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s5], w6).bytepad([key], w6);
        };
        method.update = function(key, message, outputBits, s5) {
          return method.create(key, outputBits, s5).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING2, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i5 = 0; i5 < algorithms.length; ++i5) {
        var algorithm = algorithms[i5];
        var bits = algorithm.bits;
        for (var j5 = 0; j5 < bits.length; ++j5) {
          var methodName = algorithm.name + "_" + bits[j5];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j5], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j5];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i6 = 0; i6 < 50; ++i6) {
          this.s[i6] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type2 = typeof message;
        if (type2 !== "string") {
          if (type2 === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s5 = this.s, i6, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i6 = 1; i6 < blockCount + 1; ++i6) {
              blocks[i6] = 0;
            }
          }
          if (notString) {
            for (i6 = this.start; index < length && i6 < byteCount; ++index) {
              blocks[i6 >> 2] |= message[index] << SHIFT[i6++ & 3];
            }
          } else {
            for (i6 = this.start; index < length && i6 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i6 >> 2] |= code << SHIFT[i6++ & 3];
              } else if (code < 2048) {
                blocks[i6 >> 2] |= (192 | code >> 6) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code & 63) << SHIFT[i6++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i6 >> 2] |= (224 | code >> 12) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code & 63) << SHIFT[i6++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i6 >> 2] |= (240 | code >> 18) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code & 63) << SHIFT[i6++ & 3];
              }
            }
          }
          this.lastByteIndex = i6;
          if (i6 >= byteCount) {
            this.start = i6 - byteCount;
            this.block = blocks[blockCount];
            for (i6 = 0; i6 < blockCount; ++i6) {
              s5[i6] ^= blocks[i6];
            }
            f5(s5);
            this.reset = true;
          } else {
            this.start = i6;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x5, right) {
        var o5 = x5 & 255, n3 = 1;
        var bytes = [o5];
        x5 = x5 >> 8;
        o5 = x5 & 255;
        while (o5 > 0) {
          bytes.unshift(o5);
          x5 = x5 >> 8;
          o5 = x5 & 255;
          ++n3;
        }
        if (right) {
          bytes.push(n3);
        } else {
          bytes.unshift(n3);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type2 = typeof str;
        if (type2 !== "string") {
          if (type2 === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i6 = 0; i6 < str.length; ++i6) {
            var code = str.charCodeAt(i6);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i6) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w6) {
        var bytes = this.encode(w6);
        for (var i6 = 0; i6 < strs.length; ++i6) {
          bytes += this.encodeString(strs[i6]);
        }
        var paddingBytes = w6 - bytes % w6;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i6 = this.lastByteIndex, blockCount = this.blockCount, s5 = this.s;
        blocks[i6 >> 2] |= this.padding[i6 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i6 = 1; i6 < blockCount + 1; ++i6) {
            blocks[i6] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i6 = 0; i6 < blockCount; ++i6) {
          s5[i6] ^= blocks[i6];
        }
        f5(s5);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s5 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i6 = 0, j6 = 0;
        var hex = "", block;
        while (j6 < outputBlocks) {
          for (i6 = 0; i6 < blockCount && j6 < outputBlocks; ++i6, ++j6) {
            block = s5[i6];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j6 % blockCount === 0) {
            f5(s5);
            i6 = 0;
          }
        }
        if (extraBytes) {
          block = s5[i6];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s5 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i6 = 0, j6 = 0;
        var bytes = this.outputBits >> 3;
        var buffer2;
        if (extraBytes) {
          buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer2 = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer2);
        while (j6 < outputBlocks) {
          for (i6 = 0; i6 < blockCount && j6 < outputBlocks; ++i6, ++j6) {
            array[j6] = s5[i6];
          }
          if (j6 % blockCount === 0) {
            f5(s5);
          }
        }
        if (extraBytes) {
          array[i6] = s5[i6];
          buffer2 = buffer2.slice(0, bytes);
        }
        return buffer2;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s5 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i6 = 0, j6 = 0;
        var array = [], offset, block;
        while (j6 < outputBlocks) {
          for (i6 = 0; i6 < blockCount && j6 < outputBlocks; ++i6, ++j6) {
            offset = j6 << 2;
            block = s5[i6];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j6 % blockCount === 0) {
            f5(s5);
          }
        }
        if (extraBytes) {
          offset = j6 << 2;
          block = s5[i6];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f5 = function(s5) {
        var h5, l5, n3, c0, c1, c22, c32, c42, c5, c6, c7, c8, c9, b0, b1, b22, b32, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n3 = 0; n3 < 48; n3 += 2) {
          c0 = s5[0] ^ s5[10] ^ s5[20] ^ s5[30] ^ s5[40];
          c1 = s5[1] ^ s5[11] ^ s5[21] ^ s5[31] ^ s5[41];
          c22 = s5[2] ^ s5[12] ^ s5[22] ^ s5[32] ^ s5[42];
          c32 = s5[3] ^ s5[13] ^ s5[23] ^ s5[33] ^ s5[43];
          c42 = s5[4] ^ s5[14] ^ s5[24] ^ s5[34] ^ s5[44];
          c5 = s5[5] ^ s5[15] ^ s5[25] ^ s5[35] ^ s5[45];
          c6 = s5[6] ^ s5[16] ^ s5[26] ^ s5[36] ^ s5[46];
          c7 = s5[7] ^ s5[17] ^ s5[27] ^ s5[37] ^ s5[47];
          c8 = s5[8] ^ s5[18] ^ s5[28] ^ s5[38] ^ s5[48];
          c9 = s5[9] ^ s5[19] ^ s5[29] ^ s5[39] ^ s5[49];
          h5 = c8 ^ (c22 << 1 | c32 >>> 31);
          l5 = c9 ^ (c32 << 1 | c22 >>> 31);
          s5[0] ^= h5;
          s5[1] ^= l5;
          s5[10] ^= h5;
          s5[11] ^= l5;
          s5[20] ^= h5;
          s5[21] ^= l5;
          s5[30] ^= h5;
          s5[31] ^= l5;
          s5[40] ^= h5;
          s5[41] ^= l5;
          h5 = c0 ^ (c42 << 1 | c5 >>> 31);
          l5 = c1 ^ (c5 << 1 | c42 >>> 31);
          s5[2] ^= h5;
          s5[3] ^= l5;
          s5[12] ^= h5;
          s5[13] ^= l5;
          s5[22] ^= h5;
          s5[23] ^= l5;
          s5[32] ^= h5;
          s5[33] ^= l5;
          s5[42] ^= h5;
          s5[43] ^= l5;
          h5 = c22 ^ (c6 << 1 | c7 >>> 31);
          l5 = c32 ^ (c7 << 1 | c6 >>> 31);
          s5[4] ^= h5;
          s5[5] ^= l5;
          s5[14] ^= h5;
          s5[15] ^= l5;
          s5[24] ^= h5;
          s5[25] ^= l5;
          s5[34] ^= h5;
          s5[35] ^= l5;
          s5[44] ^= h5;
          s5[45] ^= l5;
          h5 = c42 ^ (c8 << 1 | c9 >>> 31);
          l5 = c5 ^ (c9 << 1 | c8 >>> 31);
          s5[6] ^= h5;
          s5[7] ^= l5;
          s5[16] ^= h5;
          s5[17] ^= l5;
          s5[26] ^= h5;
          s5[27] ^= l5;
          s5[36] ^= h5;
          s5[37] ^= l5;
          s5[46] ^= h5;
          s5[47] ^= l5;
          h5 = c6 ^ (c0 << 1 | c1 >>> 31);
          l5 = c7 ^ (c1 << 1 | c0 >>> 31);
          s5[8] ^= h5;
          s5[9] ^= l5;
          s5[18] ^= h5;
          s5[19] ^= l5;
          s5[28] ^= h5;
          s5[29] ^= l5;
          s5[38] ^= h5;
          s5[39] ^= l5;
          s5[48] ^= h5;
          s5[49] ^= l5;
          b0 = s5[0];
          b1 = s5[1];
          b322 = s5[11] << 4 | s5[10] >>> 28;
          b33 = s5[10] << 4 | s5[11] >>> 28;
          b14 = s5[20] << 3 | s5[21] >>> 29;
          b15 = s5[21] << 3 | s5[20] >>> 29;
          b46 = s5[31] << 9 | s5[30] >>> 23;
          b47 = s5[30] << 9 | s5[31] >>> 23;
          b28 = s5[40] << 18 | s5[41] >>> 14;
          b29 = s5[41] << 18 | s5[40] >>> 14;
          b20 = s5[2] << 1 | s5[3] >>> 31;
          b21 = s5[3] << 1 | s5[2] >>> 31;
          b22 = s5[13] << 12 | s5[12] >>> 20;
          b32 = s5[12] << 12 | s5[13] >>> 20;
          b34 = s5[22] << 10 | s5[23] >>> 22;
          b35 = s5[23] << 10 | s5[22] >>> 22;
          b16 = s5[33] << 13 | s5[32] >>> 19;
          b17 = s5[32] << 13 | s5[33] >>> 19;
          b48 = s5[42] << 2 | s5[43] >>> 30;
          b49 = s5[43] << 2 | s5[42] >>> 30;
          b40 = s5[5] << 30 | s5[4] >>> 2;
          b41 = s5[4] << 30 | s5[5] >>> 2;
          b222 = s5[14] << 6 | s5[15] >>> 26;
          b23 = s5[15] << 6 | s5[14] >>> 26;
          b4 = s5[25] << 11 | s5[24] >>> 21;
          b5 = s5[24] << 11 | s5[25] >>> 21;
          b36 = s5[34] << 15 | s5[35] >>> 17;
          b37 = s5[35] << 15 | s5[34] >>> 17;
          b18 = s5[45] << 29 | s5[44] >>> 3;
          b19 = s5[44] << 29 | s5[45] >>> 3;
          b10 = s5[6] << 28 | s5[7] >>> 4;
          b11 = s5[7] << 28 | s5[6] >>> 4;
          b42 = s5[17] << 23 | s5[16] >>> 9;
          b43 = s5[16] << 23 | s5[17] >>> 9;
          b24 = s5[26] << 25 | s5[27] >>> 7;
          b25 = s5[27] << 25 | s5[26] >>> 7;
          b6 = s5[36] << 21 | s5[37] >>> 11;
          b7 = s5[37] << 21 | s5[36] >>> 11;
          b38 = s5[47] << 24 | s5[46] >>> 8;
          b39 = s5[46] << 24 | s5[47] >>> 8;
          b30 = s5[8] << 27 | s5[9] >>> 5;
          b31 = s5[9] << 27 | s5[8] >>> 5;
          b12 = s5[18] << 20 | s5[19] >>> 12;
          b13 = s5[19] << 20 | s5[18] >>> 12;
          b44 = s5[29] << 7 | s5[28] >>> 25;
          b45 = s5[28] << 7 | s5[29] >>> 25;
          b26 = s5[38] << 8 | s5[39] >>> 24;
          b27 = s5[39] << 8 | s5[38] >>> 24;
          b8 = s5[48] << 14 | s5[49] >>> 18;
          b9 = s5[49] << 14 | s5[48] >>> 18;
          s5[0] = b0 ^ ~b22 & b4;
          s5[1] = b1 ^ ~b32 & b5;
          s5[10] = b10 ^ ~b12 & b14;
          s5[11] = b11 ^ ~b13 & b15;
          s5[20] = b20 ^ ~b222 & b24;
          s5[21] = b21 ^ ~b23 & b25;
          s5[30] = b30 ^ ~b322 & b34;
          s5[31] = b31 ^ ~b33 & b35;
          s5[40] = b40 ^ ~b42 & b44;
          s5[41] = b41 ^ ~b43 & b45;
          s5[2] = b22 ^ ~b4 & b6;
          s5[3] = b32 ^ ~b5 & b7;
          s5[12] = b12 ^ ~b14 & b16;
          s5[13] = b13 ^ ~b15 & b17;
          s5[22] = b222 ^ ~b24 & b26;
          s5[23] = b23 ^ ~b25 & b27;
          s5[32] = b322 ^ ~b34 & b36;
          s5[33] = b33 ^ ~b35 & b37;
          s5[42] = b42 ^ ~b44 & b46;
          s5[43] = b43 ^ ~b45 & b47;
          s5[4] = b4 ^ ~b6 & b8;
          s5[5] = b5 ^ ~b7 & b9;
          s5[14] = b14 ^ ~b16 & b18;
          s5[15] = b15 ^ ~b17 & b19;
          s5[24] = b24 ^ ~b26 & b28;
          s5[25] = b25 ^ ~b27 & b29;
          s5[34] = b34 ^ ~b36 & b38;
          s5[35] = b35 ^ ~b37 & b39;
          s5[44] = b44 ^ ~b46 & b48;
          s5[45] = b45 ^ ~b47 & b49;
          s5[6] = b6 ^ ~b8 & b0;
          s5[7] = b7 ^ ~b9 & b1;
          s5[16] = b16 ^ ~b18 & b10;
          s5[17] = b17 ^ ~b19 & b11;
          s5[26] = b26 ^ ~b28 & b20;
          s5[27] = b27 ^ ~b29 & b21;
          s5[36] = b36 ^ ~b38 & b30;
          s5[37] = b37 ^ ~b39 & b31;
          s5[46] = b46 ^ ~b48 & b40;
          s5[47] = b47 ^ ~b49 & b41;
          s5[8] = b8 ^ ~b0 & b22;
          s5[9] = b9 ^ ~b1 & b32;
          s5[18] = b18 ^ ~b10 & b12;
          s5[19] = b19 ^ ~b11 & b13;
          s5[28] = b28 ^ ~b20 & b222;
          s5[29] = b29 ^ ~b21 & b23;
          s5[38] = b38 ^ ~b30 & b322;
          s5[39] = b39 ^ ~b31 & b33;
          s5[48] = b48 ^ ~b40 & b42;
          s5[49] = b49 ^ ~b41 & b43;
          s5[0] ^= RC[n3];
          s5[1] ^= RC[n3 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i5 = 0; i5 < methodNames.length; ++i5) {
          root[methodNames[i5]] = methods[methodNames[i5]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto2() {
      return (globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) || (globalThis === null || globalThis === void 0 ? void 0 : globalThis.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto2;
    function getSubtleCrypto2() {
      const browserCrypto = getBrowerCrypto2();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto2;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto2() && !!getSubtleCrypto2();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode3() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode3;
    function isBrowser2() {
      return !isReactNative() && !isNode3();
    }
    exports.isBrowser = isBrowser2;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o5, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o5[k22] = m5[k5];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m5, exports2) {
      for (var p5 in m5)
        if (p5 !== "default" && !exports2.hasOwnProperty(p5))
          __createBinding2(exports2, m5, p5);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_crypto2(), exports);
    __exportStar2(require_env(), exports);
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x5) => `%${x5.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp(token, "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return decodeURIComponent(components.join(""));
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher);
        for (var i5 = 1; i5 < tokens.length; i5++) {
          input = decodeComponents(tokens, i5).join("");
          tokens = input.match(singleMatcher);
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i5 = 0; i5 < entries.length; i5++) {
        var key = entries[i5];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined2 = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode2(key, options), "=", encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray5 = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray5 ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a5, b4) => Number(a5) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse4(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k5 of Object.keys(value)) {
            value[k5] = parseValue(value[k5], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse4;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys2 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys2.sort(options.sort);
      }
      return keys2.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x5) => x5.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash] = splitOnFirst(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse4(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash = `#${encode2(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js
var require_browser13 = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/qrcode/node_modules/isarray/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var toString4 = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString4.call(arr) == "[object Array]";
    };
  }
});

// node_modules/qrcode/lib/utils/typedarray-buffer.js
var require_typedarray_buffer = __commonJS({
  "node_modules/qrcode/lib/utils/typedarray-buffer.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var isArray5 = require_isarray();
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
          return 42;
        } };
        return arr.foo() === 42;
      } catch (e5) {
        return false;
      }
    }
    Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
    var K_MAX_LENGTH = Buffer4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    function Buffer4(arg, offset, length) {
      if (!Buffer4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer4)) {
        return new Buffer4(arg, offset, length);
      }
      if (typeof arg === "number") {
        return allocUnsafe3(this, arg);
      }
      return from4(this, arg, offset, length);
    }
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      Buffer4.prototype.__proto__ = Uint8Array.prototype;
      Buffer4.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer4[Symbol.species] === Buffer4) {
        Object.defineProperty(Buffer4, Symbol.species, {
          value: null,
          configurable: true,
          enumerable: false,
          writable: false
        });
      }
    }
    function checked3(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function isnan3(val) {
      return val !== val;
    }
    function createBuffer3(that, length) {
      var buf;
      if (Buffer4.TYPED_ARRAY_SUPPORT) {
        buf = new Uint8Array(length);
        buf.__proto__ = Buffer4.prototype;
      } else {
        buf = that;
        if (buf === null) {
          buf = new Buffer4(length);
        }
        buf.length = length;
      }
      return buf;
    }
    function allocUnsafe3(that, size) {
      var buf = createBuffer3(that, size < 0 ? 0 : checked3(size) | 0);
      if (!Buffer4.TYPED_ARRAY_SUPPORT) {
        for (var i5 = 0; i5 < size; ++i5) {
          buf[i5] = 0;
        }
      }
      return buf;
    }
    function fromString3(that, string) {
      var length = byteLength3(string) | 0;
      var buf = createBuffer3(that, length);
      var actual = buf.write(string);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike3(that, array) {
      var length = array.length < 0 ? 0 : checked3(array.length) | 0;
      var buf = createBuffer3(that, length);
      for (var i5 = 0; i5 < length; i5 += 1) {
        buf[i5] = array[i5] & 255;
      }
      return buf;
    }
    function fromArrayBuffer3(that, array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError("'length' is out of bounds");
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      if (Buffer4.TYPED_ARRAY_SUPPORT) {
        buf.__proto__ = Buffer4.prototype;
      } else {
        buf = fromArrayLike3(that, buf);
      }
      return buf;
    }
    function fromObject3(that, obj) {
      if (Buffer4.isBuffer(obj)) {
        var len = checked3(obj.length) | 0;
        var buf = createBuffer3(that, len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj) {
        if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
          if (typeof obj.length !== "number" || isnan3(obj.length)) {
            return createBuffer3(that, 0);
          }
          return fromArrayLike3(that, obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike3(that, obj.data);
        }
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }
    function utf8ToBytes3(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i5 = 0; i5 < length; ++i5) {
        codePoint = string.charCodeAt(i5);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i5 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function byteLength3(string) {
      if (Buffer4.isBuffer(string)) {
        return string.length;
      }
      if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        string = "" + string;
      }
      var len = string.length;
      if (len === 0)
        return 0;
      return utf8ToBytes3(string).length;
    }
    function blitBuffer3(src, dst, offset, length) {
      for (var i5 = 0; i5 < length; ++i5) {
        if (i5 + offset >= dst.length || i5 >= src.length)
          break;
        dst[i5 + offset] = src[i5];
      }
      return i5;
    }
    function utf8Write3(buf, string, offset, length) {
      return blitBuffer3(utf8ToBytes3(string, buf.length - offset), buf, offset, length);
    }
    function from4(that, value, offset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
        return fromArrayBuffer3(that, value, offset, length);
      }
      if (typeof value === "string") {
        return fromString3(that, value, offset);
      }
      return fromObject3(that, value);
    }
    Buffer4.prototype.write = function write4(string, offset, length) {
      if (offset === void 0) {
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
        } else {
          length = void 0;
        }
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      return utf8Write3(this, string, offset, length);
    };
    Buffer4.prototype.slice = function slice3(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer4.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer4.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer4(sliceLen, void 0);
        for (var i5 = 0; i5 < sliceLen; ++i5) {
          newBuf[i5] = this[i5 + start];
        }
      }
      return newBuf;
    };
    Buffer4.prototype.copy = function copy3(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i5;
      if (this === target && start < targetStart && targetStart < end) {
        for (i5 = len - 1; i5 >= 0; --i5) {
          target[i5 + targetStart] = this[i5 + start];
        }
      } else if (len < 1e3 || !Buffer4.TYPED_ARRAY_SUPPORT) {
        for (i5 = 0; i5 < len; ++i5) {
          target[i5 + targetStart] = this[i5 + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer4.prototype.fill = function fill3(val, start, end) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        var bytes = Buffer4.isBuffer(val) ? val : new Buffer4(val);
        var len = bytes.length;
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    Buffer4.concat = function concat5(list, length) {
      if (!isArray5(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return createBuffer3(null, 0);
      }
      var i5;
      if (length === void 0) {
        length = 0;
        for (i5 = 0; i5 < list.length; ++i5) {
          length += list[i5].length;
        }
      }
      var buffer2 = allocUnsafe3(null, length);
      var pos = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        var buf = list[i5];
        if (!Buffer4.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer2, pos);
        pos += buf.length;
      }
      return buffer2;
    };
    Buffer4.byteLength = byteLength3;
    Buffer4.prototype._isBuffer = true;
    Buffer4.isBuffer = function isBuffer5(b4) {
      return !!(b4 != null && b4._isBuffer);
    };
    module.exports.alloc = function(size) {
      var buffer2 = new Buffer4(size);
      buffer2.fill(0);
      return buffer2;
    };
    module.exports.from = function(data) {
      return new Buffer4(data);
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils8 = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version3) {
      if (!version3)
        throw new Error('"version" cannot be null or undefined');
      if (version3 < 1 || version3 > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version3 * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version3) {
      return CODEWORDS_COUNT[version3];
    };
    exports.getBCHDigit = function(data) {
      var digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f5) {
      if (typeof f5 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f5;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString3(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from4(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e5) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        var bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (var i5 = 0; i5 < length; i5++) {
          this.putBit((num >>> length - i5 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        var bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = BufferUtil.alloc(size * size);
      this.reservedBit = BufferUtil.alloc(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      var index = row * this.size + col;
      this.data[index] = value;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var getSymbolSize = require_utils8().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version3) {
      if (version3 === 1)
        return [];
      var posCount = Math.floor(version3 / 7) + 2;
      var size = getSymbolSize(version3);
      var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      var positions = [size - 7];
      for (var i5 = 1; i5 < posCount - 1; i5++) {
        positions[i5] = positions[i5 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version3) {
      var coords = [];
      var pos = exports.getRowColCoords(version3);
      var posLength = pos.length;
      for (var i5 = 0; i5 < posLength; i5++) {
        for (var j5 = 0; j5 < posLength; j5++) {
          if (i5 === 0 && j5 === 0 || i5 === 0 && j5 === posLength - 1 || i5 === posLength - 1 && j5 === 0) {
            continue;
          }
          coords.push([pos[i5], pos[j5]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var getSymbolSize = require_utils8().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version3) {
      var size = getSymbolSize(version3);
      return [
        [0, 0],
        [size - FINDER_PATTERN_SIZE, 0],
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from4(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      var size = data.size;
      var points = 0;
      var sameCountCol = 0;
      var sameCountRow = 0;
      var lastCol = null;
      var lastRow = null;
      for (var row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (var col = 0; col < size; col++) {
          var module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      var size = data.size;
      var points = 0;
      for (var row = 0; row < size - 1; row++) {
        for (var col = 0; col < size - 1; col++) {
          var last2 = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last2 === 4 || last2 === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      var size = data.size;
      var points = 0;
      var bitsCol = 0;
      var bitsRow = 0;
      for (var row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (var col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      var darkCount = 0;
      var modulesCount = data.data.length;
      for (var i5 = 0; i5 < modulesCount; i5++)
        darkCount += data.data[i5];
      var k5 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k5 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i5, j5) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i5 + j5) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i5 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j5 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i5 + j5) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i5 / 2) + Math.floor(j5 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i5 * j5 % 2 + i5 * j5 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i5 * j5 % 2 + i5 * j5 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i5 * j5 % 3 + (i5 + j5) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      var size = data.size;
      for (var col = 0; col < size; col++) {
        for (var row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      var numPatterns = Object.keys(exports.Patterns).length;
      var bestPattern = 0;
      var lowerPenalty = Infinity;
      for (var p5 = 0; p5 < numPatterns; p5++) {
        setupFormatFunc(p5);
        exports.applyMask(p5, data);
        var penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p5, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p5;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version3, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version3, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var EXP_TABLE = BufferUtil.alloc(512);
    var LOG_TABLE = BufferUtil.alloc(256);
    (function initTables() {
      var x5 = 1;
      for (var i5 = 0; i5 < 255; i5++) {
        EXP_TABLE[i5] = x5;
        LOG_TABLE[x5] = i5;
        x5 <<= 1;
        if (x5 & 256) {
          x5 ^= 285;
        }
      }
      for (i5 = 255; i5 < 512; i5++) {
        EXP_TABLE[i5] = EXP_TABLE[i5 - 255];
      }
    })();
    exports.log = function log2(n3) {
      if (n3 < 1)
        throw new Error("log(" + n3 + ")");
      return LOG_TABLE[n3];
    };
    exports.exp = function exp(n3) {
      return EXP_TABLE[n3];
    };
    exports.mul = function mul(x5, y5) {
      if (x5 === 0 || y5 === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x5] + LOG_TABLE[y5]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var GF = require_galois_field();
    exports.mul = function mul(p1, p22) {
      var coeff = BufferUtil.alloc(p1.length + p22.length - 1);
      for (var i5 = 0; i5 < p1.length; i5++) {
        for (var j5 = 0; j5 < p22.length; j5++) {
          coeff[i5 + j5] ^= GF.mul(p1[i5], p22[j5]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      var result = BufferUtil.from(divident);
      while (result.length - divisor.length >= 0) {
        var coeff = result[0];
        for (var i5 = 0; i5 < divisor.length; i5++) {
          result[i5] ^= GF.mul(divisor[i5], coeff);
        }
        var offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      var poly = BufferUtil.from([1]);
      for (var i5 = 0; i5 < degree; i5++) {
        poly = exports.mul(poly, [1, GF.exp(i5)]);
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var Polynomial = require_polynomial();
    var Buffer4 = require_buffer().Buffer;
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode2(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      var pad2 = BufferUtil.alloc(this.degree);
      var paddedData = Buffer4.concat([data, pad2], data.length + this.degree);
      var remainder = Polynomial.mod(paddedData, this.genPoly);
      var start = this.degree - remainder.length;
      if (start > 0) {
        var buff = BufferUtil.alloc(this.degree);
        remainder.copy(buff, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports.isValid = function isValid(version3) {
      return !isNaN(version3) && version3 >= 1 && version3 <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version3) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version3)) {
        throw new Error("Invalid version: " + version3);
      }
      if (version3 >= 1 && version3 < 10)
        return mode.ccBits[0];
      else if (version3 < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports.KANJI;
      else
        return exports.BYTE;
    };
    exports.toString = function toString4(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString3(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from4(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e5) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version2 = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Utils = require_utils8();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var isArray5 = require_isarray();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version3) {
      return Mode.getCharCountIndicator(mode, version3) + 4;
    }
    function getTotalBitsFromDataArray(segments, version3) {
      var totalBits = 0;
      segments.forEach(function(data) {
        var reservedBits = getReservedBitsCount(data.mode, version3);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        var length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from4(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version3, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version3)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      var totalCodewords = Utils.getSymbolTotalCodewords(version3);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version3, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version3);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      var seg;
      var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (isArray5(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version3) {
      if (!VersionCheck.isValid(version3) || version3 < 7) {
        throw new Error("Invalid QR Code version");
      }
      var d5 = version3 << 12;
      while (Utils.getBCHDigit(d5) - G18_BCH >= 0) {
        d5 ^= G18 << Utils.getBCHDigit(d5) - G18_BCH;
      }
      return version3 << 12 | d5;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Utils = require_utils8();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      var data = errorCorrectionLevel.bit << 3 | mask;
      var d5 = data << 10;
      while (Utils.getBCHDigit(d5) - G15_BCH >= 0) {
        d5 ^= G15 << Utils.getBCHDigit(d5) - G15_BCH;
      }
      return (data << 10 | d5) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write4(bitBuffer) {
      var i5, group, value;
      for (i5 = 0; i5 + 3 <= this.data.length; i5 += 3) {
        group = this.data.substr(i5, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      var remainingNum = this.data.length - i5;
      if (remainingNum > 0) {
        group = this.data.substr(i5);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write4(bitBuffer) {
      var i5;
      for (i5 = 0; i5 + 2 <= this.data.length; i5 += 2) {
        var value = ALPHA_NUM_CHARS.indexOf(this.data[i5]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i5 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i5]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      this.data = BufferUtil.from(data);
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (var i5 = 0, l5 = this.data.length; i5 < l5; i5++) {
        bitBuffer.put(this.data[i5], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Mode = require_mode();
    var Utils = require_utils8();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      var i5;
      for (i5 = 0; i5 < this.data.length; i5++) {
        var value = Utils.toSJIS(this.data[i5]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i5] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var dijkstra = {
      single_source_shortest_paths: function(graph, s5, d5) {
        var predecessors = {};
        var costs = {};
        costs[s5] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s5, 0);
        var closest, u5, v5, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u5 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u5] || {};
          for (v5 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v5)) {
              cost_of_e = adjacent_nodes[v5];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v5];
              first_visit = typeof costs[v5] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v5] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v5, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v5] = u5;
              }
            }
          }
        }
        if (typeof d5 !== "undefined" && typeof costs[d5] === "undefined") {
          var msg = ["Could not find a path from ", s5, " to ", d5, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d5) {
        var nodes = [];
        var u5 = d5;
        var predecessor;
        while (u5) {
          nodes.push(u5);
          predecessor = predecessors[u5];
          u5 = predecessors[u5];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s5, d5) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s5, d5);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d5
        );
      },
      PriorityQueue: {
        make: function(opts) {
          var T6 = dijkstra.PriorityQueue, t5 = {}, key;
          opts = opts || {};
          for (key in T6) {
            if (T6.hasOwnProperty(key)) {
              t5[key] = T6[key];
            }
          }
          t5.queue = [];
          t5.sorter = opts.sorter || T6.default_sorter;
          return t5;
        },
        default_sorter: function(a5, b4) {
          return a5.cost - b4.cost;
        },
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils8();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex2, mode, str) {
      var segments = [];
      var result;
      while ((result = regex2.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      var byteSegs;
      var kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s22) {
        return s1.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      var nodes = [];
      for (var i5 = 0; i5 < segs.length; i5++) {
        var seg = segs[i5];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version3) {
      var table = {};
      var graph = { "start": {} };
      var prevNodeIds = ["start"];
      for (var i5 = 0; i5 < nodes.length; i5++) {
        var nodeGroup = nodes[i5];
        var currentNodeIds = [];
        for (var j5 = 0; j5 < nodeGroup.length; j5++) {
          var node = nodeGroup[j5];
          var key = "" + i5 + j5;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (var n3 = 0; n3 < prevNodeIds.length; n3++) {
            var prevNodeId = prevNodeIds[n3];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version3);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (n3 = 0; n3 < prevNodeIds.length; n3++) {
        graph[prevNodeIds[n3]]["end"] = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      var mode;
      var bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray2(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString3(data, version3) {
      var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      var nodes = buildNodes(segs);
      var graph = buildGraph(nodes, version3);
      var path = dijkstra.find_path(graph.map, "start", "end");
      var optimizedSegs = [];
      for (var i5 = 1; i5 < path.length - 1; i5++) {
        optimizedSegs.push(graph.table[path[i5]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var Utils = require_utils8();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version2();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    var isArray5 = require_isarray();
    function setupFinderPattern(matrix, version3) {
      var size = matrix.size;
      var pos = FinderPattern.getPositions(version3);
      for (var i5 = 0; i5 < pos.length; i5++) {
        var row = pos[i5][0];
        var col = pos[i5][1];
        for (var r6 = -1; r6 <= 7; r6++) {
          if (row + r6 <= -1 || size <= row + r6)
            continue;
          for (var c5 = -1; c5 <= 7; c5++) {
            if (col + c5 <= -1 || size <= col + c5)
              continue;
            if (r6 >= 0 && r6 <= 6 && (c5 === 0 || c5 === 6) || c5 >= 0 && c5 <= 6 && (r6 === 0 || r6 === 6) || r6 >= 2 && r6 <= 4 && c5 >= 2 && c5 <= 4) {
              matrix.set(row + r6, col + c5, true, true);
            } else {
              matrix.set(row + r6, col + c5, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      var size = matrix.size;
      for (var r6 = 8; r6 < size - 8; r6++) {
        var value = r6 % 2 === 0;
        matrix.set(r6, 6, value, true);
        matrix.set(6, r6, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version3) {
      var pos = AlignmentPattern.getPositions(version3);
      for (var i5 = 0; i5 < pos.length; i5++) {
        var row = pos[i5][0];
        var col = pos[i5][1];
        for (var r6 = -2; r6 <= 2; r6++) {
          for (var c5 = -2; c5 <= 2; c5++) {
            if (r6 === -2 || r6 === 2 || c5 === -2 || c5 === 2 || r6 === 0 && c5 === 0) {
              matrix.set(row + r6, col + c5, true, true);
            } else {
              matrix.set(row + r6, col + c5, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version3) {
      var size = matrix.size;
      var bits = Version.getEncodedBits(version3);
      var row, col, mod;
      for (var i5 = 0; i5 < 18; i5++) {
        row = Math.floor(i5 / 3);
        col = i5 % 3 + size - 8 - 3;
        mod = (bits >> i5 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      var size = matrix.size;
      var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      var i5, mod;
      for (i5 = 0; i5 < 15; i5++) {
        mod = (bits >> i5 & 1) === 1;
        if (i5 < 6) {
          matrix.set(i5, 8, mod, true);
        } else if (i5 < 8) {
          matrix.set(i5 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i5, 8, mod, true);
        }
        if (i5 < 8) {
          matrix.set(8, size - i5 - 1, mod, true);
        } else if (i5 < 9) {
          matrix.set(8, 15 - i5 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i5 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      var size = matrix.size;
      var inc = -1;
      var row = size - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (var c5 = 0; c5 < 2; c5++) {
            if (!matrix.isReserved(row, col - c5)) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c5, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version3, errorCorrectionLevel, segments) {
      var buffer2 = new BitBuffer();
      segments.forEach(function(data) {
        buffer2.put(data.mode.bit, 4);
        buffer2.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version3));
        data.write(buffer2);
      });
      var totalCodewords = Utils.getSymbolTotalCodewords(version3);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version3, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer2.put(0, 4);
      }
      while (buffer2.getLengthInBits() % 8 !== 0) {
        buffer2.putBit(0);
      }
      var remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
      for (var i5 = 0; i5 < remainingByte; i5++) {
        buffer2.put(i5 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer2, version3, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version3, errorCorrectionLevel) {
      var totalCodewords = Utils.getSymbolTotalCodewords(version3);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version3, errorCorrectionLevel);
      var dataTotalCodewords = totalCodewords - ecTotalCodewords;
      var ecTotalBlocks = ECCode.getBlocksCount(version3, errorCorrectionLevel);
      var blocksInGroup2 = totalCodewords % ecTotalBlocks;
      var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      var rs = new ReedSolomonEncoder(ecCount);
      var offset = 0;
      var dcData = new Array(ecTotalBlocks);
      var ecData = new Array(ecTotalBlocks);
      var maxDataSize = 0;
      var buffer2 = BufferUtil.from(bitBuffer.buffer);
      for (var b4 = 0; b4 < ecTotalBlocks; b4++) {
        var dataSize = b4 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b4] = buffer2.slice(offset, offset + dataSize);
        ecData[b4] = rs.encode(dcData[b4]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      var data = BufferUtil.alloc(totalCodewords);
      var index = 0;
      var i5, r6;
      for (i5 = 0; i5 < maxDataSize; i5++) {
        for (r6 = 0; r6 < ecTotalBlocks; r6++) {
          if (i5 < dcData[r6].length) {
            data[index++] = dcData[r6][i5];
          }
        }
      }
      for (i5 = 0; i5 < ecCount; i5++) {
        for (r6 = 0; r6 < ecTotalBlocks; r6++) {
          data[index++] = ecData[r6][i5];
        }
      }
      return data;
    }
    function createSymbol(data, version3, errorCorrectionLevel, maskPattern) {
      var segments;
      if (isArray5(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        var estimatedVersion = version3;
        if (!estimatedVersion) {
          var rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(
            rawSegments,
            errorCorrectionLevel
          );
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      var bestVersion = Version.getBestVersionForData(
        segments,
        errorCorrectionLevel
      );
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version3) {
        version3 = bestVersion;
      } else if (version3 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      var dataBits = createData(version3, errorCorrectionLevel, segments);
      var moduleCount = Utils.getSymbolSize(version3);
      var modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version3);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version3);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version3 >= 7) {
        setupVersionInfo(modules, version3);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version3,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      var errorCorrectionLevel = ECLevel.M;
      var version3;
      var mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version3 = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version3, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils9 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      var hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c5) {
          return [c5, c5];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      var hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      var width = options.width && options.width >= 21 ? options.width : void 0;
      var scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      var scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      var size = qr.modules.size;
      var data = qr.modules.data;
      var scale = exports.getScale(size, opts);
      var symbolSize = Math.floor((size + opts.margin * 2) * scale);
      var scaledMargin = opts.margin * scale;
      var palette = [opts.color.light, opts.color.dark];
      for (var i5 = 0; i5 < symbolSize; i5++) {
        for (var j5 = 0; j5 < symbolSize; j5++) {
          var posDst = (i5 * symbolSize + j5) * 4;
          var pxColor = opts.color.light;
          if (i5 >= scaledMargin && j5 >= scaledMargin && i5 < symbolSize - scaledMargin && j5 < symbolSize - scaledMargin) {
            var iSrc = Math.floor((i5 - scaledMargin) / scale);
            var jSrc = Math.floor((j5 - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Utils = require_utils9();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e5) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      var opts = options;
      var canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      var size = Utils.getImageWidth(qrData.modules.size, opts);
      var ctx = canvasEl.getContext("2d");
      var image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      var opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      var canvasEl = exports.render(qrData, canvas, opts);
      var type2 = opts.type || "image/png";
      var rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type2, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Utils = require_utils9();
    function getColorAttrib(color, attrib) {
      var alpha = color.a / 255;
      var str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x5, y5) {
      var str = cmd + x5;
      if (typeof y5 !== "undefined")
        str += " " + y5;
      return str;
    }
    function qrToPath(data, size, margin) {
      var path = "";
      var moveBy = 0;
      var newRow = false;
      var lineLength = 0;
      for (var i5 = 0; i5 < data.length; i5++) {
        var col = Math.floor(i5 % size);
        var row = Math.floor(i5 / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i5]) {
          lineLength++;
          if (!(i5 > 0 && col > 0 && data[i5 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i5 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      var opts = Utils.getOptions(options);
      var size = qrData.modules.size;
      var data = qrData.modules.data;
      var qrcodesize = size + opts.margin * 2;
      var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      var path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser14 = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      var args = [].slice.call(arguments, 1);
      var argsNum = args.length;
      var isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            var data2 = QRCode.create(text, opts);
            resolve(renderFunc(data2, canvas, opts));
          } catch (e5) {
            reject(e5);
          }
        });
      }
      try {
        var data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e5) {
        cb(e5);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _6, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i5 = 0; i5 < selection.rangeCount; i5++) {
        ranges.push(selection.getRangeAt(i5));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range2) {
            selection.addRange(range2);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format3(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy3(text, options) {
      var debug2, message, reselectPrevious, range2, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug2 = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range2 = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e5) {
          e5.stopPropagation();
          if (options.format) {
            e5.preventDefault();
            if (typeof e5.clipboardData === "undefined") {
              debug2 && console.warn("unable to use e.clipboardData");
              debug2 && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format4 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format4, text);
            } else {
              e5.clipboardData.clearData();
              e5.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e5.preventDefault();
            options.onCopy(e5.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range2.selectNodeContents(mark);
        selection.addRange(range2);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug2 && console.error("unable to copy using execCommand: ", err);
        debug2 && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug2 && console.error("unable to copy using clipboardData: ", err2);
          debug2 && console.error("falling back to prompt");
          message = format3("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range2);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy3;
  }
});

// node_modules/@walletconnect/qrcode-modal/node_modules/preact/dist/preact.module.js
function a3(n3, l5) {
  for (var u5 in l5)
    n3[u5] = l5[u5];
  return n3;
}
function v3(n3) {
  var l5 = n3.parentNode;
  l5 && l5.removeChild(n3);
}
function h3(n3, l5, u5) {
  var i5, t5 = arguments, r6 = {};
  for (i5 in l5)
    "key" !== i5 && "ref" !== i5 && (r6[i5] = l5[i5]);
  if (arguments.length > 3)
    for (u5 = [u5], i5 = 3; i5 < arguments.length; i5++)
      u5.push(t5[i5]);
  if (null != u5 && (r6.children = u5), "function" == typeof n3 && null != n3.defaultProps)
    for (i5 in n3.defaultProps)
      void 0 === r6[i5] && (r6[i5] = n3.defaultProps[i5]);
  return p3(n3, r6, l5 && l5.key, l5 && l5.ref, null);
}
function p3(l5, u5, i5, t5, r6) {
  var o5 = { type: l5, props: u5, key: i5, ref: t5, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r6 };
  return null == r6 && (o5.__v = o5), n2.vnode && n2.vnode(o5), o5;
}
function y3() {
  return {};
}
function d3(n3) {
  return n3.children;
}
function m3(n3, l5) {
  this.props = n3, this.context = l5;
}
function w3(n3, l5) {
  if (null == l5)
    return n3.__ ? w3(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
  for (var u5; l5 < n3.__k.length; l5++)
    if (null != (u5 = n3.__k[l5]) && null != u5.__e)
      return u5.__e;
  return "function" == typeof n3.type ? w3(n3) : null;
}
function k3(n3) {
  var l5, u5;
  if (null != (n3 = n3.__) && null != n3.__c) {
    for (n3.__e = n3.__c.base = null, l5 = 0; l5 < n3.__k.length; l5++)
      if (null != (u5 = n3.__k[l5]) && null != u5.__e) {
        n3.__e = n3.__c.base = u5.__e;
        break;
      }
    return k3(n3);
  }
}
function g3(l5) {
  (!l5.__d && (l5.__d = true) && u3.push(l5) && !i3++ || r4 !== n2.debounceRendering) && ((r4 = n2.debounceRendering) || t3)(_3);
}
function _3() {
  for (var n3; i3 = u3.length; )
    n3 = u3.sort(function(n4, l5) {
      return n4.__v.__b - l5.__v.__b;
    }), u3 = [], n3.some(function(n4) {
      var l5, u5, i5, t5, r6, o5, f5;
      n4.__d && (o5 = (r6 = (l5 = n4).__v).__e, (f5 = l5.__P) && (u5 = [], (i5 = a3({}, r6)).__v = i5, t5 = A3(f5, r6, i5, l5.__n, void 0 !== f5.ownerSVGElement, null, u5, null == o5 ? w3(r6) : o5), T3(u5, r6), t5 != o5 && k3(r6)));
    });
}
function b3(n3, l5, u5, i5, t5, r6, o5, f5, s5) {
  var a5, h5, p5, y5, d5, m5, k5, g5 = u5 && u5.__k || c3, _6 = g5.length;
  if (f5 == e3 && (f5 = null != r6 ? r6[0] : _6 ? w3(u5, 0) : null), a5 = 0, l5.__k = x3(l5.__k, function(u6) {
    if (null != u6) {
      if (u6.__ = l5, u6.__b = l5.__b + 1, null === (p5 = g5[a5]) || p5 && u6.key == p5.key && u6.type === p5.type)
        g5[a5] = void 0;
      else
        for (h5 = 0; h5 < _6; h5++) {
          if ((p5 = g5[h5]) && u6.key == p5.key && u6.type === p5.type) {
            g5[h5] = void 0;
            break;
          }
          p5 = null;
        }
      if (y5 = A3(n3, u6, p5 = p5 || e3, i5, t5, r6, o5, f5, s5), (h5 = u6.ref) && p5.ref != h5 && (k5 || (k5 = []), p5.ref && k5.push(p5.ref, null, u6), k5.push(h5, u6.__c || y5, u6)), null != y5) {
        var c5;
        if (null == m5 && (m5 = y5), void 0 !== u6.__d)
          c5 = u6.__d, u6.__d = void 0;
        else if (r6 == p5 || y5 != f5 || null == y5.parentNode) {
          n:
            if (null == f5 || f5.parentNode !== n3)
              n3.appendChild(y5), c5 = null;
            else {
              for (d5 = f5, h5 = 0; (d5 = d5.nextSibling) && h5 < _6; h5 += 2)
                if (d5 == y5)
                  break n;
              n3.insertBefore(y5, f5), c5 = f5;
            }
          "option" == l5.type && (n3.value = "");
        }
        f5 = void 0 !== c5 ? c5 : y5.nextSibling, "function" == typeof l5.type && (l5.__d = f5);
      } else
        f5 && p5.__e == f5 && f5.parentNode != n3 && (f5 = w3(p5));
    }
    return a5++, u6;
  }), l5.__e = m5, null != r6 && "function" != typeof l5.type)
    for (a5 = r6.length; a5--; )
      null != r6[a5] && v3(r6[a5]);
  for (a5 = _6; a5--; )
    null != g5[a5] && D(g5[a5], g5[a5]);
  if (k5)
    for (a5 = 0; a5 < k5.length; a5++)
      j3(k5[a5], k5[++a5], k5[++a5]);
}
function x3(n3, l5, u5) {
  if (null == u5 && (u5 = []), null == n3 || "boolean" == typeof n3)
    l5 && u5.push(l5(null));
  else if (Array.isArray(n3))
    for (var i5 = 0; i5 < n3.length; i5++)
      x3(n3[i5], l5, u5);
  else
    u5.push(l5 ? l5("string" == typeof n3 || "number" == typeof n3 ? p3(null, n3, null, null, n3) : null != n3.__e || null != n3.__c ? p3(n3.type, n3.props, n3.key, null, n3.__v) : n3) : n3);
  return u5;
}
function P3(n3, l5, u5, i5, t5) {
  var r6;
  for (r6 in u5)
    "children" === r6 || "key" === r6 || r6 in l5 || N2(n3, r6, null, u5[r6], i5);
  for (r6 in l5)
    t5 && "function" != typeof l5[r6] || "children" === r6 || "key" === r6 || "value" === r6 || "checked" === r6 || u5[r6] === l5[r6] || N2(n3, r6, l5[r6], u5[r6], i5);
}
function C2(n3, l5, u5) {
  "-" === l5[0] ? n3.setProperty(l5, u5) : n3[l5] = "number" == typeof u5 && false === s3.test(l5) ? u5 + "px" : null == u5 ? "" : u5;
}
function N2(n3, l5, u5, i5, t5) {
  var r6, o5, f5, e5, c5;
  if (t5 ? "className" === l5 && (l5 = "class") : "class" === l5 && (l5 = "className"), "style" === l5)
    if (r6 = n3.style, "string" == typeof u5)
      r6.cssText = u5;
    else {
      if ("string" == typeof i5 && (r6.cssText = "", i5 = null), i5)
        for (e5 in i5)
          u5 && e5 in u5 || C2(r6, e5, "");
      if (u5)
        for (c5 in u5)
          i5 && u5[c5] === i5[c5] || C2(r6, c5, u5[c5]);
    }
  else
    "o" === l5[0] && "n" === l5[1] ? (o5 = l5 !== (l5 = l5.replace(/Capture$/, "")), f5 = l5.toLowerCase(), l5 = (f5 in n3 ? f5 : l5).slice(2), u5 ? (i5 || n3.addEventListener(l5, z3, o5), (n3.l || (n3.l = {}))[l5] = u5) : n3.removeEventListener(l5, z3, o5)) : "list" !== l5 && "tagName" !== l5 && "form" !== l5 && "type" !== l5 && "size" !== l5 && !t5 && l5 in n3 ? n3[l5] = null == u5 ? "" : u5 : "function" != typeof u5 && "dangerouslySetInnerHTML" !== l5 && (l5 !== (l5 = l5.replace(/^xlink:?/, "")) ? null == u5 || false === u5 ? n3.removeAttributeNS("http://www.w3.org/1999/xlink", l5.toLowerCase()) : n3.setAttributeNS("http://www.w3.org/1999/xlink", l5.toLowerCase(), u5) : null == u5 || false === u5 && !/^ar/.test(l5) ? n3.removeAttribute(l5) : n3.setAttribute(l5, u5));
}
function z3(l5) {
  this.l[l5.type](n2.event ? n2.event(l5) : l5);
}
function A3(l5, u5, i5, t5, r6, o5, f5, e5, c5) {
  var s5, v5, h5, p5, y5, w6, k5, g5, _6, x5, P5 = u5.type;
  if (void 0 !== u5.constructor)
    return null;
  (s5 = n2.__b) && s5(u5);
  try {
    n:
      if ("function" == typeof P5) {
        if (g5 = u5.props, _6 = (s5 = P5.contextType) && t5[s5.__c], x5 = s5 ? _6 ? _6.props.value : s5.__ : t5, i5.__c ? k5 = (v5 = u5.__c = i5.__c).__ = v5.__E : ("prototype" in P5 && P5.prototype.render ? u5.__c = v5 = new P5(g5, x5) : (u5.__c = v5 = new m3(g5, x5), v5.constructor = P5, v5.render = E), _6 && _6.sub(v5), v5.props = g5, v5.state || (v5.state = {}), v5.context = x5, v5.__n = t5, h5 = v5.__d = true, v5.__h = []), null == v5.__s && (v5.__s = v5.state), null != P5.getDerivedStateFromProps && (v5.__s == v5.state && (v5.__s = a3({}, v5.__s)), a3(v5.__s, P5.getDerivedStateFromProps(g5, v5.__s))), p5 = v5.props, y5 = v5.state, h5)
          null == P5.getDerivedStateFromProps && null != v5.componentWillMount && v5.componentWillMount(), null != v5.componentDidMount && v5.__h.push(v5.componentDidMount);
        else {
          if (null == P5.getDerivedStateFromProps && g5 !== p5 && null != v5.componentWillReceiveProps && v5.componentWillReceiveProps(g5, x5), !v5.__e && null != v5.shouldComponentUpdate && false === v5.shouldComponentUpdate(g5, v5.__s, x5) || u5.__v === i5.__v && !v5.__) {
            for (v5.props = g5, v5.state = v5.__s, u5.__v !== i5.__v && (v5.__d = false), v5.__v = u5, u5.__e = i5.__e, u5.__k = i5.__k, v5.__h.length && f5.push(v5), s5 = 0; s5 < u5.__k.length; s5++)
              u5.__k[s5] && (u5.__k[s5].__ = u5);
            break n;
          }
          null != v5.componentWillUpdate && v5.componentWillUpdate(g5, v5.__s, x5), null != v5.componentDidUpdate && v5.__h.push(function() {
            v5.componentDidUpdate(p5, y5, w6);
          });
        }
        v5.context = x5, v5.props = g5, v5.state = v5.__s, (s5 = n2.__r) && s5(u5), v5.__d = false, v5.__v = u5, v5.__P = l5, s5 = v5.render(v5.props, v5.state, v5.context), u5.__k = null != s5 && s5.type == d3 && null == s5.key ? s5.props.children : Array.isArray(s5) ? s5 : [s5], null != v5.getChildContext && (t5 = a3(a3({}, t5), v5.getChildContext())), h5 || null == v5.getSnapshotBeforeUpdate || (w6 = v5.getSnapshotBeforeUpdate(p5, y5)), b3(l5, u5, i5, t5, r6, o5, f5, e5, c5), v5.base = u5.__e, v5.__h.length && f5.push(v5), k5 && (v5.__E = v5.__ = null), v5.__e = false;
      } else
        null == o5 && u5.__v === i5.__v ? (u5.__k = i5.__k, u5.__e = i5.__e) : u5.__e = $2(i5.__e, u5, i5, t5, r6, o5, f5, c5);
    (s5 = n2.diffed) && s5(u5);
  } catch (l6) {
    u5.__v = null, n2.__e(l6, u5, i5);
  }
  return u5.__e;
}
function T3(l5, u5) {
  n2.__c && n2.__c(u5, l5), l5.some(function(u6) {
    try {
      l5 = u6.__h, u6.__h = [], l5.some(function(n3) {
        n3.call(u6);
      });
    } catch (l6) {
      n2.__e(l6, u6.__v);
    }
  });
}
function $2(n3, l5, u5, i5, t5, r6, o5, f5) {
  var s5, a5, v5, h5, p5, y5 = u5.props, d5 = l5.props;
  if (t5 = "svg" === l5.type || t5, null != r6) {
    for (s5 = 0; s5 < r6.length; s5++)
      if (null != (a5 = r6[s5]) && ((null === l5.type ? 3 === a5.nodeType : a5.localName === l5.type) || n3 == a5)) {
        n3 = a5, r6[s5] = null;
        break;
      }
  }
  if (null == n3) {
    if (null === l5.type)
      return document.createTextNode(d5);
    n3 = t5 ? document.createElementNS("http://www.w3.org/2000/svg", l5.type) : document.createElement(l5.type, d5.is && { is: d5.is }), r6 = null, f5 = false;
  }
  if (null === l5.type)
    y5 !== d5 && n3.data != d5 && (n3.data = d5);
  else {
    if (null != r6 && (r6 = c3.slice.call(n3.childNodes)), v5 = (y5 = u5.props || e3).dangerouslySetInnerHTML, h5 = d5.dangerouslySetInnerHTML, !f5) {
      if (y5 === e3)
        for (y5 = {}, p5 = 0; p5 < n3.attributes.length; p5++)
          y5[n3.attributes[p5].name] = n3.attributes[p5].value;
      (h5 || v5) && (h5 && v5 && h5.__html == v5.__html || (n3.innerHTML = h5 && h5.__html || ""));
    }
    P3(n3, d5, y5, t5, f5), h5 ? l5.__k = [] : (l5.__k = l5.props.children, b3(n3, l5, u5, i5, "foreignObject" !== l5.type && t5, r6, o5, e3, f5)), f5 || ("value" in d5 && void 0 !== (s5 = d5.value) && s5 !== n3.value && N2(n3, "value", s5, y5.value, false), "checked" in d5 && void 0 !== (s5 = d5.checked) && s5 !== n3.checked && N2(n3, "checked", s5, y5.checked, false));
  }
  return n3;
}
function j3(l5, u5, i5) {
  try {
    "function" == typeof l5 ? l5(u5) : l5.current = u5;
  } catch (l6) {
    n2.__e(l6, i5);
  }
}
function D(l5, u5, i5) {
  var t5, r6, o5;
  if (n2.unmount && n2.unmount(l5), (t5 = l5.ref) && (t5.current && t5.current !== l5.__e || j3(t5, null, u5)), i5 || "function" == typeof l5.type || (i5 = null != (r6 = l5.__e)), l5.__e = l5.__d = void 0, null != (t5 = l5.__c)) {
    if (t5.componentWillUnmount)
      try {
        t5.componentWillUnmount();
      } catch (l6) {
        n2.__e(l6, u5);
      }
    t5.base = t5.__P = null;
  }
  if (t5 = l5.__k)
    for (o5 = 0; o5 < t5.length; o5++)
      t5[o5] && D(t5[o5], u5, i5);
  null != r6 && v3(r6);
}
function E(n3, l5, u5) {
  return this.constructor(n3, u5);
}
function H2(l5, u5, i5) {
  var t5, r6, f5;
  n2.__ && n2.__(l5, u5), r6 = (t5 = i5 === o3) ? null : i5 && i5.__k || u5.__k, l5 = h3(d3, null, [l5]), f5 = [], A3(u5, (t5 ? u5 : i5 || u5).__k = l5, r6 || e3, e3, void 0 !== u5.ownerSVGElement, i5 && !t5 ? [i5] : r6 ? null : c3.slice.call(u5.childNodes), f5, i5 || e3, t5), T3(f5, l5);
}
function I2(n3, l5) {
  H2(n3, l5, o3);
}
function L2(n3, l5) {
  var u5, i5;
  for (i5 in l5 = a3(a3({}, n3.props), l5), arguments.length > 2 && (l5.children = c3.slice.call(arguments, 2)), u5 = {}, l5)
    "key" !== i5 && "ref" !== i5 && (u5[i5] = l5[i5]);
  return p3(n3.type, u5, l5.key || n3.key, l5.ref || n3.ref, null);
}
function M2(n3) {
  var l5 = {}, u5 = { __c: "__cC" + f3++, __: n3, Consumer: function(n4, l6) {
    return n4.children(l6);
  }, Provider: function(n4) {
    var i5, t5 = this;
    return this.getChildContext || (i5 = [], this.getChildContext = function() {
      return l5[u5.__c] = t5, l5;
    }, this.shouldComponentUpdate = function(n5) {
      t5.props.value !== n5.value && i5.some(function(l6) {
        l6.context = n5.value, g3(l6);
      });
    }, this.sub = function(n5) {
      i5.push(n5);
      var l6 = n5.componentWillUnmount;
      n5.componentWillUnmount = function() {
        i5.splice(i5.indexOf(n5), 1), l6 && l6.call(n5);
      };
    }), n4.children;
  } };
  return u5.Consumer.contextType = u5, u5.Provider.__ = u5, u5;
}
var n2, l3, u3, i3, t3, r4, o3, f3, e3, c3, s3;
var init_preact_module2 = __esm({
  "node_modules/@walletconnect/qrcode-modal/node_modules/preact/dist/preact.module.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    e3 = {};
    c3 = [];
    s3 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    n2 = { __e: function(n3, l5) {
      for (var u5, i5; l5 = l5.__; )
        if ((u5 = l5.__c) && !u5.__)
          try {
            if (u5.constructor && null != u5.constructor.getDerivedStateFromError && (i5 = true, u5.setState(u5.constructor.getDerivedStateFromError(n3))), null != u5.componentDidCatch && (i5 = true, u5.componentDidCatch(n3)), i5)
              return g3(u5.__E = u5);
          } catch (l6) {
            n3 = l6;
          }
      throw n3;
    } }, l3 = function(n3) {
      return null != n3 && void 0 === n3.constructor;
    }, m3.prototype.setState = function(n3, l5) {
      var u5;
      u5 = this.__s !== this.state ? this.__s : this.__s = a3({}, this.state), "function" == typeof n3 && (n3 = n3(u5, this.props)), n3 && a3(u5, n3), null != n3 && this.__v && (l5 && this.__h.push(l5), g3(this));
    }, m3.prototype.forceUpdate = function(n3) {
      this.__v && (this.__e = true, n3 && this.__h.push(n3), g3(this));
    }, m3.prototype.render = d3, u3 = [], i3 = 0, t3 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o3 = e3, f3 = 0;
  }
});

// node_modules/@walletconnect/qrcode-modal/node_modules/preact/hooks/dist/hooks.module.js
function v4(t5, r6) {
  n2.__h && n2.__h(u4, t5, i4 || r6), i4 = 0;
  var o5 = u4.__H || (u4.__H = { __: [], __h: [] });
  return t5 >= o5.__.length && o5.__.push({}), o5.__[t5];
}
function m4(n3) {
  return i4 = 1, p4(E2, n3);
}
function p4(n3, r6, i5) {
  var o5 = v4(t4++, 2);
  return o5.__c || (o5.__c = u4, o5.__ = [i5 ? i5(r6) : E2(void 0, r6), function(t5) {
    var u5 = n3(o5.__[0], t5);
    o5.__[0] !== u5 && (o5.__[0] = u5, o5.__c.setState({}));
  }]), o5.__;
}
function l4(r6, i5) {
  var o5 = v4(t4++, 3);
  !n2.__s && x4(o5.__H, i5) && (o5.__ = r6, o5.__H = i5, u4.__H.__h.push(o5));
}
function y4(r6, i5) {
  var o5 = v4(t4++, 4);
  !n2.__s && x4(o5.__H, i5) && (o5.__ = r6, o5.__H = i5, u4.__h.push(o5));
}
function d4(n3) {
  return i4 = 5, h4(function() {
    return { current: n3 };
  }, []);
}
function s4(n3, t5, u5) {
  i4 = 6, y4(function() {
    "function" == typeof n3 ? n3(t5()) : n3 && (n3.current = t5());
  }, null == u5 ? u5 : u5.concat(n3));
}
function h4(n3, u5) {
  var r6 = v4(t4++, 7);
  return x4(r6.__H, u5) ? (r6.__H = u5, r6.__h = n3, r6.__ = n3()) : r6.__;
}
function T4(n3, t5) {
  return i4 = 8, h4(function() {
    return n3;
  }, t5);
}
function w4(n3) {
  var r6 = u4.context[n3.__c], i5 = v4(t4++, 9);
  return i5.__c = n3, r6 ? (null == i5.__ && (i5.__ = true, r6.sub(u4)), r6.props.value) : n3.__;
}
function A4(t5, u5) {
  n2.useDebugValue && n2.useDebugValue(u5 ? u5(t5) : t5);
}
function F2(n3) {
  var r6 = v4(t4++, 10), i5 = m4();
  return r6.__ = n3, u4.componentDidCatch || (u4.componentDidCatch = function(n4) {
    r6.__ && r6.__(n4), i5[1](n4);
  }), [i5[0], function() {
    i5[1](void 0);
  }];
}
function _4() {
  o4.some(function(t5) {
    if (t5.__P)
      try {
        t5.__H.__h.forEach(g4), t5.__H.__h.forEach(q3), t5.__H.__h = [];
      } catch (u5) {
        return t5.__H.__h = [], n2.__e(u5, t5.__v), true;
      }
  }), o4 = [];
}
function g4(n3) {
  n3.t && n3.t();
}
function q3(n3) {
  var t5 = n3.__();
  "function" == typeof t5 && (n3.t = t5);
}
function x4(n3, t5) {
  return !n3 || t5.some(function(t6, u5) {
    return t6 !== n3[u5];
  });
}
function E2(n3, t5) {
  return "function" == typeof t5 ? t5(n3) : t5;
}
var t4, u4, r5, i4, o4, c4, f4, e4, a4;
var init_hooks_module2 = __esm({
  "node_modules/@walletconnect/qrcode-modal/node_modules/preact/hooks/dist/hooks.module.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_preact_module2();
    i4 = 0;
    o4 = [];
    c4 = n2.__r;
    f4 = n2.diffed;
    e4 = n2.__c;
    a4 = n2.unmount;
    n2.__r = function(n3) {
      c4 && c4(n3), t4 = 0, (u4 = n3.__c).__H && (u4.__H.__h.forEach(g4), u4.__H.__h.forEach(q3), u4.__H.__h = []);
    }, n2.diffed = function(t5) {
      f4 && f4(t5);
      var u5 = t5.__c;
      if (u5) {
        var i5 = u5.__H;
        i5 && i5.__h.length && (1 !== o4.push(u5) && r5 === n2.requestAnimationFrame || ((r5 = n2.requestAnimationFrame) || function(n3) {
          var t6, u6 = function() {
            clearTimeout(r6), cancelAnimationFrame(t6), setTimeout(n3);
          }, r6 = setTimeout(u6, 100);
          "undefined" != typeof window && (t6 = requestAnimationFrame(u6));
        })(_4));
      }
    }, n2.__c = function(t5, u5) {
      u5.some(function(t6) {
        try {
          t6.__h.forEach(g4), t6.__h = t6.__h.filter(function(n3) {
            return !n3.__ || q3(n3);
          });
        } catch (r6) {
          u5.some(function(n3) {
            n3.__h && (n3.__h = []);
          }), u5 = [], n2.__e(r6, t6.__v);
        }
      }), e4 && e4(t5, u5);
    }, n2.unmount = function(t5) {
      a4 && a4(t5);
      var u5 = t5.__c;
      if (u5) {
        var r6 = u5.__H;
        if (r6)
          try {
            r6.__.forEach(function(n3) {
              return n3.t && n3.t();
            });
          } catch (t6) {
            n2.__e(t6, u5.__v);
          }
      }
    };
  }
});

// node_modules/@walletconnect/qrcode-modal/node_modules/preact/compat/dist/compat.module.js
var compat_module_exports = {};
__export(compat_module_exports, {
  Children: () => R,
  Component: () => m3,
  Fragment: () => d3,
  PureComponent: () => C3,
  Suspense: () => U,
  SuspenseList: () => O2,
  cloneElement: () => K,
  createContext: () => M2,
  createElement: () => h3,
  createFactory: () => G,
  createPortal: () => z4,
  createRef: () => y3,
  default: () => compat_module_default,
  findDOMNode: () => X,
  forwardRef: () => S2,
  hydrate: () => V2,
  isValidElement: () => J,
  lazy: () => L3,
  memo: () => _5,
  render: () => T5,
  unmountComponentAtNode: () => Q,
  unstable_batchedUpdates: () => Y,
  useCallback: () => T4,
  useContext: () => w4,
  useDebugValue: () => A4,
  useEffect: () => l4,
  useErrorBoundary: () => F2,
  useImperativeHandle: () => s4,
  useLayoutEffect: () => y4,
  useMemo: () => h4,
  useReducer: () => p4,
  useRef: () => d4,
  useState: () => m4,
  version: () => B3
});
function E3(n3, t5) {
  for (var e5 in t5)
    n3[e5] = t5[e5];
  return n3;
}
function w5(n3, t5) {
  for (var e5 in n3)
    if ("__source" !== e5 && !(e5 in t5))
      return true;
  for (var r6 in t5)
    if ("__source" !== r6 && n3[r6] !== t5[r6])
      return true;
  return false;
}
function _5(n3, t5) {
  function e5(n4) {
    var e6 = this.props.ref, r7 = e6 == n4.ref;
    return !r7 && e6 && (e6.call ? e6(null) : e6.current = null), t5 ? !t5(this.props, n4) || !r7 : w5(this.props, n4);
  }
  function r6(t6) {
    return this.shouldComponentUpdate = e5, h3(n3, E3({}, t6));
  }
  return r6.prototype.isReactComponent = true, r6.displayName = "Memo(" + (n3.displayName || n3.name) + ")", r6.t = true, r6;
}
function S2(n3) {
  function t5(t6) {
    var e5 = E3({}, t6);
    return delete e5.ref, n3(e5, t6.ref);
  }
  return t5.prototype.isReactComponent = t5.t = true, t5.displayName = "ForwardRef(" + (n3.displayName || n3.name) + ")", t5;
}
function N3(n3) {
  return n3 && ((n3 = E3({}, n3)).__c = null, n3.__k = n3.__k && n3.__k.map(N3)), n3;
}
function U() {
  this.__u = 0, this.o = null, this.__b = null;
}
function M3(n3) {
  var t5 = n3.__.__c;
  return t5 && t5.u && t5.u(n3);
}
function L3(n3) {
  var t5, e5, r6;
  function o5(o6) {
    if (t5 || (t5 = n3()).then(function(n4) {
      e5 = n4.default || n4;
    }, function(n4) {
      r6 = n4;
    }), r6)
      throw r6;
    if (!e5)
      throw t5;
    return h3(e5, o6);
  }
  return o5.displayName = "Lazy", o5.t = true, o5;
}
function O2() {
  this.i = null, this.l = null;
}
function j4(n3) {
  var t5 = this, e5 = n3.container, r6 = h3(W, { context: t5.context }, n3.vnode);
  return t5.s && t5.s !== e5 && (t5.v.parentNode && t5.s.removeChild(t5.v), D(t5.h), t5.p = false), n3.vnode ? t5.p ? (e5.__k = t5.__k, H2(r6, e5), t5.__k = e5.__k) : (t5.v = document.createTextNode(""), I2("", e5), e5.appendChild(t5.v), t5.p = true, t5.s = e5, H2(r6, e5, t5.v), t5.__k = t5.v.__k) : t5.p && (t5.v.parentNode && t5.s.removeChild(t5.v), D(t5.h)), t5.h = r6, t5.componentWillUnmount = function() {
    t5.v.parentNode && t5.s.removeChild(t5.v), D(t5.h);
  }, null;
}
function z4(n3, t5) {
  return h3(j4, { vnode: n3, container: t5 });
}
function T5(n3, t5, e5) {
  if (null == t5.__k)
    for (; t5.firstChild; )
      t5.removeChild(t5.firstChild);
  return H2(n3, t5), "function" == typeof e5 && e5(), n3 ? n3.__c : null;
}
function V2(n3, t5, e5) {
  return I2(n3, t5), "function" == typeof e5 && e5(), n3 ? n3.__c : null;
}
function I3(n3, t5) {
  n3["UNSAFE_" + t5] && !n3[t5] && Object.defineProperty(n3, t5, { configurable: false, get: function() {
    return this["UNSAFE_" + t5];
  }, set: function(n4) {
    this["UNSAFE_" + t5] = n4;
  } });
}
function G(n3) {
  return h3.bind(null, n3);
}
function J(n3) {
  return !!n3 && n3.$$typeof === H3;
}
function K(n3) {
  return J(n3) ? L2.apply(null, arguments) : n3;
}
function Q(n3) {
  return !!n3.__k && (H2(null, n3), true);
}
function X(n3) {
  return n3 && (n3.base || 1 === n3.nodeType && n3) || null;
}
var C3, A5, k4, R, F3, P4, W, D2, H3, Z, $3, q4, B3, Y, compat_module_default;
var init_compat_module = __esm({
  "node_modules/@walletconnect/qrcode-modal/node_modules/preact/compat/dist/compat.module.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_hooks_module2();
    init_hooks_module2();
    init_preact_module2();
    init_preact_module2();
    C3 = function(n3) {
      var t5, e5;
      function r6(t6) {
        var e6;
        return (e6 = n3.call(this, t6) || this).isPureReactComponent = true, e6;
      }
      return e5 = n3, (t5 = r6).prototype = Object.create(e5.prototype), t5.prototype.constructor = t5, t5.__proto__ = e5, r6.prototype.shouldComponentUpdate = function(n4, t6) {
        return w5(this.props, n4) || w5(this.state, t6);
      }, r6;
    }(m3);
    A5 = n2.__b;
    n2.__b = function(n3) {
      n3.type && n3.type.t && n3.ref && (n3.props.ref = n3.ref, n3.ref = null), A5 && A5(n3);
    };
    k4 = function(n3, t5) {
      return n3 ? x3(n3).reduce(function(n4, e5, r6) {
        return n4.concat(t5(e5, r6));
      }, []) : null;
    };
    R = { map: k4, forEach: k4, count: function(n3) {
      return n3 ? x3(n3).length : 0;
    }, only: function(n3) {
      if (1 !== (n3 = x3(n3)).length)
        throw new Error("Children.only() expects only one child.");
      return n3[0];
    }, toArray: x3 };
    F3 = n2.__e;
    n2.__e = function(n3, t5, e5) {
      if (n3.then) {
        for (var r6, o5 = t5; o5 = o5.__; )
          if ((r6 = o5.__c) && r6.__c)
            return r6.__c(n3, t5.__c);
      }
      F3(n3, t5, e5);
    }, (U.prototype = new m3()).__c = function(n3, t5) {
      var e5 = this;
      null == e5.o && (e5.o = []), e5.o.push(t5);
      var r6 = M3(e5.__v), o5 = false, u5 = function() {
        o5 || (o5 = true, r6 ? r6(i5) : i5());
      };
      t5.__c = t5.componentWillUnmount, t5.componentWillUnmount = function() {
        u5(), t5.__c && t5.__c();
      };
      var i5 = function() {
        var n4;
        if (!--e5.__u)
          for (e5.__v.__k[0] = e5.state.u, e5.setState({ u: e5.__b = null }); n4 = e5.o.pop(); )
            n4.forceUpdate();
      };
      e5.__u++ || e5.setState({ u: e5.__b = e5.__v.__k[0] }), n3.then(u5, u5);
    }, U.prototype.render = function(n3, t5) {
      return this.__b && (this.__v.__k[0] = N3(this.__b), this.__b = null), [h3(m3, null, t5.u ? null : n3.children), t5.u && n3.fallback];
    };
    P4 = function(n3, t5, e5) {
      if (++e5[1] === e5[0] && n3.l.delete(t5), n3.props.revealOrder && ("t" !== n3.props.revealOrder[0] || !n3.l.size))
        for (e5 = n3.i; e5; ) {
          for (; e5.length > 3; )
            e5.pop()();
          if (e5[1] < e5[0])
            break;
          n3.i = e5 = e5[2];
        }
    };
    (O2.prototype = new m3()).u = function(n3) {
      var t5 = this, e5 = M3(t5.__v), r6 = t5.l.get(n3);
      return r6[0]++, function(o5) {
        var u5 = function() {
          t5.props.revealOrder ? (r6.push(o5), P4(t5, n3, r6)) : o5();
        };
        e5 ? e5(u5) : u5();
      };
    }, O2.prototype.render = function(n3) {
      this.i = null, this.l = /* @__PURE__ */ new Map();
      var t5 = x3(n3.children);
      n3.revealOrder && "b" === n3.revealOrder[0] && t5.reverse();
      for (var e5 = t5.length; e5--; )
        this.l.set(t5[e5], this.i = [1, 0, this.i]);
      return n3.children;
    }, O2.prototype.componentDidUpdate = O2.prototype.componentDidMount = function() {
      var n3 = this;
      n3.l.forEach(function(t5, e5) {
        P4(n3, e5, t5);
      });
    };
    W = function() {
      function n3() {
      }
      var t5 = n3.prototype;
      return t5.getChildContext = function() {
        return this.props.context;
      }, t5.render = function(n4) {
        return n4.children;
      }, n3;
    }();
    D2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    m3.prototype.isReactComponent = {};
    H3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
    Z = n2.event;
    n2.event = function(n3) {
      Z && (n3 = Z(n3)), n3.persist = function() {
      };
      var t5 = false, e5 = false, r6 = n3.stopPropagation;
      n3.stopPropagation = function() {
        r6.call(n3), t5 = true;
      };
      var o5 = n3.preventDefault;
      return n3.preventDefault = function() {
        o5.call(n3), e5 = true;
      }, n3.isPropagationStopped = function() {
        return t5;
      }, n3.isDefaultPrevented = function() {
        return e5;
      }, n3.nativeEvent = n3;
    };
    $3 = { configurable: true, get: function() {
      return this.class;
    } };
    q4 = n2.vnode;
    n2.vnode = function(n3) {
      n3.$$typeof = H3;
      var t5 = n3.type, e5 = n3.props;
      if (t5) {
        if (e5.class != e5.className && ($3.enumerable = "className" in e5, null != e5.className && (e5.class = e5.className), Object.defineProperty(e5, "className", $3)), "function" != typeof t5) {
          var r6, o5, u5;
          for (u5 in e5.defaultValue && void 0 !== e5.value && (e5.value || 0 === e5.value || (e5.value = e5.defaultValue), delete e5.defaultValue), Array.isArray(e5.value) && e5.multiple && "select" === t5 && (x3(e5.children).forEach(function(n4) {
            -1 != e5.value.indexOf(n4.props.value) && (n4.props.selected = true);
          }), delete e5.value), e5)
            if (r6 = D2.test(u5))
              break;
          if (r6)
            for (u5 in o5 = n3.props = {}, e5)
              o5[D2.test(u5) ? u5.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u5] = e5[u5];
        }
        !function(t6) {
          var e6 = n3.type, r7 = n3.props;
          if (r7 && "string" == typeof e6) {
            var o6 = {};
            for (var u6 in r7)
              /^on(Ani|Tra|Tou)/.test(u6) && (r7[u6.toLowerCase()] = r7[u6], delete r7[u6]), o6[u6.toLowerCase()] = u6;
            if (o6.ondoubleclick && (r7.ondblclick = r7[o6.ondoubleclick], delete r7[o6.ondoubleclick]), o6.onbeforeinput && (r7.onbeforeinput = r7[o6.onbeforeinput], delete r7[o6.onbeforeinput]), o6.onchange && ("textarea" === e6 || "input" === e6.toLowerCase() && !/^fil|che|ra/i.test(r7.type))) {
              var i5 = o6.oninput || "oninput";
              r7[i5] || (r7[i5] = r7[o6.onchange], delete r7[o6.onchange]);
            }
          }
        }(), "function" == typeof t5 && !t5.m && t5.prototype && (I3(t5.prototype, "componentWillMount"), I3(t5.prototype, "componentWillReceiveProps"), I3(t5.prototype, "componentWillUpdate"), t5.m = true);
      }
      q4 && q4(n3);
    };
    B3 = "16.8.0";
    Y = function(n3, t5) {
      return n3(t5);
    };
    compat_module_default = { useState: m4, useReducer: p4, useEffect: l4, useLayoutEffect: y4, useRef: d4, useImperativeHandle: s4, useMemo: h4, useCallback: T4, useContext: w4, useDebugValue: A4, version: "16.8.0", Children: R, render: T5, hydrate: T5, unmountComponentAtNode: Q, createPortal: z4, createElement: h3, createContext: M2, createFactory: G, cloneElement: K, createRef: y3, Fragment: d3, isValidElement: J, findDOMNode: X, Component: m3, PureComponent: C3, memo: _5, forwardRef: S2, unstable_batchedUpdates: Y, Suspense: U, SuspenseList: O2, lazy: L3 };
  }
});

// node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var browserUtils = (init_esm2(), __toCommonJS(esm_exports2));
    var QRCode = _interopDefault(require_browser14());
    var copy3 = _interopDefault(require_copy_to_clipboard());
    var React = (init_compat_module(), __toCommonJS(compat_module_exports));
    function open(uri) {
      QRCode.toString(uri, {
        type: "terminal"
      }).then(console.log);
    }
    var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
    var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
    var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
    function _catch(body, recover) {
      try {
        var result = body();
      } catch (e5) {
        return recover(e5);
      }
      if (result && result.then) {
        return result.then(void 0, recover);
      }
      return result;
    }
    var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E";
    var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
    var ANIMATION_DURATION = 300;
    var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
    var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
    var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
    var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
    var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
    var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
    var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
    function Header(props) {
      return React.createElement("div", {
        className: "walletconnect-modal__header"
      }, React.createElement("img", {
        src: WALLETCONNECT_LOGO_SVG_URL,
        className: "walletconnect-modal__headerLogo"
      }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
        className: "walletconnect-modal__close__wrapper",
        onClick: props.onClose
      }, React.createElement("div", {
        id: WALLETCONNECT_CLOSE_BUTTON_ID,
        className: "walletconnect-modal__close__icon"
      }, React.createElement("div", {
        className: "walletconnect-modal__close__line1"
      }), React.createElement("div", {
        className: "walletconnect-modal__close__line2"
      }))));
    }
    function ConnectButton(props) {
      return React.createElement("a", {
        className: "walletconnect-connect__button",
        href: props.href,
        id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
        onClick: props.onClick,
        rel: "noopener noreferrer",
        style: {
          backgroundColor: props.color
        },
        target: "_blank"
      }, props.name);
    }
    var CARET_SVG_URL = "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";
    function WalletButton(props) {
      var color = props.color;
      var href = props.href;
      var name = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      return React.createElement("a", {
        className: "walletconnect-modal__base__row",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("h3", {
        className: "walletconnect-modal__base__row__h3"
      }, name), React.createElement("div", {
        className: "walletconnect-modal__base__row__right"
      }, React.createElement("div", {
        className: "walletconnect-modal__base__row__right__app-icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("img", {
        src: CARET_SVG_URL,
        className: "walletconnect-modal__base__row__right__caret"
      })));
    }
    function WalletIcon(props) {
      var color = props.color;
      var href = props.href;
      var name = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      var fontSize = window.innerWidth < 768 ? (name.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
      return React.createElement("a", {
        className: "walletconnect-connect__button__icon_anchor",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("div", {
        className: "walletconnect-connect__button__icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("div", {
        style: {
          fontSize
        },
        className: "walletconnect-connect__button__text"
      }, name));
    }
    var GRID_MIN_COUNT = 5;
    var LINKS_PER_PAGE = 12;
    function LinkDisplay(props) {
      var android = browserUtils.isAndroid();
      var ref = React.useState("");
      var input = ref[0];
      var setInput = ref[1];
      var ref$1 = React.useState("");
      var filter2 = ref$1[0];
      var setFilter = ref$1[1];
      var ref$2 = React.useState(1);
      var page = ref$2[0];
      var setPage = ref$2[1];
      var links = filter2 ? props.links.filter(function(link) {
        return link.name.toLowerCase().includes(filter2.toLowerCase());
      }) : props.links;
      var errorMessage = props.errorMessage;
      var grid = filter2 || links.length > GRID_MIN_COUNT;
      var pages = Math.ceil(links.length / LINKS_PER_PAGE);
      var range2 = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
      var pageLinks = links.length ? links.filter(function(_6, index2) {
        return index2 + 1 >= range2[0] && index2 + 1 <= range2[1];
      }) : [];
      var hasPaging = !!(!android && pages > 1);
      var filterTimeout = void 0;
      function handleInput(e5) {
        setInput(e5.target.value);
        clearTimeout(filterTimeout);
        if (e5.target.value) {
          filterTimeout = setTimeout(function() {
            setFilter(e5.target.value);
            setPage(1);
          }, 1e3);
        } else {
          setInput("");
          setFilter("");
          setPage(1);
        }
      }
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
        className: "walletconnect-search__input",
        placeholder: "Search",
        value: input,
        onChange: handleInput
      }), React.createElement("div", {
        className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
      }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
        var color = entry.color;
        var name = entry.name;
        var shortName = entry.shortName;
        var logo = entry.logo;
        var href = browserUtils.formatIOSMobile(props.uri, entry);
        var handleClickIOS = React.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name,
            href
          });
        }, [pageLinks]);
        return !grid ? React.createElement(WalletButton, {
          color,
          href,
          name,
          logo,
          onClick: handleClickIOS
        }) : React.createElement(WalletIcon, {
          color,
          href,
          name: shortName || name,
          logo,
          onClick: handleClickIOS
        });
      }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton, {
        name: props.text.connect,
        color: DEFAULT_BUTTON_COLOR,
        href: props.uri,
        onClick: React.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name: "Unknown",
            href: props.uri
          });
        }, [])
      })), hasPaging && React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, Array(pages).fill(0).map(function(_6, index2) {
        var pageNumber = index2 + 1;
        var selected = page === pageNumber;
        return React.createElement("a", {
          style: {
            margin: "auto 10px",
            fontWeight: selected ? "bold" : "normal"
          },
          onClick: function() {
            return setPage(pageNumber);
          }
        }, pageNumber);
      })));
    }
    function Notification2(props) {
      var show = !!props.message.trim();
      return React.createElement("div", {
        className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
      }, props.message);
    }
    var formatQRCodeImage = function(data) {
      try {
        var result = "";
        return Promise.resolve(QRCode.toString(data, {
          margin: 0,
          type: "svg"
        })).then(function(dataString) {
          if (typeof dataString === "string") {
            result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
          }
          return result;
        });
      } catch (e5) {
        return Promise.reject(e5);
      }
    };
    function QRCodeDisplay(props) {
      var ref = React.useState("");
      var notification = ref[0];
      var setNotification = ref[1];
      var ref$1 = React.useState("");
      var svg = ref$1[0];
      var setSvg = ref$1[1];
      React.useEffect(function() {
        try {
          return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
            setSvg(_formatQRCodeImage);
          });
        } catch (e5) {
          Promise.reject(e5);
        }
      }, []);
      var copyToClipboard = function() {
        var success = copy3(props.uri);
        if (success) {
          setNotification(props.text.copied_to_clipboard);
          setInterval(function() {
            return setNotification("");
          }, 1200);
        } else {
          setNotification("Error");
          setInterval(function() {
            return setNotification("");
          }, 1200);
        }
      };
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
        dangerouslySetInnerHTML: {
          __html: svg
        }
      }), React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, React.createElement("a", {
        onClick: copyToClipboard
      }, props.text.copy_to_clipboard)), React.createElement(Notification2, {
        message: notification
      }));
    }
    function Modal(props) {
      var android = browserUtils.isAndroid();
      var mobile = browserUtils.isMobile();
      var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
      var ref = React.useState(false);
      var loading = ref[0];
      var setLoading = ref[1];
      var ref$1 = React.useState(false);
      var fetched = ref$1[0];
      var setFetched = ref$1[1];
      var ref$2 = React.useState(!mobile);
      var displayQRCode = ref$2[0];
      var setDisplayQRCode = ref$2[1];
      var displayProps = {
        mobile,
        text: props.text,
        uri: props.uri,
        qrcodeModalOptions: props.qrcodeModalOptions
      };
      var ref$3 = React.useState("");
      var singleLinkHref = ref$3[0];
      var setSingleLinkHref = ref$3[1];
      var ref$4 = React.useState(false);
      var hasSingleLink = ref$4[0];
      var setHasSingleLink = ref$4[1];
      var ref$5 = React.useState([]);
      var links = ref$5[0];
      var setLinks = ref$5[1];
      var ref$6 = React.useState("");
      var errorMessage = ref$6[0];
      var setErrorMessage = ref$6[1];
      var getLinksIfNeeded = function() {
        if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
          return;
        }
        React.useEffect(function() {
          var initLinks = function() {
            try {
              if (android) {
                return Promise.resolve();
              }
              setLoading(true);
              var _temp = _catch(function() {
                var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : browserUtils.getWalletRegistryUrl();
                return Promise.resolve(fetch(url)).then(function(registryResponse) {
                  return Promise.resolve(registryResponse.json()).then(function(_registryResponse$jso) {
                    var registry = _registryResponse$jso.listings;
                    var platform4 = mobile ? "mobile" : "desktop";
                    var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform4), whitelist);
                    setLoading(false);
                    setFetched(true);
                    setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                    setLinks(_links);
                    var hasSingleLink2 = _links.length === 1;
                    if (hasSingleLink2) {
                      setSingleLinkHref(browserUtils.formatIOSMobile(props.uri, _links[0]));
                      setDisplayQRCode(true);
                    }
                    setHasSingleLink(hasSingleLink2);
                  });
                });
              }, function(e5) {
                setLoading(false);
                setFetched(true);
                setErrorMessage(props.text.something_went_wrong);
                console.error(e5);
              });
              return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
              }) : void 0);
            } catch (e5) {
              return Promise.reject(e5);
            }
          };
          initLinks();
        });
      };
      getLinksIfNeeded();
      var rightSelected = mobile ? displayQRCode : !displayQRCode;
      return React.createElement("div", {
        id: WALLETCONNECT_MODAL_ID,
        className: "walletconnect-qrcode__base animated fadeIn"
      }, React.createElement("div", {
        className: "walletconnect-modal__base"
      }, React.createElement(Header, {
        onClose: props.onClose
      }), hasSingleLink && displayQRCode ? React.createElement("div", {
        className: "walletconnect-modal__single_wallet"
      }, React.createElement("a", {
        onClick: function() {
          return browserUtils.saveMobileLinkInfo({
            name: links[0].name,
            href: singleLinkHref
          });
        },
        href: singleLinkHref,
        rel: "noopener noreferrer",
        target: "_blank"
      }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " \u203A")) : android || loading || !loading && links.length ? React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
      }, React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle_selector"
      }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.mobile), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign(
        {},
        displayProps,
        {
          links,
          errorMessage
        }
      )))));
    }
    var de = {
      choose_preferred_wallet: "W\xE4hle bevorzugte Wallet",
      connect_mobile_wallet: "Verbinde mit Mobile Wallet",
      scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
      connect: "Verbinden",
      qrcode: "QR-Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "In die Zwischenablage kopieren",
      copied_to_clipboard: "In die Zwischenablage kopiert!",
      connect_with: "Verbinden mit Hilfe von",
      loading: "Laden...",
      something_went_wrong: "Etwas ist schief gelaufen",
      no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet",
      no_wallets_found: "keine Wallet gefunden"
    };
    var en = {
      choose_preferred_wallet: "Choose your preferred wallet",
      connect_mobile_wallet: "Connect to Mobile Wallet",
      scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
      connect: "Connect",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copy to clipboard",
      copied_to_clipboard: "Copied to clipboard!",
      connect_with: "Connect with",
      loading: "Loading...",
      something_went_wrong: "Something went wrong",
      no_supported_wallets: "There are no supported wallets yet",
      no_wallets_found: "No wallets found"
    };
    var es = {
      choose_preferred_wallet: "Elige tu billetera preferida",
      connect_mobile_wallet: "Conectar a billetera m\xF3vil",
      scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vil",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Conectar mediante",
      loading: "Cargando...",
      something_went_wrong: "Algo sali\xF3 mal",
      no_supported_wallets: "Todav\xEDa no hay billeteras compatibles",
      no_wallets_found: "No se encontraron billeteras"
    };
    var fr = {
      choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9",
      connect_mobile_wallet: "Se connecter au portefeuille mobile",
      scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
      connect: "Se connecter",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copier",
      copied_to_clipboard: "Copi\xE9!",
      connect_with: "Connectez-vous \xE0 l'aide de",
      loading: "Chargement...",
      something_went_wrong: "Quelque chose a mal tourn\xE9",
      no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
      no_wallets_found: "Aucun portefeuille trouv\xE9"
    };
    var ko = {
      choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694",
      connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0",
      scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694",
      connect: "\uC5F0\uACB0",
      qrcode: "QR \uCF54\uB4DC",
      mobile: "\uBAA8\uBC14\uC77C",
      desktop: "\uB370\uC2A4\uD06C\uD0D1",
      copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
      copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!",
      connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4",
      loading: "\uB85C\uB4DC \uC911...",
      something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
      no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
      no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4"
    };
    var pt = {
      choose_preferred_wallet: "Escolha sua carteira preferida",
      connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel",
      scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vel",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Ligar por meio de",
      loading: "Carregamento...",
      something_went_wrong: "Algo correu mal",
      no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas",
      no_wallets_found: "Nenhuma carteira encontrada"
    };
    var zh = {
      choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305",
      connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305",
      scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801",
      connect: "\u8FDE\u63A5",
      qrcode: "\u4E8C\u7EF4\u7801",
      mobile: "\u79FB\u52A8",
      desktop: "\u684C\u9762",
      copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
      copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01",
      connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5",
      loading: "\u6B63\u5728\u52A0\u8F7D...",
      something_went_wrong: "\u51FA\u4E86\u95EE\u9898",
      no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305",
      no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305"
    };
    var fa = {
      choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F",
      connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F",
      scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F",
      connect: "\u0627\u062A\u0635\u0627\u0644",
      qrcode: "\u06A9\u062F QR",
      mobile: "\u0633\u06CC\u0627\u0631",
      desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E",
      copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F",
      copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!",
      connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627",
      loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC",
      something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F",
      no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F",
      no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F"
    };
    var languages = {
      de,
      en,
      es,
      fr,
      ko,
      pt,
      zh,
      fa
    };
    function injectStyleSheet() {
      var doc = browserUtils.getDocumentOrThrow();
      var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);
      if (prev) {
        doc.head.removeChild(prev);
      }
      var style = doc.createElement("style");
      style.setAttribute("id", WALLETCONNECT_STYLE_ID);
      style.innerText = WALLETCONNECT_STYLE_SHEET;
      doc.head.appendChild(style);
    }
    function renderWrapper() {
      var doc = browserUtils.getDocumentOrThrow();
      var wrapper = doc.createElement("div");
      wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
      doc.body.appendChild(wrapper);
      return wrapper;
    }
    function triggerCloseAnimation() {
      var doc = browserUtils.getDocumentOrThrow();
      var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);
      if (modal) {
        modal.className = modal.className.replace("fadeIn", "fadeOut");
        setTimeout(function() {
          var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);
          if (wrapper) {
            doc.body.removeChild(wrapper);
          }
        }, ANIMATION_DURATION);
      }
    }
    function getWrappedCallback(cb) {
      return function() {
        triggerCloseAnimation();
        if (cb) {
          cb();
        }
      };
    }
    function getText() {
      var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
      return languages[lang] || languages["en"];
    }
    function open$1(uri, cb, qrcodeModalOptions) {
      injectStyleSheet();
      var wrapper = renderWrapper();
      React.render(React.createElement(Modal, {
        text: getText(),
        uri,
        onClose: getWrappedCallback(cb),
        qrcodeModalOptions
      }), wrapper);
    }
    function close$1() {
      triggerCloseAnimation();
    }
    var isNode3 = function() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    };
    function open$2(uri, cb, qrcodeModalOptions) {
      console.log(uri);
      if (isNode3()) {
        open(uri);
      } else {
        open$1(uri, cb, qrcodeModalOptions);
      }
    }
    function close$2() {
      if (isNode3())
        ;
      else {
        close$1();
      }
    }
    var index = {
      open: open$2,
      close: close$2
    };
    module.exports = index;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once4) {
      this.fn = fn;
      this.context = context;
      this.once = once4 || false;
    }
    function addListener4(emitter, event, fn, context, once4) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once4), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames2() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners2(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i5 = 0, l5 = handlers.length, ee = new Array(l5); i5 < l5; i5++) {
        ee[i5] = handlers[i5].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount3(event) {
      var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
      if (!listeners2)
        return 0;
      if (listeners2.fn)
        return 1;
      return listeners2.length;
    };
    EventEmitter3.prototype.emit = function emit4(event, a1, a22, a32, a42, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners2 = this._events[evt], len = arguments.length, args, i5;
      if (listeners2.fn) {
        if (listeners2.once)
          this.removeListener(event, listeners2.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners2.fn.call(listeners2.context), true;
          case 2:
            return listeners2.fn.call(listeners2.context, a1), true;
          case 3:
            return listeners2.fn.call(listeners2.context, a1, a22), true;
          case 4:
            return listeners2.fn.call(listeners2.context, a1, a22, a32), true;
          case 5:
            return listeners2.fn.call(listeners2.context, a1, a22, a32, a42), true;
          case 6:
            return listeners2.fn.call(listeners2.context, a1, a22, a32, a42, a5), true;
        }
        for (i5 = 1, args = new Array(len - 1); i5 < len; i5++) {
          args[i5 - 1] = arguments[i5];
        }
        listeners2.fn.apply(listeners2.context, args);
      } else {
        var length = listeners2.length, j5;
        for (i5 = 0; i5 < length; i5++) {
          if (listeners2[i5].once)
            this.removeListener(event, listeners2[i5].fn, void 0, true);
          switch (len) {
            case 1:
              listeners2[i5].fn.call(listeners2[i5].context);
              break;
            case 2:
              listeners2[i5].fn.call(listeners2[i5].context, a1);
              break;
            case 3:
              listeners2[i5].fn.call(listeners2[i5].context, a1, a22);
              break;
            case 4:
              listeners2[i5].fn.call(listeners2[i5].context, a1, a22, a32);
              break;
            default:
              if (!args)
                for (j5 = 1, args = new Array(len - 1); j5 < len; j5++) {
                  args[j5 - 1] = arguments[j5];
                }
              listeners2[i5].fn.apply(listeners2[i5].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on3(event, fn, context) {
      return addListener4(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once4(event, fn, context) {
      return addListener4(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener4(event, fn, context, once4) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners2 = this._events[evt];
      if (listeners2.fn) {
        if (listeners2.fn === fn && (!once4 || listeners2.once) && (!context || listeners2.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i5 = 0, events = [], length = listeners2.length; i5 < length; i5++) {
          if (listeners2[i5].fn !== fn || once4 && !listeners2[i5].once || context && listeners2[i5].context !== context) {
            events.push(listeners2[i5]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners4(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/capability.js
function blobConstructor() {
  if (typeof _blobConstructor !== "undefined") {
    return _blobConstructor;
  }
  try {
    new globalThis.Blob([new ArrayBuffer(1)]);
    _blobConstructor = true;
  } catch (e5) {
    _blobConstructor = false;
  }
  return _blobConstructor;
}
function checkTypeSupport(type2) {
  if (!xhr) {
    xhr = new globalThis.XMLHttpRequest();
    xhr.open("GET", globalThis.location.host ? "/" : "https://example.com");
  }
  try {
    xhr.responseType = type2;
    return xhr.responseType === type2;
  } catch (e5) {
    return false;
  }
}
function isFunction3(value) {
  return typeof value === "function";
}
var hasFetch, _blobConstructor, xhr, haveArrayBuffer, haveSlice, arraybuffer, msstream, mozchunkedarraybuffer, overrideMimeType, vbArray;
var init_capability = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/capability.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    hasFetch = isFunction3(globalThis.fetch) && isFunction3(globalThis.ReadableStream);
    haveArrayBuffer = typeof globalThis.ArrayBuffer !== "undefined";
    haveSlice = haveArrayBuffer && isFunction3(globalThis.ArrayBuffer.prototype.slice);
    arraybuffer = haveArrayBuffer && checkTypeSupport("arraybuffer");
    msstream = !hasFetch && haveSlice && checkTypeSupport("ms-stream");
    mozchunkedarraybuffer = !hasFetch && haveArrayBuffer && checkTypeSupport("moz-chunked-arraybuffer");
    overrideMimeType = isFunction3(xhr.overrideMimeType);
    vbArray = isFunction3(globalThis.VBArray);
    xhr = null;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/response.js
function IncomingMessage(xhr2, response, mode) {
  var self2 = this;
  Readable.call(self2);
  self2._mode = mode;
  self2.headers = {};
  self2.rawHeaders = [];
  self2.trailers = {};
  self2.rawTrailers = [];
  self2.on("end", function() {
    process.nextTick(function() {
      self2.emit("close");
    });
  });
  var read2;
  if (mode === "fetch") {
    self2._fetchResponse = response;
    self2.url = response.url;
    self2.statusCode = response.status;
    self2.statusMessage = response.statusText;
    for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done; ) {
      self2.headers[header[0].toLowerCase()] = header[1];
      self2.rawHeaders.push(header[0], header[1]);
    }
    var reader = response.body.getReader();
    read2 = function() {
      reader.read().then(function(result) {
        if (self2._destroyed)
          return;
        if (result.done) {
          self2.push(null);
          return;
        }
        self2.push(new Buffer2(result.value));
        read2();
      });
    };
    read2();
  } else {
    self2._xhr = xhr2;
    self2._pos = 0;
    self2.url = xhr2.responseURL;
    self2.statusCode = xhr2.status;
    self2.statusMessage = xhr2.statusText;
    var headers = xhr2.getAllResponseHeaders().split(/\r?\n/);
    headers.forEach(function(header2) {
      var matches = header2.match(/^([^:]+):\s*(.*)/);
      if (matches) {
        var key = matches[1].toLowerCase();
        if (key === "set-cookie") {
          if (self2.headers[key] === void 0) {
            self2.headers[key] = [];
          }
          self2.headers[key].push(matches[2]);
        } else if (self2.headers[key] !== void 0) {
          self2.headers[key] += ", " + matches[2];
        } else {
          self2.headers[key] = matches[2];
        }
        self2.rawHeaders.push(matches[1], matches[2]);
      }
    });
    self2._charset = "x-user-defined";
    if (!overrideMimeType) {
      var mimeType = self2.rawHeaders["mime-type"];
      if (mimeType) {
        var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
        if (charsetMatch) {
          self2._charset = charsetMatch[1].toLowerCase();
        }
      }
      if (!self2._charset)
        self2._charset = "utf-8";
    }
  }
}
var rStates;
var init_response = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/response.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_capability();
    init_util();
    init_stream();
    rStates = {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    };
    inherits_default(IncomingMessage, Readable);
    IncomingMessage.prototype._read = function() {
    };
    IncomingMessage.prototype._onXHRProgress = function() {
      var self2 = this;
      var xhr2 = self2._xhr;
      var response = null;
      switch (self2._mode) {
        case "text:vbarray":
          if (xhr2.readyState !== rStates.DONE)
            break;
          try {
            response = new globalThis.VBArray(xhr2.responseBody).toArray();
          } catch (e5) {
          }
          if (response !== null) {
            self2.push(new Buffer2(response));
            break;
          }
        case "text":
          try {
            response = xhr2.responseText;
          } catch (e5) {
            self2._mode = "text:vbarray";
            break;
          }
          if (response.length > self2._pos) {
            var newData = response.substr(self2._pos);
            if (self2._charset === "x-user-defined") {
              var buffer2 = new Buffer2(newData.length);
              for (var i5 = 0; i5 < newData.length; i5++)
                buffer2[i5] = newData.charCodeAt(i5) & 255;
              self2.push(buffer2);
            } else {
              self2.push(newData, self2._charset);
            }
            self2._pos = response.length;
          }
          break;
        case "arraybuffer":
          if (xhr2.readyState !== rStates.DONE || !xhr2.response)
            break;
          response = xhr2.response;
          self2.push(new Buffer2(new Uint8Array(response)));
          break;
        case "moz-chunked-arraybuffer":
          response = xhr2.response;
          if (xhr2.readyState !== rStates.LOADING || !response)
            break;
          self2.push(new Buffer2(new Uint8Array(response)));
          break;
        case "ms-stream":
          response = xhr2.response;
          if (xhr2.readyState !== rStates.LOADING)
            break;
          var reader = new globalThis.MSStreamReader();
          reader.onprogress = function() {
            if (reader.result.byteLength > self2._pos) {
              self2.push(new Buffer2(new Uint8Array(reader.result.slice(self2._pos))));
              self2._pos = reader.result.byteLength;
            }
          };
          reader.onload = function() {
            self2.push(null);
          };
          reader.readAsArrayBuffer(response);
          break;
      }
      if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
        self2.push(null);
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/to-arraybuffer.js
function to_arraybuffer_default(buf) {
  if (buf instanceof Uint8Array) {
    if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
      return buf.buffer;
    } else if (typeof buf.buffer.slice === "function") {
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
  }
  if (isBuffer2(buf)) {
    var arrayCopy = new Uint8Array(buf.length);
    var len = buf.length;
    for (var i5 = 0; i5 < len; i5++) {
      arrayCopy[i5] = buf[i5];
    }
    return arrayCopy.buffer;
  } else {
    throw new Error("Argument must be a Buffer");
  }
}
var init_to_arraybuffer = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/to-arraybuffer.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_buffer2();
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/request.js
function decideMode(preferBinary, useFetch) {
  if (hasFetch && useFetch) {
    return "fetch";
  } else if (mozchunkedarraybuffer) {
    return "moz-chunked-arraybuffer";
  } else if (msstream) {
    return "ms-stream";
  } else if (arraybuffer && preferBinary) {
    return "arraybuffer";
  } else if (vbArray && preferBinary) {
    return "text:vbarray";
  } else {
    return "text";
  }
}
function ClientRequest(opts) {
  var self2 = this;
  Writable.call(self2);
  self2._opts = opts;
  self2._body = [];
  self2._headers = {};
  if (opts.auth)
    self2.setHeader("Authorization", "Basic " + new Buffer2(opts.auth).toString("base64"));
  Object.keys(opts.headers).forEach(function(name) {
    self2.setHeader(name, opts.headers[name]);
  });
  var preferBinary;
  var useFetch = true;
  if (opts.mode === "disable-fetch") {
    useFetch = false;
    preferBinary = true;
  } else if (opts.mode === "prefer-streaming") {
    preferBinary = false;
  } else if (opts.mode === "allow-wrong-content-type") {
    preferBinary = !overrideMimeType;
  } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
    preferBinary = true;
  } else {
    throw new Error("Invalid value for opts.mode");
  }
  self2._mode = decideMode(preferBinary, useFetch);
  self2.on("finish", function() {
    self2._onFinish();
  });
}
function statusValid(xhr2) {
  try {
    var status = xhr2.status;
    return status !== null && status !== 0;
  } catch (e5) {
    return false;
  }
}
var request_default, unsafeHeaders;
var init_request = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/request.js"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_capability();
    init_util();
    init_response();
    init_stream();
    init_to_arraybuffer();
    request_default = ClientRequest;
    inherits_default(ClientRequest, Writable);
    unsafeHeaders = [
      "accept-charset",
      "accept-encoding",
      "access-control-request-headers",
      "access-control-request-method",
      "connection",
      "content-length",
      "cookie",
      "cookie2",
      "date",
      "dnt",
      "expect",
      "host",
      "keep-alive",
      "origin",
      "referer",
      "te",
      "trailer",
      "transfer-encoding",
      "upgrade",
      "user-agent",
      "via"
    ];
    ClientRequest.prototype.setHeader = function(name, value) {
      var self2 = this;
      var lowerName = name.toLowerCase();
      if (unsafeHeaders.indexOf(lowerName) !== -1)
        return;
      self2._headers[lowerName] = {
        name,
        value
      };
    };
    ClientRequest.prototype.getHeader = function(name) {
      var self2 = this;
      return self2._headers[name.toLowerCase()].value;
    };
    ClientRequest.prototype.removeHeader = function(name) {
      var self2 = this;
      delete self2._headers[name.toLowerCase()];
    };
    ClientRequest.prototype._onFinish = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      var opts = self2._opts;
      var headersObj = self2._headers;
      var body;
      if (opts.method === "POST" || opts.method === "PUT" || opts.method === "PATCH") {
        if (blobConstructor()) {
          body = new globalThis.Blob(self2._body.map(function(buffer2) {
            return to_arraybuffer_default(buffer2);
          }), {
            type: (headersObj["content-type"] || {}).value || ""
          });
        } else {
          body = Buffer2.concat(self2._body).toString();
        }
      }
      if (self2._mode === "fetch") {
        var headers = Object.keys(headersObj).map(function(name) {
          return [headersObj[name].name, headersObj[name].value];
        });
        globalThis.fetch(self2._opts.url, {
          method: self2._opts.method,
          headers,
          body,
          mode: "cors",
          credentials: opts.withCredentials ? "include" : "same-origin"
        }).then(function(response) {
          self2._fetchResponse = response;
          self2._connect();
        }, function(reason) {
          self2.emit("error", reason);
        });
      } else {
        var xhr2 = self2._xhr = new globalThis.XMLHttpRequest();
        try {
          xhr2.open(self2._opts.method, self2._opts.url, true);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
        if ("responseType" in xhr2)
          xhr2.responseType = self2._mode.split(":")[0];
        if ("withCredentials" in xhr2)
          xhr2.withCredentials = !!opts.withCredentials;
        if (self2._mode === "text" && "overrideMimeType" in xhr2)
          xhr2.overrideMimeType("text/plain; charset=x-user-defined");
        Object.keys(headersObj).forEach(function(name) {
          xhr2.setRequestHeader(headersObj[name].name, headersObj[name].value);
        });
        self2._response = null;
        xhr2.onreadystatechange = function() {
          switch (xhr2.readyState) {
            case rStates.LOADING:
            case rStates.DONE:
              self2._onXHRProgress();
              break;
          }
        };
        if (self2._mode === "moz-chunked-arraybuffer") {
          xhr2.onprogress = function() {
            self2._onXHRProgress();
          };
        }
        xhr2.onerror = function() {
          if (self2._destroyed)
            return;
          self2.emit("error", new Error("XHR error"));
        };
        try {
          xhr2.send(body);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
      }
    };
    ClientRequest.prototype._onXHRProgress = function() {
      var self2 = this;
      if (!statusValid(self2._xhr) || self2._destroyed)
        return;
      if (!self2._response)
        self2._connect();
      self2._response._onXHRProgress();
    };
    ClientRequest.prototype._connect = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode);
      self2.emit("response", self2._response);
    };
    ClientRequest.prototype._write = function(chunk, encoding, cb) {
      var self2 = this;
      self2._body.push(chunk);
      cb();
    };
    ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
      var self2 = this;
      self2._destroyed = true;
      if (self2._response)
        self2._response._destroyed = true;
      if (self2._xhr)
        self2._xhr.abort();
    };
    ClientRequest.prototype.end = function(data, encoding, cb) {
      var self2 = this;
      if (typeof data === "function") {
        cb = data;
        data = void 0;
      }
      Writable.prototype.end.call(self2, data, encoding, cb);
    };
    ClientRequest.prototype.flushHeaders = function() {
    };
    ClientRequest.prototype.setTimeout = function() {
    };
    ClientRequest.prototype.setNoDelay = function() {
    };
    ClientRequest.prototype.setSocketKeepAlive = function() {
    };
  }
});

// node-modules-polyfills:punycode
function error(type2) {
  throw new RangeError(errors[type2]);
}
function map2(array, fn) {
  var length = array.length;
  var result = [];
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}
function mapDomain(string, fn) {
  var parts = string.split("@");
  var result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  var labels = string.split(".");
  var encoded = map2(labels, fn).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  var output = [], counter = 0, length = string.length, value, extra;
  while (counter < length) {
    value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  var k5 = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k5 += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k5 + (baseMinusTMin + 1) * delta / (delta + skew));
}
function encode(input) {
  var n3, delta, handledCPCount, basicLength, bias, j5, m5, q5, k5, t5, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
  input = ucs2decode(input);
  inputLength = input.length;
  n3 = initialN;
  delta = 0;
  bias = initialBias;
  for (j5 = 0; j5 < inputLength; ++j5) {
    currentValue = input[j5];
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  handledCPCount = basicLength = output.length;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    for (m5 = maxInt, j5 = 0; j5 < inputLength; ++j5) {
      currentValue = input[j5];
      if (currentValue >= n3 && currentValue < m5) {
        m5 = currentValue;
      }
    }
    handledCPCountPlusOne = handledCPCount + 1;
    if (m5 - n3 > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m5 - n3) * handledCPCountPlusOne;
    n3 = m5;
    for (j5 = 0; j5 < inputLength; ++j5) {
      currentValue = input[j5];
      if (currentValue < n3 && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue == n3) {
        for (q5 = delta, k5 = base; ; k5 += base) {
          t5 = k5 <= bias ? tMin : k5 >= bias + tMax ? tMax : k5 - bias;
          if (q5 < t5) {
            break;
          }
          qMinusT = q5 - t5;
          baseMinusT = base - t5;
          output.push(
            stringFromCharCode(digitToBasic(t5 + qMinusT % baseMinusT, 0))
          );
          q5 = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q5, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n3;
  }
  return output.join("");
}
function toASCII(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode;
var init_punycode = __esm({
  "node-modules-polyfills:punycode"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexNonASCII = /[^\x20-\x7E]/;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
  }
});

// node-modules-polyfills:querystring
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function stringifyPrimitive(v5) {
  switch (typeof v5) {
    case "string":
      return v5;
    case "boolean":
      return v5 ? "true" : "false";
    case "number":
      return isFinite(v5) ? v5 : "";
    default:
      return "";
  }
}
function stringify2(obj, sep, eq, name) {
  sep = sep || "&";
  eq = eq || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return map3(objectKeys(obj), function(k5) {
      var ks = encodeURIComponent(stringifyPrimitive(k5)) + eq;
      if (isArray4(obj[k5])) {
        return map3(obj[k5], function(v5) {
          return ks + encodeURIComponent(stringifyPrimitive(v5));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k5]));
      }
    }).join(sep);
  }
  if (!name)
    return "";
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
}
function map3(xs, f5) {
  if (xs.map)
    return xs.map(f5);
  var res = [];
  for (var i5 = 0; i5 < xs.length; i5++) {
    res.push(f5(xs[i5], i5));
  }
  return res;
}
function parse2(qs, sep, eq, options) {
  sep = sep || "&";
  eq = eq || "=";
  var obj = {};
  if (typeof qs !== "string" || qs.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1e3;
  if (options && typeof options.maxKeys === "number") {
    maxKeys = options.maxKeys;
  }
  var len = qs.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i5 = 0; i5 < len; ++i5) {
    var x5 = qs[i5].replace(regexp, "%20"), idx = x5.indexOf(eq), kstr, vstr, k5, v5;
    if (idx >= 0) {
      kstr = x5.substr(0, idx);
      vstr = x5.substr(idx + 1);
    } else {
      kstr = x5;
      vstr = "";
    }
    k5 = decodeURIComponent(kstr);
    v5 = decodeURIComponent(vstr);
    if (!hasOwnProperty2(obj, k5)) {
      obj[k5] = v5;
    } else if (isArray4(obj[k5])) {
      obj[k5].push(v5);
    } else {
      obj[k5] = [obj[k5], v5];
    }
  }
  return obj;
}
var isArray4, objectKeys;
var init_querystring = __esm({
  "node-modules-polyfills:querystring"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    isArray4 = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
    objectKeys = Object.keys || function(obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          res.push(key);
      }
      return res;
    };
  }
});

// node-modules-polyfills:url
var url_exports = {};
__export(url_exports, {
  Url: () => Url,
  default: () => url_default,
  format: () => urlFormat,
  parse: () => urlParse,
  resolve: () => urlResolve,
  resolveObject: () => urlResolveObject
});
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
function urlParse(url, parseQueryString2, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url)
    return url;
  var u5 = new Url();
  u5.parse(url, parseQueryString2, slashesDenoteHost);
  return u5;
}
function parse3(self2, url, parseQueryString2, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }
  var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url = uSplit.join(splitter);
  var rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      self2.path = rest;
      self2.href = rest;
      self2.pathname = simplePath[1];
      if (simplePath[2]) {
        self2.search = simplePath[2];
        if (parseQueryString2) {
          self2.query = parse2(self2.search.substr(1));
        } else {
          self2.query = self2.search.substr(1);
        }
      } else if (parseQueryString2) {
        self2.search = "";
        self2.query = {};
      }
      return self2;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    self2.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      self2.slashes = true;
    }
  }
  var i5, hec, l5, p5;
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i5 = 0; i5 < hostEndingChars.length; i5++) {
      hec = rest.indexOf(hostEndingChars[i5]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      self2.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (i5 = 0; i5 < nonHostChars.length; i5++) {
      hec = rest.indexOf(nonHostChars[i5]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    self2.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    parseHost(self2);
    self2.hostname = self2.hostname || "";
    var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = self2.hostname.split(/\./);
      for (i5 = 0, l5 = hostparts.length; i5 < l5; i5++) {
        var part = hostparts[i5];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j5 = 0, k5 = part.length; j5 < k5; j5++) {
            if (part.charCodeAt(j5) > 127) {
              newpart += "x";
            } else {
              newpart += part[j5];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i5);
            var notHost = hostparts.slice(i5 + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            self2.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (self2.hostname.length > hostnameMaxLen) {
      self2.hostname = "";
    } else {
      self2.hostname = self2.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      self2.hostname = toASCII(self2.hostname);
    }
    p5 = self2.port ? ":" + self2.port : "";
    var h5 = self2.hostname || "";
    self2.host = h5 + p5;
    self2.href += self2.host;
    if (ipv6Hostname) {
      self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (i5 = 0, l5 = autoEscape.length; i5 < l5; i5++) {
      var ae = autoEscape[i5];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash = rest.indexOf("#");
  if (hash !== -1) {
    self2.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    self2.search = rest.substr(qm);
    self2.query = rest.substr(qm + 1);
    if (parseQueryString2) {
      self2.query = parse2(self2.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString2) {
    self2.search = "";
    self2.query = {};
  }
  if (rest)
    self2.pathname = rest;
  if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
    self2.pathname = "/";
  }
  if (self2.pathname || self2.search) {
    p5 = self2.pathname || "";
    var s5 = self2.search || "";
    self2.path = p5 + s5;
  }
  self2.href = format2(self2);
  return self2;
}
function urlFormat(obj) {
  if (isString(obj))
    obj = parse3({}, obj);
  return format2(obj);
}
function format2(self2) {
  var auth = self2.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = self2.protocol || "", pathname = self2.pathname || "", hash = self2.hash || "", host = false, query = "";
  if (self2.host) {
    host = auth + self2.host;
  } else if (self2.hostname) {
    host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
    if (self2.port) {
      host += ":" + self2.port;
    }
  }
  if (self2.query && isObject(self2.query) && Object.keys(self2.query).length) {
    query = stringify2(self2.query);
  }
  var search = self2.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (self2.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash && hash.charAt(0) !== "#")
    hash = "#" + hash;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash;
}
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
function urlResolveObject(source, relative) {
  if (!source)
    return relative;
  return urlParse(source, false, true).resolveObject(relative);
}
function parseHost(self2) {
  var host = self2.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      self2.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    self2.hostname = host;
}
var url_default, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol;
var init_url = __esm({
  "node-modules-polyfills:url"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_punycode();
    init_util();
    init_querystring();
    url_default = {
      parse: urlParse,
      resolve: urlResolve,
      resolveObject: urlResolveObject,
      format: urlFormat,
      Url
    };
    protocolPattern = /^([a-z0-9.+-]+:)/i;
    portPattern = /:[0-9]*$/;
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    autoEscape = ["'"].concat(unwise);
    nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    hostEndingChars = ["/", "?", "#"];
    hostnameMaxLen = 255;
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    };
    hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    Url.prototype.parse = function(url, parseQueryString2, slashesDenoteHost) {
      return parse3(this, url, parseQueryString2, slashesDenoteHost);
    };
    Url.prototype.format = function() {
      return format2(this);
    };
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    Url.prototype.resolveObject = function(relative) {
      if (isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol")
            result[rkey] = relative[rkey];
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      var relPath;
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys2 = Object.keys(relative);
          for (var v5 = 0; v5 < keys2.length; v5++) {
            var k5 = keys2[v5];
            result[k5] = relative[k5];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p5 = result.pathname || "";
          var s5 = result.search || "";
          result.path = p5 + s5;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      relPath = relative.pathname && relative.pathname.split("/") || [];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      var authInHost;
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last2 = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last2 === "." || last2 === "..") || last2 === "";
      var up = 0;
      for (var i5 = srcPath.length; i5 >= 0; i5--) {
        last2 = srcPath[i5];
        if (last2 === ".") {
          srcPath.splice(i5, 1);
        } else if (last2 === "..") {
          srcPath.splice(i5, 1);
          up++;
        } else if (up) {
          srcPath.splice(i5, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      return parseHost(this);
    };
  }
});

// node-modules-polyfills:http
var http_exports = {};
__export(http_exports, {
  Agent: () => Agent,
  METHODS: () => METHODS,
  STATUS_CODES: () => STATUS_CODES,
  default: () => http_default,
  get: () => get,
  request: () => request
});
function request(opts, cb) {
  if (typeof opts === "string")
    opts = urlParse(opts);
  var defaultProtocol = globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
  var protocol = opts.protocol || defaultProtocol;
  var host = opts.hostname || opts.host;
  var port = opts.port;
  var path = opts.path || "/";
  if (host && host.indexOf(":") !== -1)
    host = "[" + host + "]";
  opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
  opts.method = (opts.method || "GET").toUpperCase();
  opts.headers = opts.headers || {};
  var req = new request_default(opts);
  if (cb)
    req.on("response", cb);
  return req;
}
function get(opts, cb) {
  var req = request(opts, cb);
  req.end();
  return req;
}
function Agent() {
}
var METHODS, STATUS_CODES, http_default;
var init_http = __esm({
  "node-modules-polyfills:http"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_request();
    init_url();
    Agent.defaultMaxSockets = 4;
    METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
    STATUS_CODES = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Moved Temporarily",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Time-out",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Large",
      414: "Request-URI Too Large",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a teapot",
      422: "Unprocessable Entity",
      423: "Locked",
      424: "Failed Dependency",
      425: "Unordered Collection",
      426: "Upgrade Required",
      428: "Precondition Required",
      429: "Too Many Requests",
      431: "Request Header Fields Too Large",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Time-out",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      507: "Insufficient Storage",
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      511: "Network Authentication Required"
    };
    http_default = {
      request,
      get,
      Agent,
      METHODS,
      STATUS_CODES
    };
  }
});

// node-modules-polyfills-commonjs:http
var require_http = __commonJS({
  "node-modules-polyfills-commonjs:http"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_http(), __toCommonJS(http_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills:https
var https_exports = {};
__export(https_exports, {
  Agent: () => Agent2,
  METHODS: () => METHODS2,
  STATUS_CODES: () => STATUS_CODES2,
  default: () => https_default,
  get: () => get2,
  request: () => request2
});
function request2(opts, cb) {
  if (typeof opts === "string")
    opts = urlParse(opts);
  var defaultProtocol = globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
  var protocol = opts.protocol || defaultProtocol;
  var host = opts.hostname || opts.host;
  var port = opts.port;
  var path = opts.path || "/";
  if (host && host.indexOf(":") !== -1)
    host = "[" + host + "]";
  opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
  opts.method = (opts.method || "GET").toUpperCase();
  opts.headers = opts.headers || {};
  var req = new request_default(opts);
  if (cb)
    req.on("response", cb);
  return req;
}
function get2(opts, cb) {
  var req = request2(opts, cb);
  req.end();
  return req;
}
function Agent2() {
}
var METHODS2, STATUS_CODES2, https_default;
var init_https = __esm({
  "node-modules-polyfills:https"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_request();
    init_url();
    Agent2.defaultMaxSockets = 4;
    METHODS2 = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
    STATUS_CODES2 = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Moved Temporarily",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Time-out",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Large",
      414: "Request-URI Too Large",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a teapot",
      422: "Unprocessable Entity",
      423: "Locked",
      424: "Failed Dependency",
      425: "Unordered Collection",
      426: "Upgrade Required",
      428: "Precondition Required",
      429: "Too Many Requests",
      431: "Request Header Fields Too Large",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Time-out",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      507: "Insufficient Storage",
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      511: "Network Authentication Required"
    };
    https_default = {
      request: request2,
      get: get2,
      Agent: Agent2,
      METHODS: METHODS2,
      STATUS_CODES: STATUS_CODES2
    };
  }
});

// node-modules-polyfills-commonjs:https
var require_https = __commonJS({
  "node-modules-polyfills-commonjs:https"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_https(), __toCommonJS(https_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills:os
var os_exports = {};
__export(os_exports, {
  EOL: () => EOL,
  arch: () => arch,
  cpus: () => cpus,
  default: () => os_default,
  endianness: () => endianness,
  freemem: () => freemem,
  getNetworkInterfaces: () => getNetworkInterfaces,
  hostname: () => hostname,
  loadavg: () => loadavg,
  networkInterfaces: () => networkInterfaces,
  platform: () => platform3,
  release: () => release3,
  tmpDir: () => tmpDir,
  tmpdir: () => tmpdir,
  totalmem: () => totalmem,
  type: () => type,
  uptime: () => uptime3
});
function endianness() {
  if (typeof _endianness === "undefined") {
    var a5 = new ArrayBuffer(2);
    var b4 = new Uint8Array(a5);
    var c5 = new Uint16Array(a5);
    b4[0] = 1;
    b4[1] = 2;
    if (c5[0] === 258) {
      _endianness = "BE";
    } else if (c5[0] === 513) {
      _endianness = "LE";
    } else {
      throw new Error("unable to figure out endianess");
    }
  }
  return _endianness;
}
function hostname() {
  if (typeof globalThis.location !== "undefined") {
    return globalThis.location.hostname;
  } else
    return "";
}
function loadavg() {
  return [];
}
function uptime3() {
  return 0;
}
function freemem() {
  return Number.MAX_VALUE;
}
function totalmem() {
  return Number.MAX_VALUE;
}
function cpus() {
  return [];
}
function type() {
  return "Browser";
}
function release3() {
  if (typeof globalThis.navigator !== "undefined") {
    return globalThis.navigator.appVersion;
  }
  return "";
}
function networkInterfaces() {
}
function getNetworkInterfaces() {
}
function arch() {
  return "javascript";
}
function platform3() {
  return "browser";
}
function tmpDir() {
  return "/tmp";
}
var _endianness, tmpdir, EOL, os_default;
var init_os = __esm({
  "node-modules-polyfills:os"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    tmpdir = tmpDir;
    EOL = "\n";
    os_default = {
      EOL,
      tmpdir,
      tmpDir,
      networkInterfaces,
      getNetworkInterfaces,
      release: release3,
      type,
      cpus,
      totalmem,
      freemem,
      uptime: uptime3,
      loadavg,
      hostname,
      endianness
    };
  }
});

// node-modules-polyfills-commonjs:os
var require_os = __commonJS({
  "node-modules-polyfills-commonjs:os"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_os(), __toCommonJS(os_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills-commonjs:url
var require_url = __commonJS({
  "node-modules-polyfills-commonjs:url"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_url(), __toCommonJS(url_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/xhr2-cookies/dist/progress-event.js
var require_progress_event = __commonJS({
  "node_modules/xhr2-cookies/dist/progress-event.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProgressEvent = function() {
      function ProgressEvent2(type2) {
        this.type = type2;
        this.bubbles = false;
        this.cancelable = false;
        this.loaded = 0;
        this.lengthComputable = false;
        this.total = 0;
      }
      return ProgressEvent2;
    }();
    exports.ProgressEvent = ProgressEvent;
  }
});

// node_modules/xhr2-cookies/dist/errors.js
var require_errors3 = __commonJS({
  "node_modules/xhr2-cookies/dist/errors.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b4) {
        d5.__proto__ = b4;
      } || function(d5, b4) {
        for (var p5 in b4)
          if (b4.hasOwnProperty(p5))
            d5[p5] = b4[p5];
      };
      return function(d5, b4) {
        extendStatics(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var SecurityError = function(_super) {
      __extends2(SecurityError2, _super);
      function SecurityError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return SecurityError2;
    }(Error);
    exports.SecurityError = SecurityError;
    var InvalidStateError = function(_super) {
      __extends2(InvalidStateError2, _super);
      function InvalidStateError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return InvalidStateError2;
    }(Error);
    exports.InvalidStateError = InvalidStateError;
    var NetworkError = function(_super) {
      __extends2(NetworkError2, _super);
      function NetworkError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NetworkError2;
    }(Error);
    exports.NetworkError = NetworkError;
    var SyntaxError2 = function(_super) {
      __extends2(SyntaxError3, _super);
      function SyntaxError3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return SyntaxError3;
    }(Error);
    exports.SyntaxError = SyntaxError2;
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request-event-target.js
var require_xml_http_request_event_target = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request-event-target.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var XMLHttpRequestEventTarget = function() {
      function XMLHttpRequestEventTarget2() {
        this.listeners = {};
      }
      XMLHttpRequestEventTarget2.prototype.addEventListener = function(eventType, listener) {
        eventType = eventType.toLowerCase();
        this.listeners[eventType] = this.listeners[eventType] || [];
        this.listeners[eventType].push(listener.handleEvent || listener);
      };
      XMLHttpRequestEventTarget2.prototype.removeEventListener = function(eventType, listener) {
        eventType = eventType.toLowerCase();
        if (!this.listeners[eventType]) {
          return;
        }
        var index = this.listeners[eventType].indexOf(listener.handleEvent || listener);
        if (index < 0) {
          return;
        }
        this.listeners[eventType].splice(index, 1);
      };
      XMLHttpRequestEventTarget2.prototype.dispatchEvent = function(event) {
        var eventType = event.type.toLowerCase();
        event.target = this;
        if (this.listeners[eventType]) {
          for (var _i = 0, _a = this.listeners[eventType]; _i < _a.length; _i++) {
            var listener_1 = _a[_i];
            listener_1.call(this, event);
          }
        }
        var listener = this["on" + eventType];
        if (listener) {
          listener.call(this, event);
        }
        return true;
      };
      return XMLHttpRequestEventTarget2;
    }();
    exports.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request-upload.js
var require_xml_http_request_upload = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request-upload.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b4) {
        d5.__proto__ = b4;
      } || function(d5, b4) {
        for (var p5 in b4)
          if (b4.hasOwnProperty(p5))
            d5[p5] = b4[p5];
      };
      return function(d5, b4) {
        extendStatics(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    var XMLHttpRequestUpload = function(_super) {
      __extends2(XMLHttpRequestUpload2, _super);
      function XMLHttpRequestUpload2() {
        var _this = _super.call(this) || this;
        _this._contentType = null;
        _this._body = null;
        _this._reset();
        return _this;
      }
      XMLHttpRequestUpload2.prototype._reset = function() {
        this._contentType = null;
        this._body = null;
      };
      XMLHttpRequestUpload2.prototype._setData = function(data) {
        if (data == null) {
          return;
        }
        if (typeof data === "string") {
          if (data.length !== 0) {
            this._contentType = "text/plain;charset=UTF-8";
          }
          this._body = new Buffer2(data, "utf-8");
        } else if (Buffer2.isBuffer(data)) {
          this._body = data;
        } else if (data instanceof ArrayBuffer) {
          var body = new Buffer2(data.byteLength);
          var view = new Uint8Array(data);
          for (var i5 = 0; i5 < data.byteLength; i5++) {
            body[i5] = view[i5];
          }
          this._body = body;
        } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
          var body = new Buffer2(data.byteLength);
          var offset = data.byteOffset;
          var view = new Uint8Array(data.buffer);
          for (var i5 = 0; i5 < data.byteLength; i5++) {
            body[i5] = view[i5 + offset];
          }
          this._body = body;
        } else {
          throw new Error("Unsupported send() data " + data);
        }
      };
      XMLHttpRequestUpload2.prototype._finalizeHeaders = function(headers, loweredHeaders) {
        if (this._contentType && !loweredHeaders["content-type"]) {
          headers["Content-Type"] = this._contentType;
        }
        if (this._body) {
          headers["Content-Length"] = this._body.length.toString();
        }
      };
      XMLHttpRequestUpload2.prototype._startUpload = function(request3) {
        if (this._body) {
          request3.write(this._body);
        }
        request3.end();
      };
      return XMLHttpRequestUpload2;
    }(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
    exports.XMLHttpRequestUpload = XMLHttpRequestUpload;
  }
});

// node_modules/cookiejar/cookiejar.js
var require_cookiejar = __commonJS({
  "node_modules/cookiejar/cookiejar.js"(exports) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function() {
      "use strict";
      function CookieAccessInfo(domain3, path, secure, script) {
        if (this instanceof CookieAccessInfo) {
          this.domain = domain3 || void 0;
          this.path = path || "/";
          this.secure = !!secure;
          this.script = !!script;
          return this;
        }
        return new CookieAccessInfo(domain3, path, secure, script);
      }
      CookieAccessInfo.All = Object.freeze(/* @__PURE__ */ Object.create(null));
      exports.CookieAccessInfo = CookieAccessInfo;
      function Cookie(cookiestr, request_domain, request_path) {
        if (cookiestr instanceof Cookie) {
          return cookiestr;
        }
        if (this instanceof Cookie) {
          this.name = null;
          this.value = null;
          this.expiration_date = Infinity;
          this.path = String(request_path || "/");
          this.explicit_path = false;
          this.domain = request_domain || null;
          this.explicit_domain = false;
          this.secure = false;
          this.noscript = false;
          if (cookiestr) {
            this.parse(cookiestr, request_domain, request_path);
          }
          return this;
        }
        return new Cookie(cookiestr, request_domain, request_path);
      }
      exports.Cookie = Cookie;
      Cookie.prototype.toString = function toString4() {
        var str = [this.name + "=" + this.value];
        if (this.expiration_date !== Infinity) {
          str.push("expires=" + new Date(this.expiration_date).toGMTString());
        }
        if (this.domain) {
          str.push("domain=" + this.domain);
        }
        if (this.path) {
          str.push("path=" + this.path);
        }
        if (this.secure) {
          str.push("secure");
        }
        if (this.noscript) {
          str.push("httponly");
        }
        return str.join("; ");
      };
      Cookie.prototype.toValueString = function toValueString() {
        return this.name + "=" + this.value;
      };
      var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
      Cookie.prototype.parse = function parse4(str, request_domain, request_path) {
        if (this instanceof Cookie) {
          var parts = str.split(";").filter(function(value2) {
            return !!value2;
          });
          var i5;
          var pair = parts[0].match(/([^=]+)=([\s\S]*)/);
          if (!pair) {
            console.warn("Invalid cookie header encountered. Header: '" + str + "'");
            return;
          }
          var key = pair[1];
          var value = pair[2];
          if (typeof key !== "string" || key.length === 0 || typeof value !== "string") {
            console.warn("Unable to extract values from cookie header. Cookie: '" + str + "'");
            return;
          }
          this.name = key;
          this.value = value;
          for (i5 = 1; i5 < parts.length; i5 += 1) {
            pair = parts[i5].match(/([^=]+)(?:=([\s\S]*))?/);
            key = pair[1].trim().toLowerCase();
            value = pair[2];
            switch (key) {
              case "httponly":
                this.noscript = true;
                break;
              case "expires":
                this.expiration_date = value ? Number(Date.parse(value)) : Infinity;
                break;
              case "path":
                this.path = value ? value.trim() : "";
                this.explicit_path = true;
                break;
              case "domain":
                this.domain = value ? value.trim() : "";
                this.explicit_domain = !!this.domain;
                break;
              case "secure":
                this.secure = true;
                break;
            }
          }
          if (!this.explicit_path) {
            this.path = request_path || "/";
          }
          if (!this.explicit_domain) {
            this.domain = request_domain;
          }
          return this;
        }
        return new Cookie().parse(str, request_domain, request_path);
      };
      Cookie.prototype.matches = function matches(access_info) {
        if (access_info === CookieAccessInfo.All) {
          return true;
        }
        if (this.noscript && access_info.script || this.secure && !access_info.secure || !this.collidesWith(access_info)) {
          return false;
        }
        return true;
      };
      Cookie.prototype.collidesWith = function collidesWith(access_info) {
        if (this.path && !access_info.path || this.domain && !access_info.domain) {
          return false;
        }
        if (this.path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        if (this.explicit_path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/, "");
        var cookie_domain = this.domain && this.domain.replace(/^[\.]/, "");
        if (cookie_domain === access_domain) {
          return true;
        }
        if (cookie_domain) {
          if (!this.explicit_domain) {
            return false;
          }
          var wildcard = access_domain.indexOf(cookie_domain);
          if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
            return false;
          }
          return true;
        }
        return true;
      };
      function CookieJar() {
        var cookies, cookies_list, collidable_cookie;
        if (this instanceof CookieJar) {
          cookies = /* @__PURE__ */ Object.create(null);
          this.setCookie = function setCookie(cookie, request_domain, request_path) {
            var remove, i5;
            cookie = new Cookie(cookie, request_domain, request_path);
            remove = cookie.expiration_date <= Date.now();
            if (cookies[cookie.name] !== void 0) {
              cookies_list = cookies[cookie.name];
              for (i5 = 0; i5 < cookies_list.length; i5 += 1) {
                collidable_cookie = cookies_list[i5];
                if (collidable_cookie.collidesWith(cookie)) {
                  if (remove) {
                    cookies_list.splice(i5, 1);
                    if (cookies_list.length === 0) {
                      delete cookies[cookie.name];
                    }
                    return false;
                  }
                  cookies_list[i5] = cookie;
                  return cookie;
                }
              }
              if (remove) {
                return false;
              }
              cookies_list.push(cookie);
              return cookie;
            }
            if (remove) {
              return false;
            }
            cookies[cookie.name] = [cookie];
            return cookies[cookie.name];
          };
          this.getCookie = function getCookie(cookie_name, access_info) {
            var cookie, i5;
            cookies_list = cookies[cookie_name];
            if (!cookies_list) {
              return;
            }
            for (i5 = 0; i5 < cookies_list.length; i5 += 1) {
              cookie = cookies_list[i5];
              if (cookie.expiration_date <= Date.now()) {
                if (cookies_list.length === 0) {
                  delete cookies[cookie.name];
                }
                continue;
              }
              if (cookie.matches(access_info)) {
                return cookie;
              }
            }
          };
          this.getCookies = function getCookies(access_info) {
            var matches = [], cookie_name, cookie;
            for (cookie_name in cookies) {
              cookie = this.getCookie(cookie_name, access_info);
              if (cookie) {
                matches.push(cookie);
              }
            }
            matches.toString = function toString4() {
              return matches.join(":");
            };
            matches.toValueString = function toValueString() {
              return matches.map(function(c5) {
                return c5.toValueString();
              }).join("; ");
            };
            return matches;
          };
          return this;
        }
        return new CookieJar();
      }
      exports.CookieJar = CookieJar;
      CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
        cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
        var successful = [], i5, cookie;
        cookies = cookies.map(function(item) {
          return new Cookie(item, request_domain, request_path);
        });
        for (i5 = 0; i5 < cookies.length; i5 += 1) {
          cookie = cookies[i5];
          if (this.setCookie(cookie, request_domain, request_path)) {
            successful.push(cookie);
          }
        }
        return successful;
      };
    })();
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request.js
var require_xml_http_request = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b4) {
        d5.__proto__ = b4;
      } || function(d5, b4) {
        for (var p5 in b4)
          if (b4.hasOwnProperty(p5))
            d5[p5] = b4[p5];
      };
      return function(d5, b4) {
        extendStatics(d5, b4);
        function __() {
          this.constructor = d5;
        }
        d5.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
      };
    }();
    var __assign2 = exports && exports.__assign || Object.assign || function(t5) {
      for (var s5, i5 = 1, n3 = arguments.length; i5 < n3; i5++) {
        s5 = arguments[i5];
        for (var p5 in s5)
          if (Object.prototype.hasOwnProperty.call(s5, p5))
            t5[p5] = s5[p5];
      }
      return t5;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var http = require_http();
    var https = require_https();
    var os = require_os();
    var url = require_url();
    var progress_event_1 = require_progress_event();
    var errors_1 = require_errors3();
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    var xml_http_request_upload_1 = require_xml_http_request_upload();
    var Cookie = require_cookiejar();
    var XMLHttpRequest2 = function(_super) {
      __extends2(XMLHttpRequest3, _super);
      function XMLHttpRequest3(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = _super.call(this) || this;
        _this.UNSENT = XMLHttpRequest3.UNSENT;
        _this.OPENED = XMLHttpRequest3.OPENED;
        _this.HEADERS_RECEIVED = XMLHttpRequest3.HEADERS_RECEIVED;
        _this.LOADING = XMLHttpRequest3.LOADING;
        _this.DONE = XMLHttpRequest3.DONE;
        _this.onreadystatechange = null;
        _this.readyState = XMLHttpRequest3.UNSENT;
        _this.response = null;
        _this.responseText = "";
        _this.responseType = "";
        _this.status = 0;
        _this.statusText = "";
        _this.timeout = 0;
        _this.upload = new xml_http_request_upload_1.XMLHttpRequestUpload();
        _this.responseUrl = "";
        _this.withCredentials = false;
        _this._method = null;
        _this._url = null;
        _this._sync = false;
        _this._headers = {};
        _this._loweredHeaders = {};
        _this._mimeOverride = null;
        _this._request = null;
        _this._response = null;
        _this._responseParts = null;
        _this._responseHeaders = null;
        _this._aborting = null;
        _this._error = null;
        _this._loadedBytes = 0;
        _this._totalBytes = 0;
        _this._lengthComputable = false;
        _this._restrictedMethods = { CONNECT: true, TRACE: true, TRACK: true };
        _this._restrictedHeaders = {
          "accept-charset": true,
          "accept-encoding": true,
          "access-control-request-headers": true,
          "access-control-request-method": true,
          connection: true,
          "content-length": true,
          cookie: true,
          cookie2: true,
          date: true,
          dnt: true,
          expect: true,
          host: true,
          "keep-alive": true,
          origin: true,
          referer: true,
          te: true,
          trailer: true,
          "transfer-encoding": true,
          upgrade: true,
          "user-agent": true,
          via: true
        };
        _this._privateHeaders = { "set-cookie": true, "set-cookie2": true };
        _this._userAgent = "Mozilla/5.0 (" + os.type() + " " + os.arch() + ") node.js/" + process.versions.node + " v8/" + process.versions.v8;
        _this._anonymous = options.anon || false;
        return _this;
      }
      XMLHttpRequest3.prototype.open = function(method, url2, async2, user, password) {
        if (async2 === void 0) {
          async2 = true;
        }
        method = method.toUpperCase();
        if (this._restrictedMethods[method]) {
          throw new XMLHttpRequest3.SecurityError("HTTP method " + method + " is not allowed in XHR");
        }
        ;
        var xhrUrl = this._parseUrl(url2, user, password);
        if (this.readyState === XMLHttpRequest3.HEADERS_RECEIVED || this.readyState === XMLHttpRequest3.LOADING) {
        }
        this._method = method;
        this._url = xhrUrl;
        this._sync = !async2;
        this._headers = {};
        this._loweredHeaders = {};
        this._mimeOverride = null;
        this._setReadyState(XMLHttpRequest3.OPENED);
        this._request = null;
        this._response = null;
        this.status = 0;
        this.statusText = "";
        this._responseParts = [];
        this._responseHeaders = null;
        this._loadedBytes = 0;
        this._totalBytes = 0;
        this._lengthComputable = false;
      };
      XMLHttpRequest3.prototype.setRequestHeader = function(name, value) {
        if (this.readyState !== XMLHttpRequest3.OPENED) {
          throw new XMLHttpRequest3.InvalidStateError("XHR readyState must be OPENED");
        }
        var loweredName = name.toLowerCase();
        if (this._restrictedHeaders[loweredName] || /^sec-/.test(loweredName) || /^proxy-/.test(loweredName)) {
          console.warn('Refused to set unsafe header "' + name + '"');
          return;
        }
        value = value.toString();
        if (this._loweredHeaders[loweredName] != null) {
          name = this._loweredHeaders[loweredName];
          this._headers[name] = this._headers[name] + ", " + value;
        } else {
          this._loweredHeaders[loweredName] = name;
          this._headers[name] = value;
        }
      };
      XMLHttpRequest3.prototype.send = function(data) {
        if (this.readyState !== XMLHttpRequest3.OPENED) {
          throw new XMLHttpRequest3.InvalidStateError("XHR readyState must be OPENED");
        }
        if (this._request) {
          throw new XMLHttpRequest3.InvalidStateError("send() already called");
        }
        switch (this._url.protocol) {
          case "file:":
            return this._sendFile(data);
          case "http:":
          case "https:":
            return this._sendHttp(data);
          default:
            throw new XMLHttpRequest3.NetworkError("Unsupported protocol " + this._url.protocol);
        }
      };
      XMLHttpRequest3.prototype.abort = function() {
        if (this._request == null) {
          return;
        }
        this._request.abort();
        this._setError();
        this._dispatchProgress("abort");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype.getResponseHeader = function(name) {
        if (this._responseHeaders == null || name == null) {
          return null;
        }
        var loweredName = name.toLowerCase();
        return this._responseHeaders.hasOwnProperty(loweredName) ? this._responseHeaders[name.toLowerCase()] : null;
      };
      XMLHttpRequest3.prototype.getAllResponseHeaders = function() {
        var _this = this;
        if (this._responseHeaders == null) {
          return "";
        }
        return Object.keys(this._responseHeaders).map(function(key) {
          return key + ": " + _this._responseHeaders[key];
        }).join("\r\n");
      };
      XMLHttpRequest3.prototype.overrideMimeType = function(mimeType) {
        if (this.readyState === XMLHttpRequest3.LOADING || this.readyState === XMLHttpRequest3.DONE) {
          throw new XMLHttpRequest3.InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
        }
        this._mimeOverride = mimeType.toLowerCase();
      };
      XMLHttpRequest3.prototype.nodejsSet = function(options) {
        this.nodejsHttpAgent = options.httpAgent || this.nodejsHttpAgent;
        this.nodejsHttpsAgent = options.httpsAgent || this.nodejsHttpsAgent;
        if (options.hasOwnProperty("baseUrl")) {
          if (options.baseUrl != null) {
            var parsedUrl = url.parse(options.baseUrl, false, true);
            if (!parsedUrl.protocol) {
              throw new XMLHttpRequest3.SyntaxError("baseUrl must be an absolute URL");
            }
          }
          this.nodejsBaseUrl = options.baseUrl;
        }
      };
      XMLHttpRequest3.nodejsSet = function(options) {
        XMLHttpRequest3.prototype.nodejsSet(options);
      };
      XMLHttpRequest3.prototype._setReadyState = function(readyState) {
        this.readyState = readyState;
        this.dispatchEvent(new progress_event_1.ProgressEvent("readystatechange"));
      };
      XMLHttpRequest3.prototype._sendFile = function(data) {
        throw new Error("Protocol file: not implemented");
      };
      XMLHttpRequest3.prototype._sendHttp = function(data) {
        if (this._sync) {
          throw new Error("Synchronous XHR processing not implemented");
        }
        if (data && (this._method === "GET" || this._method === "HEAD")) {
          console.warn("Discarding entity body for " + this._method + " requests");
          data = null;
        } else {
          data = data || "";
        }
        this.upload._setData(data);
        this._finalizeHeaders();
        this._sendHxxpRequest();
      };
      XMLHttpRequest3.prototype._sendHxxpRequest = function() {
        var _this = this;
        if (this.withCredentials) {
          var cookie = XMLHttpRequest3.cookieJar.getCookies(Cookie.CookieAccessInfo(this._url.hostname, this._url.pathname, this._url.protocol === "https:")).toValueString();
          this._headers.cookie = this._headers.cookie2 = cookie;
        }
        var _a = this._url.protocol === "http:" ? [http, this.nodejsHttpAgent] : [https, this.nodejsHttpsAgent], hxxp = _a[0], agent = _a[1];
        var requestMethod = hxxp.request.bind(hxxp);
        var request3 = requestMethod({
          hostname: this._url.hostname,
          port: +this._url.port,
          path: this._url.path,
          auth: this._url.auth,
          method: this._method,
          headers: this._headers,
          agent
        });
        this._request = request3;
        if (this.timeout) {
          request3.setTimeout(this.timeout, function() {
            return _this._onHttpTimeout(request3);
          });
        }
        request3.on("response", function(response) {
          return _this._onHttpResponse(request3, response);
        });
        request3.on("error", function(error2) {
          return _this._onHttpRequestError(request3, error2);
        });
        this.upload._startUpload(request3);
        if (this._request === request3) {
          this._dispatchProgress("loadstart");
        }
      };
      XMLHttpRequest3.prototype._finalizeHeaders = function() {
        this._headers = __assign2({}, this._headers, { Connection: "keep-alive", Host: this._url.host, "User-Agent": this._userAgent }, this._anonymous ? { Referer: "about:blank" } : {});
        this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
      };
      XMLHttpRequest3.prototype._onHttpResponse = function(request3, response) {
        var _this = this;
        if (this._request !== request3) {
          return;
        }
        if (this.withCredentials && (response.headers["set-cookie"] || response.headers["set-cookie2"])) {
          XMLHttpRequest3.cookieJar.setCookies(response.headers["set-cookie"] || response.headers["set-cookie2"]);
        }
        if ([301, 302, 303, 307, 308].indexOf(response.statusCode) >= 0) {
          this._url = this._parseUrl(response.headers.location);
          this._method = "GET";
          if (this._loweredHeaders["content-type"]) {
            delete this._headers[this._loweredHeaders["content-type"]];
            delete this._loweredHeaders["content-type"];
          }
          if (this._headers["Content-Type"] != null) {
            delete this._headers["Content-Type"];
          }
          delete this._headers["Content-Length"];
          this.upload._reset();
          this._finalizeHeaders();
          this._sendHxxpRequest();
          return;
        }
        this._response = response;
        this._response.on("data", function(data) {
          return _this._onHttpResponseData(response, data);
        });
        this._response.on("end", function() {
          return _this._onHttpResponseEnd(response);
        });
        this._response.on("close", function() {
          return _this._onHttpResponseClose(response);
        });
        this.responseUrl = this._url.href.split("#")[0];
        this.status = response.statusCode;
        this.statusText = http.STATUS_CODES[this.status];
        this._parseResponseHeaders(response);
        var lengthString = this._responseHeaders["content-length"] || "";
        this._totalBytes = +lengthString;
        this._lengthComputable = !!lengthString;
        this._setReadyState(XMLHttpRequest3.HEADERS_RECEIVED);
      };
      XMLHttpRequest3.prototype._onHttpResponseData = function(response, data) {
        if (this._response !== response) {
          return;
        }
        this._responseParts.push(new Buffer2(data));
        this._loadedBytes += data.length;
        if (this.readyState !== XMLHttpRequest3.LOADING) {
          this._setReadyState(XMLHttpRequest3.LOADING);
        }
        this._dispatchProgress("progress");
      };
      XMLHttpRequest3.prototype._onHttpResponseEnd = function(response) {
        if (this._response !== response) {
          return;
        }
        this._parseResponse();
        this._request = null;
        this._response = null;
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("load");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._onHttpResponseClose = function(response) {
        if (this._response !== response) {
          return;
        }
        var request3 = this._request;
        this._setError();
        request3.abort();
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("error");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._onHttpTimeout = function(request3) {
        if (this._request !== request3) {
          return;
        }
        this._setError();
        request3.abort();
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("timeout");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._onHttpRequestError = function(request3, error2) {
        if (this._request !== request3) {
          return;
        }
        this._setError();
        request3.abort();
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("error");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._dispatchProgress = function(eventType) {
        var event = new XMLHttpRequest3.ProgressEvent(eventType);
        event.lengthComputable = this._lengthComputable;
        event.loaded = this._loadedBytes;
        event.total = this._totalBytes;
        this.dispatchEvent(event);
      };
      XMLHttpRequest3.prototype._setError = function() {
        this._request = null;
        this._response = null;
        this._responseHeaders = null;
        this._responseParts = null;
      };
      XMLHttpRequest3.prototype._parseUrl = function(urlString, user, password) {
        var absoluteUrl = this.nodejsBaseUrl == null ? urlString : url.resolve(this.nodejsBaseUrl, urlString);
        var xhrUrl = url.parse(absoluteUrl, false, true);
        xhrUrl.hash = null;
        var _a = (xhrUrl.auth || "").split(":"), xhrUser = _a[0], xhrPassword = _a[1];
        if (xhrUser || xhrPassword || user || password) {
          xhrUrl.auth = (user || xhrUser || "") + ":" + (password || xhrPassword || "");
        }
        return xhrUrl;
      };
      XMLHttpRequest3.prototype._parseResponseHeaders = function(response) {
        this._responseHeaders = {};
        for (var name_1 in response.headers) {
          var loweredName = name_1.toLowerCase();
          if (this._privateHeaders[loweredName]) {
            continue;
          }
          this._responseHeaders[loweredName] = response.headers[name_1];
        }
        if (this._mimeOverride != null) {
          this._responseHeaders["content-type"] = this._mimeOverride;
        }
      };
      XMLHttpRequest3.prototype._parseResponse = function() {
        var buffer2 = Buffer2.concat(this._responseParts);
        this._responseParts = null;
        switch (this.responseType) {
          case "json":
            this.responseText = null;
            try {
              this.response = JSON.parse(buffer2.toString("utf-8"));
            } catch (_a) {
              this.response = null;
            }
            return;
          case "buffer":
            this.responseText = null;
            this.response = buffer2;
            return;
          case "arraybuffer":
            this.responseText = null;
            var arrayBuffer = new ArrayBuffer(buffer2.length);
            var view = new Uint8Array(arrayBuffer);
            for (var i5 = 0; i5 < buffer2.length; i5++) {
              view[i5] = buffer2[i5];
            }
            this.response = arrayBuffer;
            return;
          case "text":
          default:
            try {
              this.responseText = buffer2.toString(this._parseResponseEncoding());
            } catch (_b) {
              this.responseText = buffer2.toString("binary");
            }
            this.response = this.responseText;
        }
      };
      XMLHttpRequest3.prototype._parseResponseEncoding = function() {
        return /;\s*charset=(.*)$/.exec(this._responseHeaders["content-type"] || "")[1] || "utf-8";
      };
      XMLHttpRequest3.ProgressEvent = progress_event_1.ProgressEvent;
      XMLHttpRequest3.InvalidStateError = errors_1.InvalidStateError;
      XMLHttpRequest3.NetworkError = errors_1.NetworkError;
      XMLHttpRequest3.SecurityError = errors_1.SecurityError;
      XMLHttpRequest3.SyntaxError = errors_1.SyntaxError;
      XMLHttpRequest3.XMLHttpRequestUpload = xml_http_request_upload_1.XMLHttpRequestUpload;
      XMLHttpRequest3.UNSENT = 0;
      XMLHttpRequest3.OPENED = 1;
      XMLHttpRequest3.HEADERS_RECEIVED = 2;
      XMLHttpRequest3.LOADING = 3;
      XMLHttpRequest3.DONE = 4;
      XMLHttpRequest3.cookieJar = Cookie.CookieJar();
      return XMLHttpRequest3;
    }(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
    exports.XMLHttpRequest = XMLHttpRequest2;
    XMLHttpRequest2.prototype.nodejsHttpAgent = http.globalAgent;
    XMLHttpRequest2.prototype.nodejsHttpsAgent = https.globalAgent;
    XMLHttpRequest2.prototype.nodejsBaseUrl = null;
  }
});

// node_modules/xhr2-cookies/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/xhr2-cookies/dist/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function __export2(m5) {
      for (var p5 in m5)
        if (!exports.hasOwnProperty(p5))
          exports[p5] = m5[p5];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_xml_http_request());
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    exports.XMLHttpRequestEventTarget = xml_http_request_event_target_1.XMLHttpRequestEventTarget;
  }
});

// node_modules/ethereum-cryptography/hash-utils.js
var require_hash_utils = __commonJS({
  "node_modules/ethereum-cryptography/hash-utils.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    function createHashFunction(hashConstructor) {
      return function(msg) {
        var hash = hashConstructor();
        hash.update(msg);
        return Buffer2.from(hash.digest());
      };
    }
    exports.createHashFunction = createHashFunction;
  }
});

// node_modules/ethereum-cryptography/keccak.js
var require_keccak3 = __commonJS({
  "node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var hash_utils_1 = require_hash_utils();
    var createKeccakHash = require_js();
    exports.keccak224 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak224");
    });
    exports.keccak256 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak256");
    });
    exports.keccak384 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak384");
    });
    exports.keccak512 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak512");
    });
  }
});

// node_modules/secp256k1/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/secp256k1/lib/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var errors2 = {
      IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
      TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
      TWEAK_MUL: "The tweak was out of range or equal to zero",
      CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
      SECKEY_INVALID: "Private Key is invalid",
      PUBKEY_PARSE: "Public Key could not be parsed",
      PUBKEY_SERIALIZE: "Public Key serialization error",
      PUBKEY_COMBINE: "The sum of the public keys is not valid",
      SIG_PARSE: "Signature could not be parsed",
      SIGN: "The nonce generation function failed, or the private key was invalid",
      RECOVER: "Public key could not be recover",
      ECDH: "Scalar was invalid (zero or overflow)"
    };
    function assert3(cond, msg) {
      if (!cond)
        throw new Error(msg);
    }
    function isUint8Array(name, value, length) {
      assert3(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);
      if (length !== void 0) {
        if (Array.isArray(length)) {
          const numbers = length.join(", ");
          const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
          assert3(length.includes(value.length), msg);
        } else {
          const msg = `Expected ${name} to be an Uint8Array with length ${length}`;
          assert3(value.length === length, msg);
        }
      }
    }
    function isCompressed(value) {
      assert3(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
    }
    function getAssertedOutput(output = (len) => new Uint8Array(len), length) {
      if (typeof output === "function")
        output = output(length);
      isUint8Array("output", output, length);
      return output;
    }
    function toTypeString(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    module.exports = (secp256k1) => {
      return {
        contextRandomize(seed) {
          assert3(
            seed === null || seed instanceof Uint8Array,
            "Expected seed to be an Uint8Array or null"
          );
          if (seed !== null)
            isUint8Array("seed", seed, 32);
          switch (secp256k1.contextRandomize(seed)) {
            case 1:
              throw new Error(errors2.CONTEXT_RANDOMIZE_UNKNOW);
          }
        },
        privateKeyVerify(seckey) {
          isUint8Array("private key", seckey, 32);
          return secp256k1.privateKeyVerify(seckey) === 0;
        },
        privateKeyNegate(seckey) {
          isUint8Array("private key", seckey, 32);
          switch (secp256k1.privateKeyNegate(seckey)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        privateKeyTweakAdd(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors2.TWEAK_ADD);
          }
        },
        privateKeyTweakMul(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors2.TWEAK_MUL);
          }
        },
        publicKeyVerify(pubkey) {
          isUint8Array("public key", pubkey, [33, 65]);
          return secp256k1.publicKeyVerify(pubkey) === 0;
        },
        publicKeyCreate(seckey, compressed = true, output) {
          isUint8Array("private key", seckey, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCreate(output, seckey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.SECKEY_INVALID);
            case 2:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyConvert(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyConvert(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyNegate(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyNegate(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
            case 3:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyCombine(pubkeys, compressed = true, output) {
          assert3(Array.isArray(pubkeys), "Expected public keys to be an Array");
          assert3(pubkeys.length > 0, "Expected public keys array will have more than zero items");
          for (const pubkey of pubkeys) {
            isUint8Array("public key", pubkey, [33, 65]);
          }
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCombine(output, pubkeys)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.PUBKEY_COMBINE);
            case 3:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.TWEAK_ADD);
          }
        },
        publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.TWEAK_MUL);
          }
        },
        signatureNormalize(sig) {
          isUint8Array("signature", sig, 64);
          switch (secp256k1.signatureNormalize(sig)) {
            case 0:
              return sig;
            case 1:
              throw new Error(errors2.SIG_PARSE);
          }
        },
        signatureExport(sig, output) {
          isUint8Array("signature", sig, 64);
          output = getAssertedOutput(output, 72);
          const obj = { output, outputlen: 72 };
          switch (secp256k1.signatureExport(obj, sig)) {
            case 0:
              return output.slice(0, obj.outputlen);
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        signatureImport(sig, output) {
          isUint8Array("signature", sig);
          output = getAssertedOutput(output, 64);
          switch (secp256k1.signatureImport(output, sig)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        ecdsaSign(msg32, seckey, options = {}, output) {
          isUint8Array("message", msg32, 32);
          isUint8Array("private key", seckey, 32);
          assert3(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.noncefn !== void 0)
            assert3(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
          output = getAssertedOutput(output, 64);
          const obj = { signature: output, recid: null };
          switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
            case 0:
              return obj;
            case 1:
              throw new Error(errors2.SIGN);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        ecdsaVerify(sig, msg32, pubkey) {
          isUint8Array("signature", sig, 64);
          isUint8Array("message", msg32, 32);
          isUint8Array("public key", pubkey, [33, 65]);
          switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
            case 0:
              return true;
            case 3:
              return false;
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.PUBKEY_PARSE);
          }
        },
        ecdsaRecover(sig, recid, msg32, compressed = true, output) {
          isUint8Array("signature", sig, 64);
          assert3(
            toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
            "Expected recovery id to be a Number within interval [0, 3]"
          );
          isUint8Array("message", msg32, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.RECOVER);
            case 3:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        ecdh(pubkey, seckey, options = {}, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("private key", seckey, 32);
          assert3(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.hashfn !== void 0) {
            assert3(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
            if (options.xbuf !== void 0)
              isUint8Array("options.xbuf", options.xbuf, 32);
            if (options.ybuf !== void 0)
              isUint8Array("options.ybuf", options.ybuf, 32);
            isUint8Array("output", output);
          } else {
            output = getAssertedOutput(output, 32);
          }
          switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.ECDH);
          }
        }
      };
    };
  }
});

// node_modules/secp256k1/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/secp256k1/lib/elliptic.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    var BN2 = ecparams.n.constructor;
    function loadCompressedPublicKey(first2, xbuf) {
      let x5 = new BN2(xbuf);
      if (x5.cmp(ecparams.p) >= 0)
        return null;
      x5 = x5.toRed(ecparams.red);
      let y5 = x5.redSqr().redIMul(x5).redIAdd(ecparams.b).redSqrt();
      if (first2 === 3 !== y5.isOdd())
        y5 = y5.redNeg();
      return ec.keyPair({ pub: { x: x5, y: y5 } });
    }
    function loadUncompressedPublicKey(first2, xbuf, ybuf) {
      let x5 = new BN2(xbuf);
      let y5 = new BN2(ybuf);
      if (x5.cmp(ecparams.p) >= 0 || y5.cmp(ecparams.p) >= 0)
        return null;
      x5 = x5.toRed(ecparams.red);
      y5 = y5.toRed(ecparams.red);
      if ((first2 === 6 || first2 === 7) && y5.isOdd() !== (first2 === 7))
        return null;
      const x32 = x5.redSqr().redIMul(x5);
      if (!y5.redSqr().redISub(x32.redIAdd(ecparams.b)).isZero())
        return null;
      return ec.keyPair({ pub: { x: x5, y: y5 } });
    }
    function loadPublicKey(pubkey) {
      const first2 = pubkey[0];
      switch (first2) {
        case 2:
        case 3:
          if (pubkey.length !== 33)
            return null;
          return loadCompressedPublicKey(first2, pubkey.subarray(1, 33));
        case 4:
        case 6:
        case 7:
          if (pubkey.length !== 65)
            return null;
          return loadUncompressedPublicKey(first2, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
        default:
          return null;
      }
    }
    function savePublicKey(output, point) {
      const pubkey = point.encode(null, output.length === 33);
      for (let i5 = 0; i5 < output.length; ++i5)
        output[i5] = pubkey[i5];
    }
    module.exports = {
      contextRandomize() {
        return 0;
      },
      privateKeyVerify(seckey) {
        const bn = new BN2(seckey);
        return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
      },
      privateKeyNegate(seckey) {
        const bn = new BN2(seckey);
        const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
        seckey.set(negate);
        return 0;
      },
      privateKeyTweakAdd(seckey, tweak) {
        const bn = new BN2(tweak);
        if (bn.cmp(ecparams.n) >= 0)
          return 1;
        bn.iadd(new BN2(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn.isub(ecparams.n);
        if (bn.isZero())
          return 1;
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      privateKeyTweakMul(seckey, tweak) {
        let bn = new BN2(tweak);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        bn.imul(new BN2(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn = bn.umod(ecparams.n);
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      publicKeyVerify(pubkey) {
        const pair = loadPublicKey(pubkey);
        return pair === null ? 1 : 0;
      },
      publicKeyCreate(output, seckey) {
        const bn = new BN2(seckey);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        const point = ec.keyFromPrivate(seckey).getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyConvert(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyNegate(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        point.y = point.y.redNeg();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyCombine(output, pubkeys) {
        const pairs2 = new Array(pubkeys.length);
        for (let i5 = 0; i5 < pubkeys.length; ++i5) {
          pairs2[i5] = loadPublicKey(pubkeys[i5]);
          if (pairs2[i5] === null)
            return 1;
        }
        let point = pairs2[0].getPublic();
        for (let i5 = 1; i5 < pairs2.length; ++i5)
          point = point.add(pairs2[i5].pub);
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakAdd(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN2(tweak);
        if (tweak.cmp(ecparams.n) >= 0)
          return 2;
        const point = pair.getPublic().add(ecparams.g.mul(tweak));
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakMul(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN2(tweak);
        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
          return 2;
        const point = pair.getPublic().mul(tweak);
        savePublicKey(output, point);
        return 0;
      },
      signatureNormalize(sig) {
        const r6 = new BN2(sig.subarray(0, 32));
        const s5 = new BN2(sig.subarray(32, 64));
        if (r6.cmp(ecparams.n) >= 0 || s5.cmp(ecparams.n) >= 0)
          return 1;
        if (s5.cmp(ec.nh) === 1) {
          sig.set(ecparams.n.sub(s5).toArrayLike(Uint8Array, "be", 32), 32);
        }
        return 0;
      },
      signatureExport(obj, sig) {
        const sigR = sig.subarray(0, 32);
        const sigS = sig.subarray(32, 64);
        if (new BN2(sigR).cmp(ecparams.n) >= 0)
          return 1;
        if (new BN2(sigS).cmp(ecparams.n) >= 0)
          return 1;
        const { output } = obj;
        let r6 = output.subarray(4, 4 + 33);
        r6[0] = 0;
        r6.set(sigR, 1);
        let lenR = 33;
        let posR = 0;
        for (; lenR > 1 && r6[posR] === 0 && !(r6[posR + 1] & 128); --lenR, ++posR)
          ;
        r6 = r6.subarray(posR);
        if (r6[0] & 128)
          return 1;
        if (lenR > 1 && r6[0] === 0 && !(r6[1] & 128))
          return 1;
        let s5 = output.subarray(6 + 33, 6 + 33 + 33);
        s5[0] = 0;
        s5.set(sigS, 1);
        let lenS = 33;
        let posS = 0;
        for (; lenS > 1 && s5[posS] === 0 && !(s5[posS + 1] & 128); --lenS, ++posS)
          ;
        s5 = s5.subarray(posS);
        if (s5[0] & 128)
          return 1;
        if (lenS > 1 && s5[0] === 0 && !(s5[1] & 128))
          return 1;
        obj.outputlen = 6 + lenR + lenS;
        output[0] = 48;
        output[1] = obj.outputlen - 2;
        output[2] = 2;
        output[3] = r6.length;
        output.set(r6, 4);
        output[4 + lenR] = 2;
        output[5 + lenR] = s5.length;
        output.set(s5, 6 + lenR);
        return 0;
      },
      signatureImport(output, sig) {
        if (sig.length < 8)
          return 1;
        if (sig.length > 72)
          return 1;
        if (sig[0] !== 48)
          return 1;
        if (sig[1] !== sig.length - 2)
          return 1;
        if (sig[2] !== 2)
          return 1;
        const lenR = sig[3];
        if (lenR === 0)
          return 1;
        if (5 + lenR >= sig.length)
          return 1;
        if (sig[4 + lenR] !== 2)
          return 1;
        const lenS = sig[5 + lenR];
        if (lenS === 0)
          return 1;
        if (6 + lenR + lenS !== sig.length)
          return 1;
        if (sig[4] & 128)
          return 1;
        if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
          return 1;
        if (sig[lenR + 6] & 128)
          return 1;
        if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
          return 1;
        let sigR = sig.subarray(4, 4 + lenR);
        if (sigR.length === 33 && sigR[0] === 0)
          sigR = sigR.subarray(1);
        if (sigR.length > 32)
          return 1;
        let sigS = sig.subarray(6 + lenR);
        if (sigS.length === 33 && sigS[0] === 0)
          sigS = sigS.slice(1);
        if (sigS.length > 32)
          throw new Error("S length is too long");
        let r6 = new BN2(sigR);
        if (r6.cmp(ecparams.n) >= 0)
          r6 = new BN2(0);
        let s5 = new BN2(sig.subarray(6 + lenR));
        if (s5.cmp(ecparams.n) >= 0)
          s5 = new BN2(0);
        output.set(r6.toArrayLike(Uint8Array, "be", 32), 0);
        output.set(s5.toArrayLike(Uint8Array, "be", 32), 32);
        return 0;
      },
      ecdsaSign(obj, message, seckey, data, noncefn) {
        if (noncefn) {
          const _noncefn = noncefn;
          noncefn = (counter) => {
            const nonce = _noncefn(message, seckey, null, data, counter);
            const isValid = nonce instanceof Uint8Array && nonce.length === 32;
            if (!isValid)
              throw new Error("This is the way");
            return new BN2(nonce);
          };
        }
        const d5 = new BN2(seckey);
        if (d5.cmp(ecparams.n) >= 0 || d5.isZero())
          return 1;
        let sig;
        try {
          sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
        } catch (err) {
          return 1;
        }
        obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
        obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
        obj.recid = sig.recoveryParam;
        return 0;
      },
      ecdsaVerify(sig, msg32, pubkey) {
        const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
        const sigr = new BN2(sigObj.r);
        const sigs = new BN2(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero())
          return 3;
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 2;
        const point = pair.getPublic();
        const isValid = ec.verify(msg32, sigObj, point);
        return isValid ? 0 : 3;
      },
      ecdsaRecover(output, sig, recid, msg32) {
        const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
        const sigr = new BN2(sigObj.r);
        const sigs = new BN2(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigr.isZero() || sigs.isZero())
          return 2;
        let point;
        try {
          point = ec.recoverPubKey(msg32, sigObj, recid);
        } catch (err) {
          return 2;
        }
        savePublicKey(output, point);
        return 0;
      },
      ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const scalar = new BN2(seckey);
        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
          return 2;
        const point = pair.getPublic().mul(scalar);
        if (hashfn === void 0) {
          const data2 = point.encode(null, true);
          const sha2562 = ec.hash().update(data2).digest();
          for (let i5 = 0; i5 < 32; ++i5)
            output[i5] = sha2562[i5];
        } else {
          if (!xbuf)
            xbuf = new Uint8Array(32);
          const x5 = point.getX().toArray("be", 32);
          for (let i5 = 0; i5 < 32; ++i5)
            xbuf[i5] = x5[i5];
          if (!ybuf)
            ybuf = new Uint8Array(32);
          const y5 = point.getY().toArray("be", 32);
          for (let i5 = 0; i5 < 32; ++i5)
            ybuf[i5] = y5[i5];
          const hash = hashfn(xbuf, ybuf, data);
          const isValid = hash instanceof Uint8Array && hash.length === output.length;
          if (!isValid)
            return 2;
          output.set(hash);
        }
        return 0;
      }
    };
  }
});

// node_modules/secp256k1/elliptic.js
var require_elliptic3 = __commonJS({
  "node_modules/secp256k1/elliptic.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_lib3()(require_elliptic2());
  }
});

// node_modules/ethereum-cryptography/random.js
var require_random = __commonJS({
  "node_modules/ethereum-cryptography/random.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var randombytes = require_browser();
    function getRandomBytes(bytes) {
      return new Promise(function(resolve, reject) {
        randombytes(bytes, function(err, resp) {
          if (err) {
            reject(err);
            return;
          }
          resolve(resp);
        });
      });
    }
    exports.getRandomBytes = getRandomBytes;
    function getRandomBytesSync(bytes) {
      return randombytes(bytes);
    }
    exports.getRandomBytesSync = getRandomBytesSync;
  }
});

// node_modules/ethereum-cryptography/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/ethereum-cryptography/secp256k1.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P5, generator) {
      function adopt(value) {
        return value instanceof P5 ? value : new P5(function(resolve) {
          resolve(value);
        });
      }
      return new (P5 || (P5 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _6 = { label: 0, sent: function() {
        if (t5[0] & 1)
          throw t5[1];
        return t5[1];
      }, trys: [], ops: [] }, f5, y5, t5, g5;
      return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
        return this;
      }), g5;
      function verb(n3) {
        return function(v5) {
          return step([n3, v5]);
        };
      }
      function step(op) {
        if (f5)
          throw new TypeError("Generator is already executing.");
        while (_6)
          try {
            if (f5 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
              return t5;
            if (y5 = 0, t5)
              op = [op[0] & 2, t5.value];
            switch (op[0]) {
              case 0:
              case 1:
                t5 = op;
                break;
              case 4:
                _6.label++;
                return { value: op[1], done: false };
              case 5:
                _6.label++;
                y5 = op[1];
                op = [0];
                continue;
              case 7:
                op = _6.ops.pop();
                _6.trys.pop();
                continue;
              default:
                if (!(t5 = _6.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _6 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                  _6.label = op[1];
                  break;
                }
                if (op[0] === 6 && _6.label < t5[1]) {
                  _6.label = t5[1];
                  t5 = op;
                  break;
                }
                if (t5 && _6.label < t5[2]) {
                  _6.label = t5[2];
                  _6.ops.push(op);
                  break;
                }
                if (t5[2])
                  _6.ops.pop();
                _6.trys.pop();
                continue;
            }
            op = body.call(thisArg, _6);
          } catch (e5) {
            op = [6, e5];
            y5 = 0;
          } finally {
            f5 = t5 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    function __export2(m5) {
      for (var p5 in m5)
        if (!exports.hasOwnProperty(p5))
          exports[p5] = m5[p5];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var secp256k1_1 = require_elliptic3();
    var random_1 = require_random();
    var SECP256K1_PRIVATE_KEY_SIZE = 32;
    function createPrivateKey() {
      return __awaiter2(this, void 0, void 0, function() {
        var pk;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (false)
                return [3, 2];
              return [4, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
            case 1:
              pk = _a.sent();
              if (secp256k1_1.privateKeyVerify(pk)) {
                return [2, pk];
              }
              return [3, 0];
            case 2:
              return [2];
          }
        });
      });
    }
    exports.createPrivateKey = createPrivateKey;
    function createPrivateKeySync() {
      while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_1.privateKeyVerify(pk)) {
          return pk;
        }
      }
    }
    exports.createPrivateKeySync = createPrivateKeySync;
    __export2(require_elliptic3());
  }
});

// node_modules/ethereumjs-util/node_modules/bn.js/lib/bn.js
var require_bn9 = __commonJS({
  "node_modules/ethereumjs-util/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base2, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e5) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i5 = number.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number[i5] | number[i5 - 1] << 8 | number[i5 - 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number.length; i5 += 3) {
            w6 = number[i5] | number[i5 + 1] << 8 | number[i5 + 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off3 = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number.length; i5 += 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN2.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i5, number.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r6 = new BN2(null);
        this.copy(r6);
        return r6;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength3; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN2.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN2.prototype._countBits(N4) - 1;
        for (var i5 = 0; i5 < N4; i5++) {
          t5[i5] = this.revBin(i5, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i5 = 0; i5 < N4; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s5 = 1; s5 < N4; s5 <<= 1) {
          var l5 = s5 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s5; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s5];
              var io = itws[p5 + j5 + s5];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s5] = re - ro;
              itws[p5 + j5 + s5] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N4 = Math.max(m5, n3) | 1;
        var odd = N4 & 1;
        var i5 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N4 - i5 - 1];
          rws[N4 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N4 - i5 - 1];
          iws[N4 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N4) * 8192 + Math.round(ws[2 * i5] / N4) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N4; ++i5) {
          rws[i5] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i5 = 0; i5 < N4; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _6 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _6, rwst, iwst, N4, rbt);
        this.transform(nrws, _6, nrwst, niwst, N4, rbt);
        for (var i5 = 0; i5 < N4; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _6, N4, rbt);
        this.conjugate(rmws, _6, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN2(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s5 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s5] = this.words[i5];
          }
          for (i5 = 0; i5 < s5; i5++) {
            this.words[i5] = 0;
          }
          this.length += s5;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s5 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s5;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s5; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s5;
        }
        if (s5 === 0) {
        } else if (this.length > s5) {
          this.length -= s5;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s5];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5)
          return false;
        var w6 = this.words[s5];
        return !!(w6 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s5) {
          return this;
        }
        if (r6 !== 0) {
          s5++;
        }
        this.length = Math.min(s5, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN2(1);
        var B4 = new BN2(0);
        var C4 = new BN2(0);
        var D3 = new BN2(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B4.isOdd()) {
                A6.iadd(yp);
                B4.isub(xp);
              }
              A6.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D3.isOdd()) {
                C4.iadd(yp);
                D3.isub(xp);
              }
              C4.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B4.isub(D3);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D3.isub(B4);
          }
        }
        return {
          a: C4,
          b: D3,
          gcd: y5.iushln(g5)
        };
      };
      BN2.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5) {
          this._expand(s5 + 1);
          this.words[s5] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s5; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN2(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN2._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s5 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s5++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z5 = this.m.bitLength();
        z5 = new BN2(2 * z5 * z5).toRed(this);
        while (this.pow(z5, lpow).cmp(nOne) !== 0) {
          z5.redIAdd(nOne);
        }
        var c5 = this.pow(z5, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s5;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert3(i5 < m5);
          var b4 = this.pow(c5, new BN2(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/ethereumjs-util/dist/secp256k1-lib/index.js
var require_secp256k1_lib = __commonJS({
  "node_modules/ethereumjs-util/dist/secp256k1-lib/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var BN2 = require_bn9();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    exports.privateKeyExport = function(privateKey, compressed) {
      var d5 = new BN2(privateKey);
      if (d5.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
      }
      var point = ec.g.mul(d5);
      return toPublicKey(point.getX(), point.getY(), compressed);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn = new BN2(privateKey);
      if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error("private key range is invalid");
      }
      return bn.invm(ecparams.n).toArrayLike(Buffer2, "be", 32);
    };
    exports.signatureImport = function(sigObj) {
      var r6 = new BN2(sigObj.r);
      if (r6.ucmp(ecparams.n) >= 0) {
        r6 = new BN2(0);
      }
      var s5 = new BN2(sigObj.s);
      if (s5.ucmp(ecparams.n) >= 0) {
        s5 = new BN2(0);
      }
      return Buffer2.concat([r6.toArrayLike(Buffer2, "be", 32), s5.toArrayLike(Buffer2, "be", 32)]);
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      var point = ec.keyFromPublic(publicKey);
      var scalar = new BN2(privateKey);
      if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error("scalar was invalid (zero or overflow)");
      }
      var shared = point.pub.mul(scalar);
      return toPublicKey(shared.getX(), shared.getY(), compressed);
    };
    var toPublicKey = function toPublicKey2(x5, y5, compressed) {
      var publicKey = void 0;
      if (compressed) {
        publicKey = Buffer2.alloc(33);
        publicKey[0] = y5.isOdd() ? 3 : 2;
        x5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 1);
      } else {
        publicKey = Buffer2.alloc(65);
        publicKey[0] = 4;
        x5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 1);
        y5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 33);
      }
      return publicKey;
    };
  }
});

// node_modules/ethereumjs-util/dist/secp256k1-lib/der.js
var require_der4 = __commonJS({
  "node_modules/ethereumjs-util/dist/secp256k1-lib/der.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer2.from([
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer2.from([
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey, compressed) {
      var result = Buffer2.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return null;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return null;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return null;
      if (length < index + lenb)
        return null;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return null;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return null;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return null;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureImportLax = function(signature) {
      var r6 = Buffer2.alloc(32, 0);
      var s5 = Buffer2.alloc(32, 0);
      var length = signature.length;
      var index = 0;
      if (signature[index++] !== 48) {
        return null;
      }
      var lenbyte = signature[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length) {
          return null;
        }
      }
      if (signature[index++] !== 2) {
        return null;
      }
      var rlen = signature[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          rlen = (rlen << 8) + signature[index];
        }
      }
      if (rlen > length - index) {
        return null;
      }
      var rindex = index;
      index += rlen;
      if (signature[index++] !== 2) {
        return null;
      }
      var slen = signature[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          slen = (slen << 8) + signature[index];
        }
      }
      if (slen > length - index) {
        return null;
      }
      var sindex = index;
      index += slen;
      for (; rlen > 0 && signature[rindex] === 0; rlen -= 1, rindex += 1) {
      }
      if (rlen > 32) {
        return null;
      }
      var rvalue = signature.slice(rindex, rindex + rlen);
      rvalue.copy(r6, 32 - rvalue.length);
      for (; slen > 0 && signature[sindex] === 0; slen -= 1, sindex += 1) {
      }
      if (slen > 32) {
        return null;
      }
      var svalue = signature.slice(sindex, sindex + slen);
      svalue.copy(s5, 32 - svalue.length);
      return { r: r6, s: s5 };
    };
  }
});

// node_modules/ethereumjs-util/dist/secp256k1-adapter.js
var require_secp256k1_adapter = __commonJS({
  "node_modules/ethereumjs-util/dist/secp256k1-adapter.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var secp256k1 = require_secp256k12();
    var secp256k1v3 = require_secp256k1_lib();
    var der = require_der4();
    var privateKeyVerify = function privateKeyVerify2(privateKey) {
      if (privateKey.length !== 32) {
        return false;
      }
      return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
    };
    var privateKeyExport = function privateKeyExport2(privateKey, compressed) {
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
      return der.privateKeyExport(privateKey, publicKey, compressed);
    };
    var privateKeyImport = function privateKeyImport2(privateKey) {
      privateKey = der.privateKeyImport(privateKey);
      if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
        return privateKey;
      }
      throw new Error("couldn't import from DER format");
    };
    var privateKeyNegate = function privateKeyNegate2(privateKey) {
      return Buffer2.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
    };
    var privateKeyModInverse = function privateKeyModInverse2(privateKey) {
      if (privateKey.length !== 32) {
        throw new Error("private key length is invalid");
      }
      return Buffer2.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
    };
    var privateKeyTweakAdd = function privateKeyTweakAdd2(privateKey, tweak) {
      return Buffer2.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
    };
    var privateKeyTweakMul = function privateKeyTweakMul2(privateKey, tweak) {
      return Buffer2.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
    };
    var publicKeyCreate = function publicKeyCreate2(privateKey, compressed) {
      return Buffer2.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
    };
    var publicKeyConvert = function publicKeyConvert2(publicKey, compressed) {
      return Buffer2.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
    };
    var publicKeyVerify = function publicKeyVerify2(publicKey) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
      }
      return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
    };
    var publicKeyTweakAdd = function publicKeyTweakAdd2(publicKey, tweak, compressed) {
      return Buffer2.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    var publicKeyTweakMul = function publicKeyTweakMul2(publicKey, tweak, compressed) {
      return Buffer2.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    var publicKeyCombine = function publicKeyCombine2(publicKeys, compressed) {
      var keys2 = [];
      publicKeys.forEach(function(publicKey) {
        keys2.push(Uint8Array.from(publicKey));
      });
      return Buffer2.from(secp256k1.publicKeyCombine(keys2, compressed));
    };
    var signatureNormalize = function signatureNormalize2(signature) {
      return Buffer2.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
    };
    var signatureExport = function signatureExport2(signature) {
      return Buffer2.from(secp256k1.signatureExport(Uint8Array.from(signature)));
    };
    var signatureImport = function signatureImport2(signature) {
      return Buffer2.from(secp256k1.signatureImport(Uint8Array.from(signature)));
    };
    var signatureImportLax = function signatureImportLax2(signature) {
      if (signature.length === 0) {
        throw new RangeError("signature length is invalid");
      }
      var sigObj = der.signatureImportLax(signature);
      if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
      }
      return secp256k1v3.signatureImport(sigObj);
    };
    var sign = function sign2(message, privateKey, options) {
      if (options === null) {
        throw new TypeError("options should be an Object");
      }
      var signOptions = void 0;
      if (options) {
        signOptions = {};
        if (options.data === null) {
          throw new TypeError("options.data should be a Buffer");
        }
        if (options.data) {
          if (options.data.length !== 32) {
            throw new RangeError("options.data length is invalid");
          }
          signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
          throw new TypeError("options.noncefn should be a Function");
        }
        if (options.noncefn) {
          signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
            var bufferAlgo = algo != null ? Buffer2.from(algo) : null;
            var bufferData = data != null ? Buffer2.from(data) : null;
            var buffer2 = Buffer2.from("");
            if (options.noncefn) {
              buffer2 = options.noncefn(Buffer2.from(message2), Buffer2.from(privateKey2), bufferAlgo, bufferData, attempt);
            }
            return Uint8Array.from(buffer2);
          };
        }
      }
      var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
      return {
        signature: Buffer2.from(sig.signature),
        recovery: sig.recid
      };
    };
    var verify = function verify2(message, signature, publicKey) {
      return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
    };
    var recover = function recover2(message, signature, recid, compressed) {
      return Buffer2.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
    };
    var ecdh = function ecdh2(publicKey, privateKey) {
      return Buffer2.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
    };
    var ecdhUnsafe = function ecdhUnsafe2(publicKey, privateKey, compressed) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError("public key length is invalid");
      }
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      return Buffer2.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
    };
    module.exports = {
      privateKeyVerify,
      privateKeyExport,
      privateKeyImport,
      privateKeyNegate,
      privateKeyModInverse,
      privateKeyTweakAdd,
      privateKeyTweakMul,
      publicKeyCreate,
      publicKeyConvert,
      publicKeyVerify,
      publicKeyTweakAdd,
      publicKeyTweakMul,
      publicKeyCombine,
      signatureNormalize,
      signatureExport,
      signatureImport,
      signatureImportLax,
      sign,
      verify,
      recover,
      ecdh,
      ecdhUnsafe
    };
  }
});

// node-modules-polyfills:assert
var assert_exports = {};
__export(assert_exports, {
  AssertionError: () => AssertionError,
  assert: () => ok,
  deepEqual: () => deepEqual,
  deepStrictEqual: () => deepStrictEqual,
  default: () => assert_default,
  doesNotThrow: () => doesNotThrow,
  equal: () => equal,
  fail: () => fail,
  ifError: () => ifError,
  notDeepEqual: () => notDeepEqual,
  notDeepStrictEqual: () => notDeepStrictEqual,
  notEqual: () => notEqual,
  notStrictEqual: () => notStrictEqual,
  ok: () => ok,
  strictEqual: () => strictEqual,
  throws: () => throws
});
function compare5(a5, b4) {
  if (a5 === b4) {
    return 0;
  }
  var x5 = a5.length;
  var y5 = b4.length;
  for (var i5 = 0, len = Math.min(x5, y5); i5 < len; ++i5) {
    if (a5[i5] !== b4[i5]) {
      x5 = a5[i5];
      y5 = b4[i5];
      break;
    }
  }
  if (x5 < y5) {
    return -1;
  }
  if (y5 < x5) {
    return 1;
  }
  return 0;
}
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== "undefined") {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = function() {
    return function foo() {
    }.name === "foo";
  }();
}
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer2(arrbuf)) {
    return false;
  }
  if (typeof globalThis.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert2(value, message) {
  if (!value)
    fail(value, true, message, "==", ok);
}
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
function AssertionError(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err = new Error();
    if (err.stack) {
      var out = err.stack;
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
function truncate(s5, n3) {
  if (typeof s5 === "string") {
    return s5.length < n3 ? s5 : s5.slice(0, n3);
  } else {
    return s5;
  }
}
function inspect3(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect2(something);
  }
  var rawname = getName(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage(self2) {
  return truncate(inspect3(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect3(self2.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
function ok(value, message) {
  if (!value)
    fail(value, true, message, "==", ok);
}
function equal(actual, expected, message) {
  if (actual != expected)
    fail(actual, expected, message, "==", equal);
}
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", notEqual);
  }
}
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", deepEqual);
  }
}
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
  }
}
function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer2(actual) && isBuffer2(expected)) {
    return compare5(actual, expected) === 0;
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare5(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer2(actual) !== isBuffer2(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a5, b4, strict, actualVisitedObjects) {
  if (a5 === null || a5 === void 0 || b4 === null || b4 === void 0)
    return false;
  if (isPrimitive(a5) || isPrimitive(b4))
    return a5 === b4;
  if (strict && Object.getPrototypeOf(a5) !== Object.getPrototypeOf(b4))
    return false;
  var aIsArgs = isArguments(a5);
  var bIsArgs = isArguments(b4);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a5 = pSlice.call(a5);
    b4 = pSlice.call(b4);
    return _deepEqual(a5, b4, strict);
  }
  var ka = objectKeys2(a5);
  var kb = objectKeys2(b4);
  var key, i5;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i5 = ka.length - 1; i5 >= 0; i5--) {
    if (ka[i5] !== kb[i5])
      return false;
  }
  for (i5 = ka.length - 1; i5 >= 0; i5--) {
    key = ka[i5];
    if (!_deepEqual(a5[key], b4[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", notDeepEqual);
  }
}
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
  }
}
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", strictEqual);
  }
}
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", notStrictEqual);
  }
}
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e5) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block) {
  var error2;
  try {
    block();
  } catch (e5) {
    error2 = e5;
  }
  return error2;
}
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
function throws(block, error2, message) {
  _throws(true, block, error2, message);
}
function doesNotThrow(block, error2, message) {
  _throws(false, block, error2, message);
}
function ifError(err) {
  if (err)
    throw err;
}
var hasOwn, objectKeys2, pSlice, _functionsHaveNames, assert_default, regex;
var init_assert = __esm({
  "node-modules-polyfills:assert"() {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    init_buffer2();
    init_util();
    hasOwn = Object.prototype.hasOwnProperty;
    objectKeys2 = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        if (hasOwn.call(obj, key))
          keys2.push(key);
      }
      return keys2;
    };
    pSlice = Array.prototype.slice;
    assert_default = assert2;
    regex = /\s*function\s+([^\(\s]*)\s*/;
    assert2.AssertionError = AssertionError;
    inherits_default(AssertionError, Error);
    assert2.fail = fail;
    assert2.ok = ok;
    assert2.equal = equal;
    assert2.notEqual = notEqual;
    assert2.deepEqual = deepEqual;
    assert2.deepStrictEqual = deepStrictEqual;
    assert2.notDeepEqual = notDeepEqual;
    assert2.notDeepStrictEqual = notDeepStrictEqual;
    assert2.strictEqual = strictEqual;
    assert2.notStrictEqual = notStrictEqual;
    assert2.throws = throws;
    assert2.doesNotThrow = doesNotThrow;
    assert2.ifError = ifError;
  }
});

// node-modules-polyfills-commonjs:assert
var require_assert = __commonJS({
  "node-modules-polyfills-commonjs:assert"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_assert(), __toCommonJS(assert_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/rlp/dist.browser/index.js
var require_dist6 = __commonJS({
  "node_modules/rlp/dist.browser/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLength = exports.decode = exports.encode = void 0;
    var bn_js_1 = __importDefault2(require_bn3());
    function encode2(input) {
      if (Array.isArray(input)) {
        var output = [];
        for (var i5 = 0; i5 < input.length; i5++) {
          output.push(encode2(input[i5]));
        }
        var buf = Buffer2.concat(output);
        return Buffer2.concat([encodeLength(buf.length, 192), buf]);
      } else {
        var inputBuf = toBuffer(input);
        return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : Buffer2.concat([encodeLength(inputBuf.length, 128), inputBuf]);
      }
    }
    exports.encode = encode2;
    function safeParseInt(v5, base2) {
      if (v5[0] === "0" && v5[1] === "0") {
        throw new Error("invalid RLP: extra zeros");
      }
      return parseInt(v5, base2);
    }
    function encodeLength(len, offset) {
      if (len < 56) {
        return Buffer2.from([len + offset]);
      } else {
        var hexLength = intToHex(len);
        var lLength = hexLength.length / 2;
        var firstByte = intToHex(offset + 55 + lLength);
        return Buffer2.from(firstByte + hexLength, "hex");
      }
    }
    function decode(input, stream) {
      if (stream === void 0) {
        stream = false;
      }
      if (!input || input.length === 0) {
        return Buffer2.from([]);
      }
      var inputBuffer = toBuffer(input);
      var decoded = _decode(inputBuffer);
      if (stream) {
        return decoded;
      }
      if (decoded.remainder.length !== 0) {
        throw new Error("invalid remainder");
      }
      return decoded.data;
    }
    exports.decode = decode;
    function getLength(input) {
      if (!input || input.length === 0) {
        return Buffer2.from([]);
      }
      var inputBuffer = toBuffer(input);
      var firstByte = inputBuffer[0];
      if (firstByte <= 127) {
        return inputBuffer.length;
      } else if (firstByte <= 183) {
        return firstByte - 127;
      } else if (firstByte <= 191) {
        return firstByte - 182;
      } else if (firstByte <= 247) {
        return firstByte - 191;
      } else {
        var llength = firstByte - 246;
        var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString("hex"), 16);
        return llength + length_1;
      }
    }
    exports.getLength = getLength;
    function _decode(input) {
      var length, llength, data, innerRemainder, d5;
      var decoded = [];
      var firstByte = input[0];
      if (firstByte <= 127) {
        return {
          data: input.slice(0, 1),
          remainder: input.slice(1)
        };
      } else if (firstByte <= 183) {
        length = firstByte - 127;
        if (firstByte === 128) {
          data = Buffer2.from([]);
        } else {
          data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 128) {
          throw new Error("invalid rlp encoding: byte must be less 0x80");
        }
        return {
          data,
          remainder: input.slice(length)
        };
      } else if (firstByte <= 191) {
        llength = firstByte - 182;
        if (input.length - 1 < llength) {
          throw new Error("invalid RLP: not enough bytes for string length");
        }
        length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
        if (length <= 55) {
          throw new Error("invalid RLP: expected string length to be greater than 55");
        }
        data = input.slice(llength, length + llength);
        if (data.length < length) {
          throw new Error("invalid RLP: not enough bytes for string");
        }
        return {
          data,
          remainder: input.slice(length + llength)
        };
      } else if (firstByte <= 247) {
        length = firstByte - 191;
        innerRemainder = input.slice(1, length);
        while (innerRemainder.length) {
          d5 = _decode(innerRemainder);
          decoded.push(d5.data);
          innerRemainder = d5.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(length)
        };
      } else {
        llength = firstByte - 246;
        length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
        var totalLength = llength + length;
        if (totalLength > input.length) {
          throw new Error("invalid rlp: total length is larger than the data");
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
          throw new Error("invalid rlp, List has a invalid length");
        }
        while (innerRemainder.length) {
          d5 = _decode(innerRemainder);
          decoded.push(d5.data);
          innerRemainder = d5.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(totalLength)
        };
      }
    }
    function isHexPrefixed(str) {
      return str.slice(0, 2) === "0x";
    }
    function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    }
    function intToHex(integer) {
      if (integer < 0) {
        throw new Error("Invalid integer as argument, must be unsigned!");
      }
      var hex = integer.toString(16);
      return hex.length % 2 ? "0" + hex : hex;
    }
    function padToEven(a5) {
      return a5.length % 2 ? "0" + a5 : a5;
    }
    function intToBuffer2(integer) {
      var hex = intToHex(integer);
      return Buffer2.from(hex, "hex");
    }
    function toBuffer(v5) {
      if (!Buffer2.isBuffer(v5)) {
        if (typeof v5 === "string") {
          if (isHexPrefixed(v5)) {
            return Buffer2.from(padToEven(stripHexPrefix(v5)), "hex");
          } else {
            return Buffer2.from(v5);
          }
        } else if (typeof v5 === "number" || typeof v5 === "bigint") {
          if (!v5) {
            return Buffer2.from([]);
          } else {
            return intToBuffer2(v5);
          }
        } else if (v5 === null || v5 === void 0) {
          return Buffer2.from([]);
        } else if (v5 instanceof Uint8Array) {
          return Buffer2.from(v5);
        } else if (bn_js_1.default.isBN(v5)) {
          return Buffer2.from(v5.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v5;
    }
  }
});

// node_modules/is-hex-prefixed/src/index.js
var require_src2 = __commonJS({
  "node_modules/is-hex-prefixed/src/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str + ", while checking isHexPrefixed.");
      }
      return str.slice(0, 2) === "0x";
    };
  }
});

// node_modules/strip-hex-prefix/src/index.js
var require_src3 = __commonJS({
  "node_modules/strip-hex-prefix/src/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var isHexPrefixed = require_src2();
    module.exports = function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
  }
});

// node_modules/ethjs-util/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/ethjs-util/lib/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var isHexPrefixed = require_src2();
    var stripHexPrefix = require_src3();
    function padToEven(value) {
      var a5 = value;
      if (typeof a5 !== "string") {
        throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof a5 + ", while padToEven.");
      }
      if (a5.length % 2) {
        a5 = "0" + a5;
      }
      return a5;
    }
    function intToHex(i5) {
      var hex = i5.toString(16);
      return "0x" + hex;
    }
    function intToBuffer2(i5) {
      var hex = intToHex(i5);
      return new Buffer2(padToEven(hex.slice(2)), "hex");
    }
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof str + "'.");
      }
      return Buffer2.byteLength(str, "utf8");
    }
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof superset + "'");
      }
      if (Array.isArray(subset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof subset + "'");
      }
      return subset[Boolean(some) && "some" || "every"](function(value) {
        return superset.indexOf(value) >= 0;
      });
    }
    function toUtf8(hex) {
      var bufferValue = new Buffer2(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, "")), "hex");
      return bufferValue.toString("utf8");
    }
    function toAscii(hex) {
      var str = "";
      var i5 = 0, l5 = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i5 = 2;
      }
      for (; i5 < l5; i5 += 2) {
        var code = parseInt(hex.substr(i5, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    function fromUtf8(stringValue) {
      var str = new Buffer2(stringValue, "utf8");
      return "0x" + padToEven(str.toString("hex")).replace(/^0+|0+$/g, "");
    }
    function fromAscii(stringValue) {
      var hex = "";
      for (var i5 = 0; i5 < stringValue.length; i5++) {
        var code = stringValue.charCodeAt(i5);
        var n3 = code.toString(16);
        hex += n3.length < 2 ? "0" + n3 : n3;
      }
      return "0x" + hex;
    }
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof params + "'");
      }
      if (typeof key !== "string") {
        throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof key + "'.");
      }
      var result = [];
      for (var i5 = 0; i5 < params.length; i5++) {
        var value = params[i5][key];
        if (allowEmpty && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error("invalid abi");
        }
        result.push(value);
      }
      return result;
    }
    function isHexString3(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length && value.length !== 2 + 2 * length) {
        return false;
      }
      return true;
    }
    module.exports = {
      arrayContainsArray,
      intToBuffer: intToBuffer2,
      getBinarySize,
      isHexPrefixed,
      stripHexPrefix,
      padToEven,
      intToHex,
      fromAscii,
      fromUtf8,
      toAscii,
      toUtf8,
      getKeys,
      isHexString: isHexString3
    };
  }
});

// node_modules/ethereumjs-util/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _require = require_keccak3();
    var keccak224 = _require.keccak224;
    var keccak384 = _require.keccak384;
    var k256 = _require.keccak256;
    var keccak512 = _require.keccak512;
    var secp256k1 = require_secp256k1_adapter();
    var assert3 = require_assert();
    var rlp = require_dist6();
    var BN2 = require_bn9();
    var createHash = require_browser3();
    var Buffer4 = require_safe_buffer().Buffer;
    Object.assign(exports, require_lib4());
    exports.MAX_INTEGER = new BN2("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN2("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;
    exports.KECCAK256_NULL = Buffer4.from(exports.KECCAK256_NULL_S, "hex");
    exports.SHA3_NULL = exports.KECCAK256_NULL;
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;
    exports.KECCAK256_RLP_ARRAY = Buffer4.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;
    exports.KECCAK256_RLP = Buffer4.from(exports.KECCAK256_RLP_S, "hex");
    exports.SHA3_RLP = exports.KECCAK256_RLP;
    exports.BN = BN2;
    exports.rlp = rlp;
    exports.secp256k1 = secp256k1;
    exports.zeros = function(bytes) {
      return Buffer4.allocUnsafe(bytes).fill(0);
    };
    exports.zeroAddress = function() {
      var addressLength = 20;
      var zeroAddress = exports.zeros(addressLength);
      return exports.bufferToHex(zeroAddress);
    };
    exports.setLengthLeft = exports.setLength = function(msg, length, right) {
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = exports.stripZeros = function(a5) {
      a5 = exports.stripHexPrefix(a5);
      var first2 = a5[0];
      while (a5.length > 0 && first2.toString() === "0") {
        a5 = a5.slice(1);
        first2 = a5[0];
      }
      return a5;
    };
    exports.toBuffer = function(v5) {
      if (!Buffer4.isBuffer(v5)) {
        if (Array.isArray(v5)) {
          v5 = Buffer4.from(v5);
        } else if (typeof v5 === "string") {
          if (exports.isHexString(v5)) {
            v5 = Buffer4.from(exports.padToEven(exports.stripHexPrefix(v5)), "hex");
          } else {
            v5 = Buffer4.from(v5);
          }
        } else if (typeof v5 === "number") {
          v5 = exports.intToBuffer(v5);
        } else if (v5 === null || v5 === void 0) {
          v5 = Buffer4.allocUnsafe(0);
        } else if (BN2.isBN(v5)) {
          v5 = v5.toArrayLike(Buffer4);
        } else if (v5.toArray) {
          v5 = Buffer4.from(v5.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v5;
    };
    exports.bufferToInt = function(buf) {
      return new BN2(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN2(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer4.from(num.toTwos(256).toArray());
    };
    exports.keccak = function(a5, bits) {
      a5 = exports.toBuffer(a5);
      if (!bits)
        bits = 256;
      switch (bits) {
        case 224: {
          return keccak224(a5);
        }
        case 256: {
          return k256(a5);
        }
        case 384: {
          return keccak384(a5);
        }
        case 512: {
          return keccak512(a5);
        }
        default: {
          throw new Error("Invald algorithm: keccak" + bits);
        }
      }
    };
    exports.keccak256 = function(a5) {
      return exports.keccak(a5);
    };
    exports.sha3 = exports.keccak;
    exports.sha256 = function(a5) {
      a5 = exports.toBuffer(a5);
      return createHash("sha256").update(a5).digest();
    };
    exports.ripemd160 = function(a5, padded) {
      a5 = exports.toBuffer(a5);
      var hash = createHash("rmd160").update(a5).digest();
      if (padded === true) {
        return exports.setLength(hash, 32);
      } else {
        return hash;
      }
    };
    exports.rlphash = function(a5) {
      return exports.keccak(rlp.encode(a5));
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k1.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey, sanitize) {
      if (publicKey.length === 64) {
        return secp256k1.publicKeyVerify(Buffer4.concat([Buffer4.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k1.publicKeyVerify(publicKey);
    };
    exports.pubToAddress = exports.publicToAddress = function(pubKey, sanitize) {
      pubKey = exports.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
      }
      assert3(pubKey.length === 64);
      return exports.keccak(pubKey).slice(-20);
    };
    var privateToPublic = exports.privateToPublic = function(privateKey) {
      privateKey = exports.toBuffer(privateKey);
      return secp256k1.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey) {
      publicKey = exports.toBuffer(publicKey);
      if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
      }
      return publicKey;
    };
    exports.ecsign = function(msgHash, privateKey) {
      var sig = secp256k1.sign(msgHash, privateKey);
      var ret = {};
      ret.r = sig.signature.slice(0, 32);
      ret.s = sig.signature.slice(32, 64);
      ret.v = sig.recovery + 27;
      return ret;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = exports.toBuffer("Ethereum Signed Message:\n" + message.length.toString());
      return exports.keccak(Buffer4.concat([prefix, message]));
    };
    exports.ecrecover = function(msgHash, v5, r6, s5) {
      var signature = Buffer4.concat([exports.setLength(r6, 32), exports.setLength(s5, 32)], 64);
      var recovery = v5 - 27;
      if (recovery !== 0 && recovery !== 1) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
      return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v5, r6, s5) {
      if (v5 !== 27 && v5 !== 28) {
        throw new Error("Invalid recovery id");
      }
      return exports.bufferToHex(Buffer4.concat([exports.setLengthLeft(r6, 32), exports.setLengthLeft(s5, 32), exports.toBuffer(v5 - 27)]));
    };
    exports.fromRpcSig = function(sig) {
      sig = exports.toBuffer(sig);
      if (sig.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v5 = sig[64];
      if (v5 < 27) {
        v5 += 27;
      }
      return {
        v: v5,
        r: sig.slice(0, 32),
        s: sig.slice(32, 64)
      };
    };
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(privateToPublic(privateKey));
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddress = exports.zeroAddress();
      return zeroAddress === exports.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address) {
      address = exports.stripHexPrefix(address).toLowerCase();
      var hash = exports.keccak(address).toString("hex");
      var ret = "0x";
      for (var i5 = 0; i5 < address.length; i5++) {
        if (parseInt(hash[i5], 16) >= 8) {
          ret += address[i5].toUpperCase();
        } else {
          ret += address[i5];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
    };
    exports.generateAddress = function(from4, nonce) {
      from4 = exports.toBuffer(from4);
      nonce = new BN2(nonce);
      if (nonce.isZero()) {
        nonce = null;
      } else {
        nonce = Buffer4.from(nonce.toArray());
      }
      return exports.rlphash([from4, nonce]).slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a5 = exports.unpad(address);
      return a5.length === 1 && a5[0] >= 1 && a5[0] <= 8;
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return exports.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.isValidSignature = function(v5, r6, s5, homestead) {
      var SECP256K1_N_DIV_2 = new BN2("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r6.length !== 32 || s5.length !== 32) {
        return false;
      }
      if (v5 !== 27 && v5 !== 28) {
        return false;
      }
      r6 = new BN2(r6);
      s5 = new BN2(s5);
      if (r6.isZero() || r6.gt(SECP256K1_N) || s5.isZero() || s5.gt(SECP256K1_N)) {
        return false;
      }
      if (homestead === false && new BN2(s5).cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.baToJSON = function(ba) {
      if (Buffer4.isBuffer(ba)) {
        return "0x" + ba.toString("hex");
      } else if (ba instanceof Array) {
        var array = [];
        for (var i5 = 0; i5 < ba.length; i5++) {
          array.push(exports.baToJSON(ba[i5]));
        }
        return array;
      }
    };
    exports.defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label) {
          var obj = {};
          self2._fields.forEach(function(field) {
            obj[field] = "0x" + self2[field].toString("hex");
          });
          return obj;
        }
        return exports.baToJSON(this.raw);
      };
      self2.serialize = function serialize() {
        return rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i5) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i5];
        }
        function setter(v5) {
          v5 = exports.toBuffer(v5);
          if (v5.toString("hex") === "00" && !field.allowZero) {
            v5 = Buffer4.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v5 = exports.stripZeros(v5);
            assert3(field.length >= v5.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v5.length === 0) && field.length) {
            assert3(field.length === v5.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self2.raw[i5] = v5;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer4.from(exports.stripHexPrefix(data), "hex");
        }
        if (Buffer4.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d5, i5) {
            self2[self2._fields[i5]] = exports.toBuffer(d5);
          });
        } else if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object") {
          var keys2 = Object.keys(data);
          fields.forEach(function(field) {
            if (keys2.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys2.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e5) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString2(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString2;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString2 = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function isObject3(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    module.exports = isObject3;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var baseGetTag = require_baseGetTag();
    var isObject3 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction4(value) {
      if (!isObject3(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction4;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var isFunction4 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction4(value);
    }
    module.exports = isArrayLike2;
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {};
    module.exports = exports["default"];
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function noop4() {
    }
    module.exports = noop4;
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = once4;
    function once4(fn) {
      return function() {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll) {
      return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
    };
    var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
    module.exports = exports["default"];
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function baseTimes(n3, iteratee) {
      var index = -1, result = Array(n3);
      while (++index < n3) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments2 = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments2;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var isArray5 = Array.isArray;
    module.exports = isArray5;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer4 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer4 ? Buffer4.isBuffer : void 0;
    var isBuffer5 = nativeIsBuffer || stubFalse;
    module.exports = isBuffer5;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type2 = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e5) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray2;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var baseTimes = require_baseTimes();
    var isArguments2 = require_isArguments();
    var isArray5 = require_isArray();
    var isBuffer5 = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray2 = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray5(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer5(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty3.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike2 = require_isArrayLike();
    function keys2(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys2;
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterator2;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    var _keys = require_keys();
    var _keys2 = _interopRequireDefault(_keys);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i5 = -1;
      var len = coll.length;
      return function next() {
        return ++i5 < len ? { value: coll[i5], key: i5 } : null;
      };
    }
    function createES2015Iterator(iterator3) {
      var i5 = -1;
      return function next() {
        var item = iterator3.next();
        if (item.done)
          return null;
        i5++;
        return { value: item.value, key: i5 };
      };
    }
    function createObjectIterator(obj) {
      var okeys = (0, _keys2.default)(obj);
      var i5 = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i5];
        if (key === "__proto__") {
          return next();
        }
        return i5 < len ? { value: obj[key], key } : null;
      };
    }
    function iterator2(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator3 = (0, _getIterator2.default)(coll);
      return iterator3 ? createES2015Iterator(iterator3) : createObjectIterator(coll);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = onlyOnce;
    function onlyOnce(fn) {
      return function() {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _eachOfLimit;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _eachOfLimit(limit) {
      return function(obj, iteratee, callback) {
        callback = (0, _once2.default)(callback || _noop2.default);
        if (limit <= 0 || !obj) {
          return callback(null);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done2 = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          running -= 1;
          if (err) {
            done2 = true;
            callback(err);
          } else if (value === _breakLoop2.default || done2 && running <= 0) {
            done2 = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done2) {
            var elem = nextElem();
            if (elem === null) {
              done2 = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/slice.js
var require_slice = __commonJS({
  "node_modules/async/internal/slice.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = slice3;
    function slice3(arrayLike, start) {
      start = start | 0;
      var newLen = Math.max(arrayLike.length - start, 0);
      var newArr = Array(newLen);
      for (var idx = 0; idx < newLen; idx++) {
        newArr[idx] = arrayLike[start + idx];
      }
      return newArr;
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(fn) {
      return function() {
        var args = (0, _slice2.default)(arguments);
        var callback = args.pop();
        fn.call(this, args, callback);
      };
    };
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hasNextTick = exports.hasSetImmediate = void 0;
    exports.fallback = fallback;
    exports.wrap = wrap;
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer2) {
      return function(fn) {
        var args = (0, _slice2.default)(arguments, 1);
        defer2(function() {
          fn.apply(null, args);
        });
      };
    }
    var _defer;
    if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports.default = wrap(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = asyncify;
    var _isObject = require_isObject();
    var _isObject2 = _interopRequireDefault(_isObject);
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e5) {
          return callback(e5);
        }
        if ((0, _isObject2.default)(result) && typeof result.then === "function") {
          result.then(function(value) {
            invokeCallback(callback, null, value);
          }, function(err) {
            invokeCallback(callback, err.message ? err : new Error(err));
          });
        } else {
          callback(null, result);
        }
      });
    }
    function invokeCallback(callback, error2, value) {
      try {
        callback(error2, value);
      } catch (e5) {
        (0, _setImmediate2.default)(rethrow, e5);
      }
    }
    function rethrow(error2) {
      throw error2;
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var supportsSymbol = typeof Symbol === "function";
    function isAsync(fn) {
      return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function wrapAsync(asyncFn) {
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports.default = wrapAsync;
    exports.isAsync = isAsync;
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = eachOfLimit;
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/doLimit.js
var require_doLimit = __commonJS({
  "node_modules/async/internal/doLimit.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = doLimit;
    function doLimit(fn, limit) {
      return function(iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    };
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _doLimit = require_doLimit();
    var _doLimit2 = _interopRequireDefault(_doLimit);
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      var index = 0, completed = 0, length = coll.length;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    var eachOfGeneric = (0, _doLimit2.default)(_eachOfLimit2.default, Infinity);
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/doParallel.js
var require_doParallel = __commonJS({
  "node_modules/async/internal/doParallel.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = doParallel;
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function doParallel(fn) {
      return function(obj, iteratee, callback) {
        return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/map.js
var require_map = __commonJS({
  "node_modules/async/internal/map.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _asyncMap;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      callback = callback || _noop2.default;
      arr = arr || [];
      var results2 = [];
      var counter = 0;
      var _iteratee = (0, _wrapAsync2.default)(iteratee);
      eachfn(arr, function(value, _6, callback2) {
        var index = counter++;
        _iteratee(value, function(err, v5) {
          results2[index] = v5;
          callback2(err);
        });
      }, function(err) {
        callback(err, results2);
      });
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/map.js
var require_map2 = __commonJS({
  "node_modules/async/map.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _doParallel = require_doParallel();
    var _doParallel2 = _interopRequireDefault(_doParallel);
    var _map = require_map();
    var _map2 = _interopRequireDefault(_map);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _doParallel2.default)(_map2.default);
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return function(value, index, callback) {
        return iteratee(value, callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachLimit.js
var require_eachLimit = __commonJS({
  "node_modules/async/eachLimit.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = eachLimit;
    var _eachOfLimit = require_eachOfLimit();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, limit, iteratee, callback) {
      (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachSeries.js
var require_eachSeries = __commonJS({
  "node_modules/async/eachSeries.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _eachLimit = require_eachLimit();
    var _eachLimit2 = _interopRequireDefault(_eachLimit);
    var _doLimit = require_doLimit();
    var _doLimit2 = _interopRequireDefault(_doLimit);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _doLimit2.default)(_eachLimit2.default, 1);
    module.exports = exports["default"];
  }
});

// node_modules/web3-provider-engine/util/stoplight.js
var require_stoplight = __commonJS({
  "node_modules/web3-provider-engine/util/stoplight.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var EventEmitter3 = require_events().EventEmitter;
    var inherits2 = require_util().inherits;
    module.exports = Stoplight;
    inherits2(Stoplight, EventEmitter3);
    function Stoplight() {
      const self2 = this;
      EventEmitter3.call(self2);
      self2.isLocked = true;
    }
    Stoplight.prototype.go = function() {
      const self2 = this;
      self2.isLocked = false;
      self2.emit("unlock");
    };
    Stoplight.prototype.stop = function() {
      const self2 = this;
      self2.isLocked = true;
      self2.emit("lock");
    };
    Stoplight.prototype.await = function(fn) {
      const self2 = this;
      if (self2.isLocked) {
        self2.once("unlock", fn);
      } else {
        setTimeout(fn);
      }
    };
  }
});

// node_modules/jsonify/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/jsonify/lib/parse.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var at;
    var ch;
    var escapee = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
    };
    var text;
    function error2(m5) {
      throw {
        name: "SyntaxError",
        message: m5,
        at,
        text
      };
    }
    function next(c5) {
      if (c5 && c5 !== ch) {
        error2("Expected '" + c5 + "' instead of '" + ch + "'");
      }
      ch = text.charAt(at);
      at += 1;
      return ch;
    }
    function number() {
      var num;
      var str = "";
      if (ch === "-") {
        str = "-";
        next("-");
      }
      while (ch >= "0" && ch <= "9") {
        str += ch;
        next();
      }
      if (ch === ".") {
        str += ".";
        while (next() && ch >= "0" && ch <= "9") {
          str += ch;
        }
      }
      if (ch === "e" || ch === "E") {
        str += ch;
        next();
        if (ch === "-" || ch === "+") {
          str += ch;
          next();
        }
        while (ch >= "0" && ch <= "9") {
          str += ch;
          next();
        }
      }
      num = Number(str);
      if (!isFinite(num)) {
        error2("Bad number");
      }
      return num;
    }
    function string() {
      var hex;
      var i5;
      var str = "";
      var uffff;
      if (ch === '"') {
        while (next()) {
          if (ch === '"') {
            next();
            return str;
          } else if (ch === "\\") {
            next();
            if (ch === "u") {
              uffff = 0;
              for (i5 = 0; i5 < 4; i5 += 1) {
                hex = parseInt(next(), 16);
                if (!isFinite(hex)) {
                  break;
                }
                uffff = uffff * 16 + hex;
              }
              str += String.fromCharCode(uffff);
            } else if (typeof escapee[ch] === "string") {
              str += escapee[ch];
            } else {
              break;
            }
          } else {
            str += ch;
          }
        }
      }
      error2("Bad string");
    }
    function white() {
      while (ch && ch <= " ") {
        next();
      }
    }
    function word() {
      switch (ch) {
        case "t":
          next("t");
          next("r");
          next("u");
          next("e");
          return true;
        case "f":
          next("f");
          next("a");
          next("l");
          next("s");
          next("e");
          return false;
        case "n":
          next("n");
          next("u");
          next("l");
          next("l");
          return null;
        default:
          error2("Unexpected '" + ch + "'");
      }
    }
    function array() {
      var arr = [];
      if (ch === "[") {
        next("[");
        white();
        if (ch === "]") {
          next("]");
          return arr;
        }
        while (ch) {
          arr.push(value());
          white();
          if (ch === "]") {
            next("]");
            return arr;
          }
          next(",");
          white();
        }
      }
      error2("Bad array");
    }
    function object() {
      var key;
      var obj = {};
      if (ch === "{") {
        next("{");
        white();
        if (ch === "}") {
          next("}");
          return obj;
        }
        while (ch) {
          key = string();
          white();
          next(":");
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            error2('Duplicate key "' + key + '"');
          }
          obj[key] = value();
          white();
          if (ch === "}") {
            next("}");
            return obj;
          }
          next(",");
          white();
        }
      }
      error2("Bad object");
    }
    function value() {
      white();
      switch (ch) {
        case "{":
          return object();
        case "[":
          return array();
        case '"':
          return string();
        case "-":
          return number();
        default:
          return ch >= "0" && ch <= "9" ? number() : word();
      }
    }
    module.exports = function(source, reviver) {
      var result;
      text = source;
      at = 0;
      ch = " ";
      result = value();
      white();
      if (ch) {
        error2("Syntax error");
      }
      return typeof reviver === "function" ? function walk(holder, key) {
        var k5;
        var v5;
        var val = holder[key];
        if (val && typeof val === "object") {
          for (k5 in value) {
            if (Object.prototype.hasOwnProperty.call(val, k5)) {
              v5 = walk(val, k5);
              if (typeof v5 === "undefined") {
                delete val[k5];
              } else {
                val[k5] = v5;
              }
            }
          }
        }
        return reviver.call(holder, key, val);
      }({ "": result }, "") : result;
    };
  }
});

// node_modules/jsonify/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/jsonify/lib/stringify.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var escapable = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var gap;
    var indent;
    var meta = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    var rep;
    function quote(string) {
      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function(a5) {
        var c5 = meta[a5];
        return typeof c5 === "string" ? c5 : "\\u" + ("0000" + a5.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
      var i5;
      var k5;
      var v5;
      var length;
      var mind = gap;
      var partial;
      var value = holder[key];
      if (value && typeof value === "object" && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      if (typeof rep === "function") {
        value = rep.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          return quote(value);
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
        case "null":
          return String(value);
        case "object":
          if (!value) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i5 = 0; i5 < length; i5 += 1) {
              partial[i5] = str(i5, value) || "null";
            }
            v5 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v5;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i5 = 0; i5 < length; i5 += 1) {
              k5 = rep[i5];
              if (typeof k5 === "string") {
                v5 = str(k5, value);
                if (v5) {
                  partial.push(quote(k5) + (gap ? ": " : ":") + v5);
                }
              }
            }
          } else {
            for (k5 in value) {
              if (Object.prototype.hasOwnProperty.call(value, k5)) {
                v5 = str(k5, value);
                if (v5) {
                  partial.push(quote(k5) + (gap ? ": " : ":") + v5);
                }
              }
            }
          }
          v5 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v5;
        default:
      }
    }
    module.exports = function(value, replacer, space) {
      var i5;
      gap = "";
      indent = "";
      if (typeof space === "number") {
        for (i5 = 0; i5 < space; i5 += 1) {
          indent += " ";
        }
      } else if (typeof space === "string") {
        indent = space;
      }
      rep = replacer;
      if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
        throw new Error("JSON.stringify");
      }
      return str("", { "": value });
    };
  }
});

// node_modules/jsonify/index.js
var require_jsonify = __commonJS({
  "node_modules/jsonify/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    exports.parse = require_parse2();
    exports.stringify = require_stringify2();
  }
});

// node_modules/json-stable-stringify/index.js
var require_json_stable_stringify = __commonJS({
  "node_modules/json-stable-stringify/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var json = typeof JSON !== "undefined" ? JSON : require_jsonify();
    module.exports = function(obj, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var space = opts.space || "";
      if (typeof space === "number")
        space = Array(space + 1).join(" ");
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var replacer = opts.replacer || function(key, value) {
        return value;
      };
      var cmp = opts.cmp && function(f5) {
        return function(node) {
          return function(a5, b4) {
            var aobj = { key: a5, value: node[a5] };
            var bobj = { key: b4, value: node[b4] };
            return f5(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify3(parent, key, node, level) {
        var indent = space ? "\n" + new Array(level + 1).join(space) : "";
        var colonSeparator = space ? ": " : ":";
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        node = replacer.call(parent, key, node);
        if (node === void 0) {
          return;
        }
        if (typeof node !== "object" || node === null) {
          return json.stringify(node);
        }
        if (isArray5(node)) {
          var out = [];
          for (var i5 = 0; i5 < node.length; i5++) {
            var item = stringify3(node, i5, node[i5], level + 1) || json.stringify(null);
            out.push(indent + space + item);
          }
          return "[" + out.join(",") + indent + "]";
        } else {
          if (seen.indexOf(node) !== -1) {
            if (cycles)
              return json.stringify("__cycle__");
            throw new TypeError("Converting circular structure to JSON");
          } else
            seen.push(node);
          var keys2 = objectKeys3(node).sort(cmp && cmp(node));
          var out = [];
          for (var i5 = 0; i5 < keys2.length; i5++) {
            var key = keys2[i5];
            var value = stringify3(node, key, node[key], level + 1);
            if (!value)
              continue;
            var keyValue = json.stringify(key) + colonSeparator + value;
            ;
            out.push(indent + space + keyValue);
          }
          seen.splice(seen.indexOf(node), 1);
          return "{" + out.join(",") + indent + "}";
        }
      }({ "": obj }, "", obj, 0);
    };
    var isArray5 = Array.isArray || function(x5) {
      return {}.toString.call(x5) === "[object Array]";
    };
    var objectKeys3 = Object.keys || function(obj) {
      var has = Object.prototype.hasOwnProperty || function() {
        return true;
      };
      var keys2 = [];
      for (var key in obj) {
        if (has.call(obj, key))
          keys2.push(key);
      }
      return keys2;
    };
  }
});

// node_modules/web3-provider-engine/util/rpc-cache-utils.js
var require_rpc_cache_utils = __commonJS({
  "node_modules/web3-provider-engine/util/rpc-cache-utils.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var stringify3 = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload, opts = {}) {
      if (!canCache(payload))
        return null;
      const { includeBlockRef } = opts;
      const params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload);
      return payload.method + ":" + stringify3(params);
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
          return "fork";
        case "eth_gasPrice":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "eth_blockNumber":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
          return "never";
      }
    }
  }
});

// node_modules/web3-provider-engine/util/random-id.js
var require_random_id = __commonJS({
  "node_modules/web3-provider-engine/util/random-id.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = createRandomId;
    function createRandomId() {
      return Math.floor(Number.MAX_SAFE_INTEGER * Math.random());
    }
  }
});

// node_modules/web3-provider-engine/util/create-payload.js
var require_create_payload = __commonJS({
  "node_modules/web3-provider-engine/util/create-payload.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var getRandomId = require_random_id();
    var extend = require_immutable();
    module.exports = createPayload;
    function createPayload(data) {
      return extend({
        id: getRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/web3-provider-engine/index.js
var require_web3_provider_engine = __commonJS({
  "node_modules/web3-provider-engine/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var EventEmitter3 = require_events().EventEmitter;
    var inherits2 = require_util().inherits;
    var ethUtil = require_dist7();
    var EthBlockTracker = require_polling();
    var map4 = require_map2();
    var eachSeries = require_eachSeries();
    var Stoplight = require_stoplight();
    var cacheUtils = require_rpc_cache_utils();
    var createPayload = require_create_payload();
    var noop4 = function() {
    };
    module.exports = Web3ProviderEngine;
    inherits2(Web3ProviderEngine, EventEmitter3);
    function Web3ProviderEngine(opts) {
      const self2 = this;
      EventEmitter3.call(self2);
      self2.setMaxListeners(30);
      opts = opts || {};
      const directProvider = { sendAsync: self2._handleAsync.bind(self2) };
      const blockTrackerProvider = opts.blockTrackerProvider || directProvider;
      self2._blockTracker = opts.blockTracker || new EthBlockTracker({
        provider: blockTrackerProvider,
        pollingInterval: opts.pollingInterval || 4e3,
        setSkipCacheFlag: true
      });
      self2._ready = new Stoplight();
      self2.currentBlock = null;
      self2._providers = [];
    }
    Web3ProviderEngine.prototype.start = function(cb = noop4) {
      const self2 = this;
      self2._ready.go();
      self2._blockTracker.on("latest", (blockNumber) => {
        self2._getBlockByNumberWithRetry(blockNumber, (err, block) => {
          if (err) {
            this.emit("error", err);
            return;
          }
          if (!block) {
            console.log(block);
            this.emit("error", new Error("Could not find block"));
            return;
          }
          const bufferBlock = toBufferBlock(block);
          self2._setCurrentBlock(bufferBlock);
          self2.emit("rawBlock", block);
          self2.emit("latest", block);
        });
      });
      self2._blockTracker.on("sync", self2.emit.bind(self2, "sync"));
      self2._blockTracker.on("error", self2.emit.bind(self2, "error"));
      self2._running = true;
      self2.emit("start");
    };
    Web3ProviderEngine.prototype.stop = function() {
      const self2 = this;
      self2._blockTracker.removeAllListeners();
      self2._running = false;
      self2.emit("stop");
    };
    Web3ProviderEngine.prototype.isRunning = function() {
      const self2 = this;
      return self2._running;
    };
    Web3ProviderEngine.prototype.addProvider = function(source, index) {
      const self2 = this;
      if (typeof index === "number") {
        self2._providers.splice(index, 0, source);
      } else {
        self2._providers.push(source);
      }
      source.setEngine(this);
    };
    Web3ProviderEngine.prototype.removeProvider = function(source) {
      const self2 = this;
      const index = self2._providers.indexOf(source);
      if (index < 0)
        throw new Error("Provider not found.");
      self2._providers.splice(index, 1);
    };
    Web3ProviderEngine.prototype.send = function(payload) {
      throw new Error("Web3ProviderEngine does not support synchronous requests.");
    };
    Web3ProviderEngine.prototype.sendAsync = function(payload, cb) {
      const self2 = this;
      self2._ready.await(function() {
        if (Array.isArray(payload)) {
          map4(payload, self2._handleAsync.bind(self2), cb);
        } else {
          self2._handleAsync(payload, cb);
        }
      });
    };
    Web3ProviderEngine.prototype._getBlockByNumberWithRetry = function(blockNumber, cb) {
      const self2 = this;
      let retriesRemaining = 5;
      attemptRequest();
      return;
      function attemptRequest() {
        self2._getBlockByNumber(blockNumber, afterRequest);
      }
      function afterRequest(err, block) {
        if (err)
          return cb(err);
        if (!block) {
          if (retriesRemaining > 0) {
            retriesRemaining--;
            setTimeout(function() {
              attemptRequest();
            }, 1e3);
            return;
          } else {
            cb(null, null);
            return;
          }
        }
        cb(null, block);
        return;
      }
    };
    Web3ProviderEngine.prototype._getBlockByNumber = function(blockNumber, cb) {
      const req = createPayload({ method: "eth_getBlockByNumber", params: [blockNumber, false], skipCache: true });
      this._handleAsync(req, (err, res) => {
        if (err)
          return cb(err);
        return cb(null, res.result);
      });
    };
    Web3ProviderEngine.prototype._handleAsync = function(payload, finished) {
      var self2 = this;
      var currentProvider = -1;
      var result = null;
      var error2 = null;
      var stack = [];
      next();
      function next(after) {
        currentProvider += 1;
        stack.unshift(after);
        if (currentProvider >= self2._providers.length) {
          end(new Error('Request for method "' + payload.method + '" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));
        } else {
          try {
            var provider = self2._providers[currentProvider];
            provider.handleRequest(payload, next, end);
          } catch (e5) {
            end(e5);
          }
        }
      }
      function end(_error, _result) {
        error2 = _error;
        result = _result;
        eachSeries(stack, function(fn, callback) {
          if (fn) {
            fn(error2, result, callback);
          } else {
            callback();
          }
        }, function() {
          var resultObj = {
            id: payload.id,
            jsonrpc: payload.jsonrpc,
            result
          };
          if (error2 != null) {
            resultObj.error = {
              message: error2.stack || error2.message || error2,
              code: -32e3
            };
            finished(error2, resultObj);
          } else {
            finished(null, resultObj);
          }
        });
      }
    };
    Web3ProviderEngine.prototype._setCurrentBlock = function(block) {
      const self2 = this;
      self2.currentBlock = block;
      self2.emit("block", block);
    };
    function toBufferBlock(jsonBlock) {
      return {
        number: ethUtil.toBuffer(jsonBlock.number),
        hash: ethUtil.toBuffer(jsonBlock.hash),
        parentHash: ethUtil.toBuffer(jsonBlock.parentHash),
        nonce: ethUtil.toBuffer(jsonBlock.nonce),
        mixHash: ethUtil.toBuffer(jsonBlock.mixHash),
        sha3Uncles: ethUtil.toBuffer(jsonBlock.sha3Uncles),
        logsBloom: ethUtil.toBuffer(jsonBlock.logsBloom),
        transactionsRoot: ethUtil.toBuffer(jsonBlock.transactionsRoot),
        stateRoot: ethUtil.toBuffer(jsonBlock.stateRoot),
        receiptsRoot: ethUtil.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),
        miner: ethUtil.toBuffer(jsonBlock.miner),
        difficulty: ethUtil.toBuffer(jsonBlock.difficulty),
        totalDifficulty: ethUtil.toBuffer(jsonBlock.totalDifficulty),
        size: ethUtil.toBuffer(jsonBlock.size),
        extraData: ethUtil.toBuffer(jsonBlock.extraData),
        gasLimit: ethUtil.toBuffer(jsonBlock.gasLimit),
        gasUsed: ethUtil.toBuffer(jsonBlock.gasUsed),
        timestamp: ethUtil.toBuffer(jsonBlock.timestamp),
        transactions: jsonBlock.transactions
      };
    }
  }
});

// node_modules/web3-provider-engine/subproviders/subprovider.js
var require_subprovider = __commonJS({
  "node_modules/web3-provider-engine/subproviders/subprovider.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var createPayload = require_create_payload();
    module.exports = SubProvider;
    function SubProvider() {
    }
    SubProvider.prototype.setEngine = function(engine) {
      const self2 = this;
      if (self2.engine)
        return;
      self2.engine = engine;
      engine.on("block", function(block) {
        self2.currentBlock = block;
      });
      engine.on("start", function() {
        self2.start();
      });
      engine.on("stop", function() {
        self2.stop();
      });
    };
    SubProvider.prototype.handleRequest = function(payload, next, end) {
      throw new Error("Subproviders should override `handleRequest`.");
    };
    SubProvider.prototype.emitPayload = function(payload, cb) {
      const self2 = this;
      self2.engine.sendAsync(createPayload(payload), cb);
    };
    SubProvider.prototype.stop = function() {
    };
    SubProvider.prototype.start = function() {
    };
  }
});

// node_modules/web3-provider-engine/subproviders/json-rpc-engine-middleware.js
var require_json_rpc_engine_middleware = __commonJS({
  "node_modules/web3-provider-engine/subproviders/json-rpc-engine-middleware.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var Subprovider = require_subprovider();
    var JsonRpcEngineMiddlewareSubprovider = class extends Subprovider {
      constructor(constructorFn) {
        super();
        if (!constructorFn)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - no constructorFn specified");
        this._constructorFn = constructorFn;
      }
      setEngine(engine) {
        if (this.middleware)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - subprovider added to engine twice");
        const blockTracker = engine._blockTracker;
        const middleware = this._constructorFn({ engine, provider: engine, blockTracker });
        if (!middleware)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - _constructorFn did not return middleware");
        if (typeof middleware !== "function")
          throw new Error("JsonRpcEngineMiddlewareSubprovider - specified middleware is not a function");
        this.middleware = middleware;
      }
      handleRequest(req, provEngNext, provEngEnd) {
        const res = { id: req.id };
        this.middleware(req, res, middlewareNext, middlewareEnd);
        function middlewareNext(handler) {
          provEngNext((err, result, cb) => {
            if (err) {
              delete res.result;
              res.error = { message: err.message || err };
            } else {
              res.result = result;
            }
            if (handler) {
              handler(cb);
            } else {
              cb();
            }
          });
        }
        function middlewareEnd(err) {
          if (err)
            return provEngEnd(err);
          provEngEnd(null, res.result);
        }
      }
    };
    module.exports = JsonRpcEngineMiddlewareSubprovider;
  }
});

// node_modules/eth-json-rpc-middleware/cache-utils.js
var require_cache_utils = __commonJS({
  "node_modules/eth-json-rpc-middleware/cache-utils.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var stringify3 = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload, skipBlockRef) {
      const simpleParams = skipBlockRef ? paramsWithoutBlockTag(payload) : payload.params;
      if (canCache(payload)) {
        return payload.method + ":" + stringify3(simpleParams);
      } else {
        return null;
      }
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      let index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      const index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
        case "test_permaCache":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
        case "test_forkCache":
          return "fork";
        case "eth_gasPrice":
        case "eth_blockNumber":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "test_blockCache":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
        case "test_neverCache":
          return "never";
      }
    }
  }
});

// node_modules/eth-json-rpc-middleware/node_modules/json-rpc-engine/src/createAsyncMiddleware.js
var require_createAsyncMiddleware2 = __commonJS({
  "node_modules/eth-json-rpc-middleware/node_modules/json-rpc-engine/src/createAsyncMiddleware.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function createAsyncMiddleware(asyncMiddleware) {
      return (req, res, next, end) => {
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
          resolveNextPromise = resolve;
        });
        let returnHandlerCallback, nextWasCalled;
        const asyncNext = async () => {
          nextWasCalled = true;
          next((callback) => {
            returnHandlerCallback = callback;
            resolveNextPromise();
          });
          await nextPromise;
        };
        asyncMiddleware(req, res, asyncNext).then(async () => {
          if (nextWasCalled) {
            await nextPromise;
            returnHandlerCallback(null);
          } else {
            end(null);
          }
        }).catch((error2) => {
          if (returnHandlerCallback) {
            returnHandlerCallback(error2);
          } else {
            end(error2);
          }
        });
      };
    };
  }
});

// node_modules/eth-json-rpc-middleware/block-cache.js
var require_block_cache = __commonJS({
  "node_modules/eth-json-rpc-middleware/block-cache.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var cacheUtils = require_cache_utils();
    var createAsyncMiddleware = require_createAsyncMiddleware2();
    var emptyValues = [void 0, null, "<nil>"];
    module.exports = createBlockCacheMiddleware;
    function createBlockCacheMiddleware(opts = {}) {
      const { blockTracker } = opts;
      if (!blockTracker)
        throw new Error("createBlockCacheMiddleware - No BlockTracker specified");
      const blockCache = new BlockCacheStrategy();
      const strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache
      };
      return createAsyncMiddleware(async (req, res, next) => {
        if (req.skipCache) {
          return next();
        }
        const type2 = cacheUtils.cacheTypeForPayload(req);
        const strategy = strategies[type2];
        if (!strategy) {
          return next();
        }
        if (!strategy.canCacheRequest(req)) {
          return next();
        }
        let blockTag = cacheUtils.blockTagForPayload(req);
        if (!blockTag)
          blockTag = "latest";
        let requestedBlockNumber;
        if (blockTag === "earliest") {
          requestedBlockNumber = "0x00";
        } else if (blockTag === "latest") {
          const latestBlockNumber = await blockTracker.getLatestBlock();
          blockCache.clearBefore(latestBlockNumber);
          requestedBlockNumber = latestBlockNumber;
        } else {
          requestedBlockNumber = blockTag;
        }
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === void 0) {
          await next();
          await strategy.set(req, requestedBlockNumber, res.result);
        } else {
          res.result = cacheResult;
        }
      });
    }
    var BlockCacheStrategy = class {
      constructor() {
        this.cache = {};
      }
      getBlockCacheForPayload(payload, blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        if (!blockCache) {
          const newCache = {};
          this.cache[blockNumber] = newCache;
          blockCache = newCache;
        }
        return blockCache;
      }
      async get(payload, requestedBlockNumber) {
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        if (!blockCache)
          return;
        const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
        const cached = blockCache[identifier];
        return cached;
      }
      async set(payload, requestedBlockNumber, result) {
        const canCache = this.canCacheResult(payload, result);
        if (!canCache)
          return;
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
        blockCache[identifier] = result;
      }
      canCacheRequest(payload) {
        if (!cacheUtils.canCache(payload)) {
          return false;
        }
        const blockTag = cacheUtils.blockTagForPayload(payload);
        if (blockTag === "pending") {
          return false;
        }
        return true;
      }
      canCacheResult(payload, result) {
        if (emptyValues.includes(result))
          return;
        if (["eth_getTransactionByHash", "eth_getTransactionReceipt"].includes(payload.method)) {
          if (!result || !result.blockHash || result.blockHash === "0x0000000000000000000000000000000000000000000000000000000000000000") {
            return false;
          }
        }
        return true;
      }
      clearBefore(oldBlockHex) {
        const self2 = this;
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        Object.keys(self2.cache).map(Number).filter((num) => num < oldBlockNumber).forEach((num) => delete self2.cache[num]);
      }
    };
  }
});

// node_modules/web3-provider-engine/subproviders/cache.js
var require_cache = __commonJS({
  "node_modules/web3-provider-engine/subproviders/cache.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createBlockCacheMiddleware = require_block_cache();
    var BlockCacheSubprovider = class extends ProviderSubprovider {
      constructor(opts) {
        super(({ blockTracker }) => createBlockCacheMiddleware(Object.assign({ blockTracker }, opts)));
      }
    };
    module.exports = BlockCacheSubprovider;
  }
});

// node_modules/web3-provider-engine/subproviders/fixture.js
var require_fixture = __commonJS({
  "node_modules/web3-provider-engine/subproviders/fixture.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_util().inherits;
    var Subprovider = require_subprovider();
    module.exports = FixtureProvider;
    inherits2(FixtureProvider, Subprovider);
    function FixtureProvider(staticResponses) {
      const self2 = this;
      staticResponses = staticResponses || {};
      self2.staticResponses = staticResponses;
    }
    FixtureProvider.prototype.handleRequest = function(payload, next, end) {
      const self2 = this;
      var staticResponse = self2.staticResponses[payload.method];
      if ("function" === typeof staticResponse) {
        staticResponse(payload, next, end);
      } else if (staticResponse !== void 0) {
        setTimeout(() => end(null, staticResponse));
      } else {
        next();
      }
    };
  }
});

// node_modules/web3-provider-engine/subproviders/filters.js
var require_filters = __commonJS({
  "node_modules/web3-provider-engine/subproviders/filters.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var SubscriptionsSubprovider2 = class extends ProviderSubprovider {
      constructor() {
        super(({ blockTracker, provider, engine }) => {
          return createFilterMiddleware({ blockTracker, provider });
        });
      }
    };
    module.exports = SubscriptionsSubprovider2;
  }
});

// node_modules/async/waterfall.js
var require_waterfall = __commonJS({
  "node_modules/async/waterfall.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(tasks, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      if (!(0, _isArray2.default)(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args) {
        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
        args.push((0, _onlyOnce2.default)(next));
        task.apply(null, args);
      }
      function next(err) {
        if (err || taskIndex === tasks.length) {
          return callback.apply(null, arguments);
        }
        nextTask((0, _slice2.default)(arguments, 1));
      }
      nextTask([]);
    };
    var _isArray = require_isArray();
    var _isArray2 = _interopRequireDefault(_isArray);
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _parallel;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _parallel(eachfn, tasks, callback) {
      callback = callback || _noop2.default;
      var results2 = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, function(task, key, callback2) {
        (0, _wrapAsync2.default)(task)(function(err, result) {
          if (arguments.length > 2) {
            result = (0, _slice2.default)(arguments, 1);
          }
          results2[key] = result;
          callback2(err);
        });
      }, function(err) {
        callback(err, results2);
      });
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/parallel.js
var require_parallel2 = __commonJS({
  "node_modules/async/parallel.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = parallelLimit;
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _parallel = require_parallel();
    var _parallel2 = _interopRequireDefault(_parallel);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parallelLimit(tasks, callback) {
      (0, _parallel2.default)(_eachOf2.default, tasks, callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/ethereumjs-abi/node_modules/bn.js/lib/bn.js
var require_bn10 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base2, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e5) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j5, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i5 = number.length - 1, j5 = 0; i5 >= 0; i5 -= 3) {
            w6 = number[i5] | number[i5 - 1] << 8 | number[i5 - 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j5 = 0; i5 < number.length; i5 += 3) {
            w6 = number[i5] | number[i5 + 1] << 8 | number[i5 + 2] << 16;
            this.words[j5] |= w6 << off3 & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r6 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r6 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r6;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off3 = 0;
        var j5 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number.length; i5 += 2) {
            w6 = parseHexByte(number, start, i5) << off3;
            this.words[j5] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j5 += 1;
              this.words[j5] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r6 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r6 *= mul;
          if (c5 >= 49) {
            r6 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r6 += c5 - 17 + 10;
          } else {
            r6 += c5;
          }
        }
        return r6;
      }
      BN2.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number, i5, i5 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i5, number.length, base2);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r6 = new BN2(null);
        this.copy(r6);
        return r6;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i5--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r6 = c5.modn(groupBase).toString(base2);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r6.length] + r6 + out;
            } else {
              out = r6 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength3; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q5.isZero(); i5++) {
            b4 = q5.andln(255);
            q5.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r6 = 0;
          if (t5 >= 4096) {
            r6 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r6 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r6 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r6 += 2;
            t5 >>>= 2;
          }
          return r6 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r6 = 0;
        if ((t5 & 8191) === 0) {
          r6 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r6 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r6 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r6 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r6++;
        }
        return r6;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r6 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r6 += b4;
          if (b4 !== 26)
            break;
        }
        return r6;
      };
      BN2.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a5;
        var b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a5.words[i5] ^ b4.words[i5];
        }
        if (this !== a5) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r6;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r6 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r6 = this.isub(num);
          num.negative = 1;
          return r6._normSign();
        }
        var a5, b4;
        if (this.length > num.length) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          this.words[i5] = r6 & 67108863;
          carry = r6 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r6 = this.iadd(num);
          num.negative = 1;
          return r6._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b4;
        if (cmp > 0) {
          a5 = this;
          b4 = num;
        } else {
          a5 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r6 = (a5.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        for (; carry !== 0 && i5 < a5.length; i5++) {
          r6 = (a5.words[i5] | 0) + carry;
          carry = r6 >> 26;
          this.words[i5] = r6 & 67108863;
        }
        if (carry === 0 && i5 < a5.length && a5 !== this) {
          for (; i5 < a5.length; i5++) {
            this.words[i5] = a5.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r6 = a5 * b4;
        var lo = r6 & 67108863;
        var carry = r6 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5 | 0;
            a5 = self2.words[i5] | 0;
            b4 = num.words[j5] | 0;
            r6 = a5 * b4 + rword;
            ncarry += r6 / 67108864 | 0;
            rword = r6 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b4 = num.words;
        var o5 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o5[0] = w0;
        o5[1] = w1;
        o5[2] = w22;
        o5[3] = w32;
        o5[4] = w42;
        o5[5] = w52;
        o5[6] = w6;
        o5[7] = w7;
        o5[8] = w8;
        o5[9] = w9;
        o5[10] = w10;
        o5[11] = w11;
        o5[12] = w12;
        o5[13] = w13;
        o5[14] = w14;
        o5[15] = w15;
        o5[16] = w16;
        o5[17] = w17;
        o5[18] = w18;
        if (c5 !== 0) {
          o5[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i5 = k5 - j5;
            var a5 = self2.words[i5] | 0;
            var b4 = num.words[j5] | 0;
            var r6 = a5 * b4;
            var lo = r6 & 67108863;
            ncarry = ncarry + (r6 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN2.prototype._countBits(N4) - 1;
        for (var i5 = 0; i5 < N4; i5++) {
          t5[i5] = this.revBin(i5, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i5 = 0; i5 < l5; i5++) {
          rb |= (x5 & 1) << l5 - i5 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i5 = 0; i5 < N4; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s5 = 1; s5 < N4; s5 <<= 1) {
          var l5 = s5 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s5; j5++) {
              var re = rtws[p5 + j5];
              var ie = itws[p5 + j5];
              var ro = rtws[p5 + j5 + s5];
              var io = itws[p5 + j5 + s5];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p5 + j5] = re + ro;
              itws[p5 + j5] = ie + io;
              rtws[p5 + j5 + s5] = re - ro;
              itws[p5 + j5 + s5] = ie - io;
              if (j5 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N4 = Math.max(m5, n3) | 1;
        var odd = N4 & 1;
        var i5 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var t5 = rws[i5];
          rws[i5] = rws[N4 - i5 - 1];
          rws[N4 - i5 - 1] = t5;
          t5 = iws[i5];
          iws[i5] = -iws[N4 - i5 - 1];
          iws[N4 - i5 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < N4 / 2; i5++) {
          var w6 = Math.round(ws[2 * i5 + 1] / N4) * 8192 + Math.round(ws[2 * i5] / N4) + carry;
          ws[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N4; ++i5) {
          rws[i5] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i5 = 0; i5 < N4; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _6 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _6, rwst, iwst, N4, rbt);
        this.transform(nrws, _6, nrwst, niwst, N4, rbt);
        for (var i5 = 0; i5 < N4; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _6, N4, rbt);
        this.conjugate(rmws, _6, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i5] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN2(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q5 = res.sqr(); i5 < w6.length; i5++, q5 = q5.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        var carryMask = 67108863 >>> 26 - r6 << 26 - r6;
        var i5;
        if (r6 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r6;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r6;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s5 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s5] = this.words[i5];
          }
          for (i5 = 0; i5 < s5; i5++) {
            this.words[i5] = 0;
          }
          this.length += s5;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r6 = bits % 26;
        var s5 = Math.min((bits - r6) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r6 << r6;
        var maskedWords = extended;
        h5 -= s5;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i5 = 0; i5 < s5; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s5;
        }
        if (s5 === 0) {
        } else if (this.length > s5) {
          this.length -= s5;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s5];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h5); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r6 | word >>> r6;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5)
          return false;
        var w6 = this.words[s5];
        return !!(w6 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r6 = bits % 26;
        var s5 = (bits - r6) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s5) {
          return this;
        }
        if (r6 !== 0) {
          s5++;
        }
        this.length = Math.min(s5, this.length);
        if (r6 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r6 << r6;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a5.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m5 = a5.length - b4.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i5 = 0; i5 < q5.length; i5++) {
            q5.words[i5] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b4, 1, m5);
        if (diff.negative === 0) {
          a5 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j5 = m5 - 1; j5 >= 0; j5--) {
          var qj = (a5.words[b4.length + j5] | 0) * 67108864 + (a5.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b4, qj, j5);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b4, 1, j5);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a5
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A6 = new BN2(1);
        var B4 = new BN2(0);
        var C4 = new BN2(0);
        var D3 = new BN2(1);
        var g5 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i5 = 0, im = 1; (x5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x5.iushrn(i5);
            while (i5-- > 0) {
              if (A6.isOdd() || B4.isOdd()) {
                A6.iadd(yp);
                B4.isub(xp);
              }
              A6.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y5.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y5.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D3.isOdd()) {
                C4.iadd(yp);
                D3.isub(xp);
              }
              C4.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A6.isub(C4);
            B4.isub(D3);
          } else {
            y5.isub(x5);
            C4.isub(A6);
            D3.isub(B4);
          }
        }
        return {
          a: C4,
          b: D3,
          gcd: y5.iushln(g5)
        };
      };
      BN2.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a5 = this;
        var b4 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b4.clone();
        while (a5.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a5.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a5.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b4) >= 0) {
            a5.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a5 = this.clone();
        var b4 = num.clone();
        a5.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a5.isEven() && b4.isEven(); shift++) {
          a5.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r6 = a5.cmp(b4);
          if (r6 < 0) {
            var t5 = a5;
            a5 = b4;
            b4 = t5;
          } else if (r6 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a5.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r6 = bit % 26;
        var s5 = (bit - r6) / 26;
        var q5 = 1 << r6;
        if (this.length <= s5) {
          this._expand(s5 + 1);
          this.words[s5] |= q5;
          return this;
        }
        var carry = q5;
        for (var i5 = s5; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a5 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a5 === b4)
            continue;
          if (a5 < b4) {
            res = -1;
          } else if (a5 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN2(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r6 = num;
        var rlen;
        do {
          this.split(r6, this.tmp);
          r6 = this.imulK(r6);
          r6 = r6.iadd(this.tmp);
          rlen = r6.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r6.ucmp(this.p);
        if (cmp === 0) {
          r6.words[0] = 0;
          r6.length = 1;
        } else if (cmp > 0) {
          r6.isub(this.p);
        } else {
          if (r6.strip !== void 0) {
            r6.strip();
          } else {
            r6._strip();
          }
        }
        return r6;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo += w6 * 977;
          num.words[i5] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi = (num.words[i5] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i5] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN2._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert3(a5.negative === 0, "red works only with positives");
        assert3(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b4) {
        assert3((a5.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a5.red && a5.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime)
          return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b4) {
        this._verify2(a5, b4);
        var res = a5.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.imul(b4));
      };
      Red.prototype.mul = function mul(a5, b4) {
        this._verify2(a5, b4);
        return this.imod(a5.mul(b4));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero())
          return a5.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q5 = this.m.subn(1);
        var s5 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s5++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z5 = this.m.bitLength();
        z5 = new BN2(2 * z5 * z5).toRed(this);
        while (this.pow(z5, lpow).cmp(nOne) !== 0) {
          z5.redIAdd(nOne);
        }
        var c5 = this.pow(z5, q5);
        var r6 = this.pow(a5, q5.addn(1).iushrn(1));
        var t5 = this.pow(a5, q5);
        var m5 = s5;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert3(i5 < m5);
          var b4 = this.pow(c5, new BN2(1).iushln(m5 - i5 - 1));
          r6 = r6.redMul(b4);
          c5 = b4.redSqr();
          t5 = t5.redMul(c5);
          m5 = i5;
        }
        return r6;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a5;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r6 = num.umod(this.m);
        return r6 === num ? r6.clone() : r6;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r6 = this.imod(num.mul(this.rinv));
        r6.red = null;
        return r6;
      };
      Mont.prototype.imul = function imul(a5, b4) {
        if (a5.isZero() || b4.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t5 = a5.imul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b4) {
        if (a5.isZero() || b4.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a5.mul(b4);
        var c5 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js
var require_secp256k1v3_lib = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var BN2 = require_bn10();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    exports.privateKeyExport = function(privateKey, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var d5 = new BN2(privateKey);
      if (d5.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
      }
      var point = ec.g.mul(d5);
      return toPublicKey(point.getX(), point.getY(), compressed);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn = new BN2(privateKey);
      if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error("private key range is invalid");
      }
      return bn.invm(ecparams.n).toArrayLike(Buffer2, "be", 32);
    };
    exports.signatureImport = function(sigObj) {
      var r6 = new BN2(sigObj.r);
      if (r6.ucmp(ecparams.n) >= 0) {
        r6 = new BN2(0);
      }
      var s5 = new BN2(sigObj.s);
      if (s5.ucmp(ecparams.n) >= 0) {
        s5 = new BN2(0);
      }
      return Buffer2.concat([r6.toArrayLike(Buffer2, "be", 32), s5.toArrayLike(Buffer2, "be", 32)]);
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var point = ec.keyFromPublic(publicKey);
      var scalar = new BN2(privateKey);
      if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error("scalar was invalid (zero or overflow)");
      }
      var shared = point.pub.mul(scalar);
      return toPublicKey(shared.getX(), shared.getY(), compressed);
    };
    var toPublicKey = function(x5, y5, compressed) {
      var publicKey;
      if (compressed) {
        publicKey = Buffer2.alloc(33);
        publicKey[0] = y5.isOdd() ? 3 : 2;
        x5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 1);
      } else {
        publicKey = Buffer2.alloc(65);
        publicKey[0] = 4;
        x5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 1);
        y5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 33);
      }
      return publicKey;
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js
var require_der5 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer2.from([
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer2.from([
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var result = Buffer2.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return null;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return null;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return null;
      if (length < index + lenb)
        return null;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return null;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return null;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return null;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureImportLax = function(signature) {
      var r6 = Buffer2.alloc(32, 0);
      var s5 = Buffer2.alloc(32, 0);
      var length = signature.length;
      var index = 0;
      if (signature[index++] !== 48) {
        return null;
      }
      var lenbyte = signature[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length) {
          return null;
        }
      }
      if (signature[index++] !== 2) {
        return null;
      }
      var rlen = signature[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          rlen = (rlen << 8) + signature[index];
      }
      if (rlen > length - index) {
        return null;
      }
      var rindex = index;
      index += rlen;
      if (signature[index++] !== 2) {
        return null;
      }
      var slen = signature[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          slen = (slen << 8) + signature[index];
      }
      if (slen > length - index) {
        return null;
      }
      var sindex = index;
      index += slen;
      for (; rlen > 0 && signature[rindex] === 0; rlen -= 1, rindex += 1)
        ;
      if (rlen > 32) {
        return null;
      }
      var rvalue = signature.slice(rindex, rindex + rlen);
      rvalue.copy(r6, 32 - rvalue.length);
      for (; slen > 0 && signature[sindex] === 0; slen -= 1, sindex += 1)
        ;
      if (slen > 32) {
        return null;
      }
      var svalue = signature.slice(sindex, sindex + slen);
      svalue.copy(s5, 32 - svalue.length);
      return { r: r6, s: s5 };
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js
var require_secp256k1v3_adapter = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;
    var secp256k1 = require_secp256k12();
    var secp256k1v3 = require_secp256k1v3_lib();
    var der = require_der5();
    exports.privateKeyVerify = function(privateKey) {
      if (privateKey.length !== 32) {
        return false;
      }
      return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
    };
    exports.privateKeyExport = function(privateKey, compressed) {
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
      return der.privateKeyExport(privateKey, publicKey, compressed);
    };
    exports.privateKeyImport = function(privateKey) {
      privateKey = der.privateKeyImport(privateKey);
      if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {
        return privateKey;
      }
      throw new Error("couldn't import from DER format");
    };
    exports.privateKeyNegate = function(privateKey) {
      return Buffer2.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
    };
    exports.privateKeyModInverse = function(privateKey) {
      if (privateKey.length !== 32) {
        throw new Error("private key length is invalid");
      }
      return Buffer2.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
    };
    exports.privateKeyTweakAdd = function(privateKey, tweak) {
      return Buffer2.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
    };
    exports.privateKeyTweakMul = function(privateKey, tweak) {
      return Buffer2.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
    };
    exports.publicKeyCreate = function(privateKey, compressed) {
      return Buffer2.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
    };
    exports.publicKeyConvert = function(publicKey, compressed) {
      return Buffer2.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
    };
    exports.publicKeyVerify = function(publicKey) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
      }
      return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
    };
    exports.publicKeyTweakAdd = function(publicKey, tweak, compressed) {
      return Buffer2.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    exports.publicKeyTweakMul = function(publicKey, tweak, compressed) {
      return Buffer2.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    exports.publicKeyCombine = function(publicKeys, compressed) {
      var keys2 = [];
      publicKeys.forEach(function(publicKey) {
        keys2.push(Uint8Array.from(publicKey));
      });
      return Buffer2.from(secp256k1.publicKeyCombine(keys2, compressed));
    };
    exports.signatureNormalize = function(signature) {
      return Buffer2.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
    };
    exports.signatureExport = function(signature) {
      return Buffer2.from(secp256k1.signatureExport(Uint8Array.from(signature)));
    };
    exports.signatureImport = function(signature) {
      return Buffer2.from(secp256k1.signatureImport(Uint8Array.from(signature)));
    };
    exports.signatureImportLax = function(signature) {
      if (signature.length === 0) {
        throw new RangeError("signature length is invalid");
      }
      var sigObj = der.signatureImportLax(signature);
      if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
      }
      return secp256k1v3.signatureImport(sigObj);
    };
    exports.sign = function(message, privateKey, options) {
      if (options === null) {
        throw new TypeError("options should be an Object");
      }
      var signOptions = void 0;
      if (options) {
        signOptions = {};
        if (options.data === null) {
          throw new TypeError("options.data should be a Buffer");
        }
        if (options.data) {
          if (options.data.length != 32) {
            throw new RangeError("options.data length is invalid");
          }
          signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
          throw new TypeError("options.noncefn should be a Function");
        }
        if (options.noncefn) {
          signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
            var bufferAlgo = algo != null ? Buffer2.from(algo) : null;
            var bufferData = data != null ? Buffer2.from(data) : null;
            var buffer2 = Buffer2.from("");
            if (options.noncefn) {
              buffer2 = options.noncefn(Buffer2.from(message2), Buffer2.from(privateKey2), bufferAlgo, bufferData, attempt);
            }
            return new Uint8Array(buffer2);
          };
        }
      }
      var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
      return {
        signature: Buffer2.from(sig.signature),
        recovery: sig.recid
      };
    };
    exports.verify = function(message, signature, publicKey) {
      return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
    };
    exports.recover = function(message, signature, recid, compressed) {
      return Buffer2.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
    };
    exports.ecdh = function(publicKey, privateKey) {
      return Buffer2.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError("public key length is invalid");
      }
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      return Buffer2.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js
var require_constants2 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
    var BN2 = require_bn10();
    exports.MAX_INTEGER = new BN2("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN2("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.KECCAK256_NULL = Buffer2.from(exports.KECCAK256_NULL_S, "hex");
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.KECCAK256_RLP_ARRAY = Buffer2.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.KECCAK256_RLP = Buffer2.from(exports.KECCAK256_RLP_S, "hex");
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js
var require_bytes = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;
    var ethjsUtil = require_lib4();
    var BN2 = require_bn10();
    exports.zeros = function(bytes) {
      return Buffer2.allocUnsafe(bytes).fill(0);
    };
    exports.setLengthLeft = function(msg, length, right) {
      if (right === void 0) {
        right = false;
      }
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLength = exports.setLengthLeft;
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = function(a5) {
      a5 = ethjsUtil.stripHexPrefix(a5);
      var first2 = a5[0];
      while (a5.length > 0 && first2.toString() === "0") {
        a5 = a5.slice(1);
        first2 = a5[0];
      }
      return a5;
    };
    exports.stripZeros = exports.unpad;
    exports.toBuffer = function(v5) {
      if (!Buffer2.isBuffer(v5)) {
        if (Array.isArray(v5)) {
          v5 = Buffer2.from(v5);
        } else if (typeof v5 === "string") {
          if (ethjsUtil.isHexString(v5)) {
            v5 = Buffer2.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v5)), "hex");
          } else {
            throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v5);
          }
        } else if (typeof v5 === "number") {
          v5 = ethjsUtil.intToBuffer(v5);
        } else if (v5 === null || v5 === void 0) {
          v5 = Buffer2.allocUnsafe(0);
        } else if (BN2.isBN(v5)) {
          v5 = v5.toArrayLike(Buffer2);
        } else if (v5.toArray) {
          v5 = Buffer2.from(v5.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v5;
    };
    exports.bufferToInt = function(buf) {
      return new BN2(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN2(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer2.from(num.toTwos(256).toArray());
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return ethjsUtil.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.baToJSON = function(ba) {
      if (Buffer2.isBuffer(ba)) {
        return "0x" + ba.toString("hex");
      } else if (ba instanceof Array) {
        var array = [];
        for (var i5 = 0; i5 < ba.length; i5++) {
          array.push(exports.baToJSON(ba[i5]));
        }
        return array;
      }
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js
var require_hash3 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;
    var _a = require_keccak3();
    var keccak224 = _a.keccak224;
    var keccak384 = _a.keccak384;
    var k256 = _a.keccak256;
    var keccak512 = _a.keccak512;
    var createHash = require_browser3();
    var ethjsUtil = require_lib4();
    var rlp = require_dist6();
    var bytes_1 = require_bytes();
    exports.keccak = function(a5, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      if (typeof a5 === "string" && !ethjsUtil.isHexString(a5)) {
        a5 = Buffer2.from(a5, "utf8");
      } else {
        a5 = bytes_1.toBuffer(a5);
      }
      if (!bits)
        bits = 256;
      switch (bits) {
        case 224: {
          return keccak224(a5);
        }
        case 256: {
          return k256(a5);
        }
        case 384: {
          return keccak384(a5);
        }
        case 512: {
          return keccak512(a5);
        }
        default: {
          throw new Error("Invald algorithm: keccak" + bits);
        }
      }
    };
    exports.keccak256 = function(a5) {
      return exports.keccak(a5);
    };
    exports.sha256 = function(a5) {
      a5 = bytes_1.toBuffer(a5);
      return createHash("sha256").update(a5).digest();
    };
    exports.ripemd160 = function(a5, padded) {
      a5 = bytes_1.toBuffer(a5);
      var hash = createHash("rmd160").update(a5).digest();
      if (padded === true) {
        return bytes_1.setLength(hash, 32);
      } else {
        return hash;
      }
    };
    exports.rlphash = function(a5) {
      return exports.keccak(rlp.encode(a5));
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js
var require_account = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;
    var assert3 = require_assert();
    var ethjsUtil = require_lib4();
    var secp256k1 = require_secp256k1v3_adapter();
    var BN2 = require_bn10();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash3();
    exports.zeroAddress = function() {
      var addressLength = 20;
      var addr = bytes_1.zeros(addressLength);
      return bytes_1.bufferToHex(addr);
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddr = exports.zeroAddress();
      return zeroAddr === bytes_1.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address, eip1191ChainId) {
      address = ethjsUtil.stripHexPrefix(address).toLowerCase();
      var prefix = eip1191ChainId !== void 0 ? eip1191ChainId.toString() + "0x" : "";
      var hash = hash_1.keccak(prefix + address).toString("hex");
      var ret = "0x";
      for (var i5 = 0; i5 < address.length; i5++) {
        if (parseInt(hash[i5], 16) >= 8) {
          ret += address[i5].toUpperCase();
        } else {
          ret += address[i5];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address, eip1191ChainId) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;
    };
    exports.generateAddress = function(from4, nonce) {
      from4 = bytes_1.toBuffer(from4);
      var nonceBN = new BN2(nonce);
      if (nonceBN.isZero()) {
        return hash_1.rlphash([from4, null]).slice(-20);
      }
      return hash_1.rlphash([from4, Buffer2.from(nonceBN.toArray())]).slice(-20);
    };
    exports.generateAddress2 = function(from4, salt, initCode) {
      var fromBuf = bytes_1.toBuffer(from4);
      var saltBuf = bytes_1.toBuffer(salt);
      var initCodeBuf = bytes_1.toBuffer(initCode);
      assert3(fromBuf.length === 20);
      assert3(saltBuf.length === 32);
      var address = hash_1.keccak256(Buffer2.concat([Buffer2.from("ff", "hex"), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));
      return address.slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a5 = bytes_1.unpad(address);
      return a5.length === 1 && a5[0] >= 1 && a5[0] <= 8;
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k1.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      if (publicKey.length === 64) {
        return secp256k1.publicKeyVerify(Buffer2.concat([Buffer2.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k1.publicKeyVerify(publicKey);
    };
    exports.pubToAddress = function(pubKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      pubKey = bytes_1.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
      }
      assert3(pubKey.length === 64);
      return hash_1.keccak(pubKey).slice(-20);
    };
    exports.publicToAddress = exports.pubToAddress;
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(exports.privateToPublic(privateKey));
    };
    exports.privateToPublic = function(privateKey) {
      privateKey = bytes_1.toBuffer(privateKey);
      return secp256k1.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey) {
      publicKey = bytes_1.toBuffer(publicKey);
      if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
      }
      return publicKey;
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js
var require_signature3 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
    var secp256k1 = require_secp256k1v3_adapter();
    var BN2 = require_bn10();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash3();
    exports.ecsign = function(msgHash, privateKey, chainId) {
      var sig = secp256k1.sign(msgHash, privateKey);
      var recovery = sig.recovery;
      var ret = {
        r: sig.signature.slice(0, 32),
        s: sig.signature.slice(32, 64),
        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27
      };
      return ret;
    };
    exports.ecrecover = function(msgHash, v5, r6, s5, chainId) {
      var signature = Buffer2.concat([bytes_1.setLength(r6, 32), bytes_1.setLength(s5, 32)], 64);
      var recovery = calculateSigRecovery(v5, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
      return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v5, r6, s5, chainId) {
      var recovery = calculateSigRecovery(v5, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return bytes_1.bufferToHex(Buffer2.concat([bytes_1.setLengthLeft(r6, 32), bytes_1.setLengthLeft(s5, 32), bytes_1.toBuffer(v5)]));
    };
    exports.fromRpcSig = function(sig) {
      var buf = bytes_1.toBuffer(sig);
      if (buf.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v5 = buf[64];
      if (v5 < 27) {
        v5 += 27;
      }
      return {
        v: v5,
        r: buf.slice(0, 32),
        s: buf.slice(32, 64)
      };
    };
    exports.isValidSignature = function(v5, r6, s5, homesteadOrLater, chainId) {
      if (homesteadOrLater === void 0) {
        homesteadOrLater = true;
      }
      var SECP256K1_N_DIV_2 = new BN2("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r6.length !== 32 || s5.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v5, chainId))) {
        return false;
      }
      var rBN = new BN2(r6);
      var sBN = new BN2(s5);
      if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
      }
      if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = Buffer2.from("Ethereum Signed Message:\n" + message.length.toString(), "utf-8");
      return hash_1.keccak(Buffer2.concat([prefix, message]));
    };
    function calculateSigRecovery(v5, chainId) {
      return chainId ? v5 - (2 * chainId + 35) : v5 - 27;
    }
    function isValidSigRecovery(recovery) {
      return recovery === 0 || recovery === 1;
    }
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js
var require_object = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineProperties = void 0;
    var assert3 = require_assert();
    var ethjsUtil = require_lib4();
    var rlp = require_dist6();
    var bytes_1 = require_bytes();
    exports.defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label === void 0) {
          label = false;
        }
        if (label) {
          var obj_1 = {};
          self2._fields.forEach(function(field) {
            obj_1[field] = "0x" + self2[field].toString("hex");
          });
          return obj_1;
        }
        return bytes_1.baToJSON(self2.raw);
      };
      self2.serialize = function serialize() {
        return rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i5) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i5];
        }
        function setter(v5) {
          v5 = bytes_1.toBuffer(v5);
          if (v5.toString("hex") === "00" && !field.allowZero) {
            v5 = Buffer2.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v5 = bytes_1.stripZeros(v5);
            assert3(field.length >= v5.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v5.length === 0) && field.length) {
            assert3(field.length === v5.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self2.raw[i5] = v5;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer2.from(ethjsUtil.stripHexPrefix(data), "hex");
        }
        if (Buffer2.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d5, i5) {
            self2[self2._fields[i5]] = bytes_1.toBuffer(d5);
          });
        } else if (typeof data === "object") {
          var keys_1 = Object.keys(data);
          fields.forEach(function(field) {
            if (keys_1.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys_1.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o5, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o5, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o5[k22] = m5[k5];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m5, exports2) {
      for (var p5 in m5)
        if (p5 !== "default" && !exports2.hasOwnProperty(p5))
          __createBinding2(exports2, m5, p5);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.secp256k1 = exports.rlp = exports.BN = void 0;
    var secp256k1 = require_secp256k1v3_adapter();
    exports.secp256k1 = secp256k1;
    var ethjsUtil = require_lib4();
    var BN2 = require_bn10();
    exports.BN = BN2;
    var rlp = require_dist6();
    exports.rlp = rlp;
    Object.assign(exports, ethjsUtil);
    __exportStar2(require_constants2(), exports);
    __exportStar2(require_account(), exports);
    __exportStar2(require_hash3(), exports);
    __exportStar2(require_signature3(), exports);
    __exportStar2(require_bytes(), exports);
    __exportStar2(require_object(), exports);
  }
});

// node_modules/ethereumjs-abi/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/ethereumjs-abi/lib/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_dist8();
    var BN2 = require_bn10();
    var ABI = function() {
    };
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    ABI.eventID = function(name, types) {
      var sig = name + "(" + types.map(elementaryName).join(",") + ")";
      return utils.keccak256(Buffer2.from(sig));
    };
    ABI.methodID = function(name, types) {
      return ABI.eventID(name, types).slice(0, 4);
    };
    function parseTypeN(type2) {
      return parseInt(/^\D+(\d+)$/.exec(type2)[1], 10);
    }
    function parseTypeNxM(type2) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type2);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type2) {
      var tmp = type2.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type2 = typeof arg;
      if (type2 === "string") {
        if (utils.isHexPrefixed(arg)) {
          return new BN2(utils.stripHexPrefix(arg), 16);
        } else {
          return new BN2(arg, 10);
        }
      } else if (type2 === "number") {
        return new BN2(arg);
      } else if (arg.toArray) {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function parseSignature(sig) {
      var tmp = /^(\w+)\((.*)\)$/.exec(sig);
      if (tmp.length !== 3) {
        throw new Error("Invalid method signature");
      }
      var args = /^(.+)\):\((.+)$/.exec(tmp[2]);
      if (args !== null && args.length === 3) {
        return {
          method: tmp[1],
          args: args[1].split(","),
          retargs: args[2].split(",")
        };
      } else {
        var params = tmp[2].split(",");
        if (params.length === 1 && params[0] === "") {
          params = [];
        }
        return {
          method: tmp[1],
          args: params
        };
      }
    }
    function encodeSingle(type2, arg) {
      var size, num, ret, i5;
      if (type2 === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type2 === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type2 === "string") {
        return encodeSingle("bytes", Buffer2.from(arg, "utf8"));
      } else if (isArray5(type2)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type2);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error("Elements exceed array size: " + size);
        }
        ret = [];
        type2 = type2.slice(0, type2.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i5 in arg) {
          ret.push(encodeSingle(type2, arg[i5]));
        }
        if (size === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer2.concat(ret);
      } else if (type2 === "bytes") {
        arg = Buffer2.from(arg);
        ret = Buffer2.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer2.concat([ret, utils.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type2.startsWith("bytes")) {
        size = parseTypeN(type2);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return utils.setLengthRight(arg, 32);
      } else if (type2.startsWith("uint")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer2, "be", 32);
      } else if (type2.startsWith("int")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        return num.toTwos(256).toArrayLike(Buffer2, "be", 32);
      } else if (type2.startsWith("ufixed")) {
        size = parseTypeNxM(type2);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new BN2(2).pow(new BN2(size[1]))));
      } else if (type2.startsWith("fixed")) {
        size = parseTypeNxM(type2);
        return encodeSingle("int256", parseNumber(arg).mul(new BN2(2).pow(new BN2(size[1]))));
      }
      throw new Error("Unsupported or invalid type: " + type2);
    }
    function decodeSingle(parsedType, data, offset) {
      if (typeof parsedType === "string") {
        parsedType = parseType(parsedType);
      }
      var size, num, ret, i5;
      if (parsedType.name === "address") {
        return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer2, "be", 20).toString("hex");
      } else if (parsedType.name === "bool") {
        return decodeSingle(parsedType.rawType, data, offset).toString() === new BN2(1).toString();
      } else if (parsedType.name === "string") {
        var bytes = decodeSingle(parsedType.rawType, data, offset);
        return Buffer2.from(bytes, "utf8").toString();
      } else if (parsedType.isArray) {
        ret = [];
        size = parsedType.size;
        if (parsedType.size === "dynamic") {
          offset = decodeSingle("uint256", data, offset).toNumber();
          size = decodeSingle("uint256", data, offset).toNumber();
          offset = offset + 32;
        }
        for (i5 = 0; i5 < size; i5++) {
          var decoded = decodeSingle(parsedType.subArray, data, offset);
          ret.push(decoded);
          offset += parsedType.subArray.memoryUsage;
        }
        return ret;
      } else if (parsedType.name === "bytes") {
        offset = decodeSingle("uint256", data, offset).toNumber();
        size = decodeSingle("uint256", data, offset).toNumber();
        return data.slice(offset + 32, offset + 32 + size);
      } else if (parsedType.name.startsWith("bytes")) {
        return data.slice(offset, offset + parsedType.size);
      } else if (parsedType.name.startsWith("uint")) {
        num = new BN2(data.slice(offset, offset + 32), 16, "be");
        if (num.bitLength() > parsedType.size) {
          throw new Error("Decoded int exceeds width: " + parsedType.size + " vs " + num.bitLength());
        }
        return num;
      } else if (parsedType.name.startsWith("int")) {
        num = new BN2(data.slice(offset, offset + 32), 16, "be").fromTwos(256);
        if (num.bitLength() > parsedType.size) {
          throw new Error("Decoded uint exceeds width: " + parsedType.size + " vs " + num.bitLength());
        }
        return num;
      } else if (parsedType.name.startsWith("ufixed")) {
        size = new BN2(2).pow(new BN2(parsedType.size[1]));
        num = decodeSingle("uint256", data, offset);
        if (!num.mod(size).isZero()) {
          throw new Error("Decimals not supported yet");
        }
        return num.div(size);
      } else if (parsedType.name.startsWith("fixed")) {
        size = new BN2(2).pow(new BN2(parsedType.size[1]));
        num = decodeSingle("int256", data, offset);
        if (!num.mod(size).isZero()) {
          throw new Error("Decimals not supported yet");
        }
        return num.div(size);
      }
      throw new Error("Unsupported or invalid type: " + parsedType.name);
    }
    function parseType(type2) {
      var size;
      var ret;
      if (isArray5(type2)) {
        size = parseTypeArray(type2);
        var subArray = type2.slice(0, type2.lastIndexOf("["));
        subArray = parseType(subArray);
        ret = {
          isArray: true,
          name: type2,
          size,
          memoryUsage: size === "dynamic" ? 32 : subArray.memoryUsage * size,
          subArray
        };
        return ret;
      } else {
        var rawType;
        switch (type2) {
          case "address":
            rawType = "uint160";
            break;
          case "bool":
            rawType = "uint8";
            break;
          case "string":
            rawType = "bytes";
            break;
        }
        ret = {
          rawType,
          name: type2,
          memoryUsage: 32
        };
        if (type2.startsWith("bytes") && type2 !== "bytes" || type2.startsWith("uint") || type2.startsWith("int")) {
          ret.size = parseTypeN(type2);
        } else if (type2.startsWith("ufixed") || type2.startsWith("fixed")) {
          ret.size = parseTypeNxM(type2);
        }
        if (type2.startsWith("bytes") && type2 !== "bytes" && (ret.size < 1 || ret.size > 32)) {
          throw new Error("Invalid bytes<N> width: " + ret.size);
        }
        if ((type2.startsWith("uint") || type2.startsWith("int")) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {
          throw new Error("Invalid int/uint<N> width: " + ret.size);
        }
        return ret;
      }
    }
    function isDynamic(type2) {
      return type2 === "string" || type2 === "bytes" || parseTypeArray(type2) === "dynamic";
    }
    function isArray5(type2) {
      return type2.lastIndexOf("]") === type2.length - 1;
    }
    ABI.rawEncode = function(types, values) {
      var output = [];
      var data = [];
      var headLength = 0;
      types.forEach(function(type3) {
        if (isArray5(type3)) {
          var size = parseTypeArray(type3);
          if (size !== "dynamic") {
            headLength += 32 * size;
          } else {
            headLength += 32;
          }
        } else {
          headLength += 32;
        }
      });
      for (var i5 = 0; i5 < types.length; i5++) {
        var type2 = elementaryName(types[i5]);
        var value = values[i5];
        var cur = encodeSingle(type2, value);
        if (isDynamic(type2)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer2.concat(output.concat(data));
    };
    ABI.rawDecode = function(types, data) {
      var ret = [];
      data = Buffer2.from(data);
      var offset = 0;
      for (var i5 = 0; i5 < types.length; i5++) {
        var type2 = elementaryName(types[i5]);
        var parsed = parseType(type2, data, offset);
        var decoded = decodeSingle(parsed, data, offset);
        offset += parsed.memoryUsage;
        ret.push(decoded);
      }
      return ret;
    };
    ABI.simpleEncode = function(method) {
      var args = Array.prototype.slice.call(arguments).slice(1);
      var sig = parseSignature(method);
      if (args.length !== sig.args.length) {
        throw new Error("Argument count mismatch");
      }
      return Buffer2.concat([ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args)]);
    };
    ABI.simpleDecode = function(method, data) {
      var sig = parseSignature(method);
      if (!sig.retargs) {
        throw new Error("No return values in method");
      }
      return ABI.rawDecode(sig.retargs, data);
    };
    function stringify3(type2, value) {
      if (type2.startsWith("address") || type2.startsWith("bytes")) {
        return "0x" + value.toString("hex");
      } else {
        return value.toString();
      }
    }
    ABI.stringify = function(types, values) {
      var ret = [];
      for (var i5 in types) {
        var type2 = types[i5];
        var value = values[i5];
        if (/^[^\[]+\[.*\]$/.test(type2)) {
          value = value.map(function(item) {
            return stringify3(type2, item);
          }).join(", ");
        } else {
          value = stringify3(type2, value);
        }
        ret.push(value);
      }
      return ret;
    };
    ABI.solidityHexValue = function(type2, value, bitsize) {
      var size, num;
      if (isArray5(type2)) {
        var subType = type2.replace(/\[.*?\]/, "");
        if (!isArray5(subType)) {
          var arraySize = parseTypeArray(type2);
          if (arraySize !== "dynamic" && arraySize !== 0 && value.length > arraySize) {
            throw new Error("Elements exceed array size: " + arraySize);
          }
        }
        var arrayValues = value.map(function(v5) {
          return ABI.solidityHexValue(subType, v5, 256);
        });
        return Buffer2.concat(arrayValues);
      } else if (type2 === "bytes") {
        return value;
      } else if (type2 === "string") {
        return Buffer2.from(value, "utf8");
      } else if (type2 === "bool") {
        bitsize = bitsize || 8;
        var padding = Array(bitsize / 4).join("0");
        return Buffer2.from(value ? padding + "1" : padding + "0", "hex");
      } else if (type2 === "address") {
        var bytesize = 20;
        if (bitsize) {
          bytesize = bitsize / 8;
        }
        return utils.setLengthLeft(value, bytesize);
      } else if (type2.startsWith("bytes")) {
        size = parseTypeN(type2);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return utils.setLengthRight(value, size);
      } else if (type2.startsWith("uint")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        bitsize = bitsize || size;
        return num.toArrayLike(Buffer2, "be", bitsize / 8);
      } else if (type2.startsWith("int")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        bitsize = bitsize || size;
        return num.toTwos(size).toArrayLike(Buffer2, "be", bitsize / 8);
      } else {
        throw new Error("Unsupported or invalid type: " + type2);
      }
    };
    ABI.solidityPack = function(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var ret = [];
      for (var i5 = 0; i5 < types.length; i5++) {
        var type2 = elementaryName(types[i5]);
        var value = values[i5];
        ret.push(ABI.solidityHexValue(type2, value, null));
      }
      return Buffer2.concat(ret);
    };
    ABI.soliditySHA3 = function(types, values) {
      return utils.keccak256(ABI.solidityPack(types, values));
    };
    ABI.soliditySHA256 = function(types, values) {
      return utils.sha256(ABI.solidityPack(types, values));
    };
    ABI.solidityRIPEMD160 = function(types, values) {
      return utils.ripemd160(ABI.solidityPack(types, values), true);
    };
    function isNumeric2(c5) {
      return c5 >= "0" && c5 <= "9";
    }
    ABI.fromSerpent = function(sig) {
      var ret = [];
      for (var i5 = 0; i5 < sig.length; i5++) {
        var type2 = sig[i5];
        if (type2 === "s") {
          ret.push("bytes");
        } else if (type2 === "b") {
          var tmp = "bytes";
          var j5 = i5 + 1;
          while (j5 < sig.length && isNumeric2(sig[j5])) {
            tmp += sig[j5] - "0";
            j5++;
          }
          i5 = j5 - 1;
          ret.push(tmp);
        } else if (type2 === "i") {
          ret.push("int256");
        } else if (type2 === "a") {
          ret.push("int256[]");
        } else {
          throw new Error("Unsupported or invalid type: " + type2);
        }
      }
      return ret;
    };
    ABI.toSerpent = function(types) {
      var ret = [];
      for (var i5 = 0; i5 < types.length; i5++) {
        var type2 = types[i5];
        if (type2 === "bytes") {
          ret.push("s");
        } else if (type2.startsWith("bytes")) {
          ret.push("b" + parseTypeN(type2));
        } else if (type2 === "int256") {
          ret.push("i");
        } else if (type2 === "int256[]") {
          ret.push("a");
        } else {
          throw new Error("Unsupported or invalid type: " + type2);
        }
      }
      return ret.join("");
    };
    module.exports = ABI;
  }
});

// node_modules/ethereumjs-abi/index.js
var require_ethereumjs_abi = __commonJS({
  "node_modules/ethereumjs-abi/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_lib5();
  }
});

// node_modules/eth-sig-util/index.js
var require_eth_sig_util = __commonJS({
  "node_modules/eth-sig-util/index.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ethUtil = require_dist7();
    var ethAbi = require_ethereumjs_abi();
    module.exports = {
      concatSig: function(v5, r6, s5) {
        const rSig = ethUtil.fromSigned(r6);
        const sSig = ethUtil.fromSigned(s5);
        const vSig = ethUtil.bufferToInt(v5);
        const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString("hex"), 64);
        const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString("hex"), 64);
        const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));
        return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString("hex");
      },
      normalize: function(input) {
        if (!input)
          return;
        if (typeof input === "number") {
          const buffer2 = ethUtil.toBuffer(input);
          input = ethUtil.bufferToHex(buffer2);
        }
        if (typeof input !== "string") {
          var msg = "eth-sig-util.normalize() requires hex string or integer input.";
          msg += " received " + typeof input + ": " + input;
          throw new Error(msg);
        }
        return ethUtil.addHexPrefix(input.toLowerCase());
      },
      personalSign: function(privateKey, msgParams) {
        var message = ethUtil.toBuffer(msgParams.data);
        var msgHash = ethUtil.hashPersonalMessage(message);
        var sig = ethUtil.ecsign(msgHash, privateKey);
        var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
        return serialized;
      },
      recoverPersonalSignature: function(msgParams) {
        const publicKey = getPublicKeyFor(msgParams);
        const sender = ethUtil.publicToAddress(publicKey);
        const senderHex = ethUtil.bufferToHex(sender);
        return senderHex;
      },
      extractPublicKey: function(msgParams) {
        const publicKey = getPublicKeyFor(msgParams);
        return "0x" + publicKey.toString("hex");
      },
      typedSignatureHash: function(typedData) {
        const hashBuffer = typedSignatureHash(typedData);
        return ethUtil.bufferToHex(hashBuffer);
      },
      signTypedData: function(privateKey, msgParams) {
        const msgHash = typedSignatureHash(msgParams.data);
        const sig = ethUtil.ecsign(msgHash, privateKey);
        return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
      },
      recoverTypedSignature: function(msgParams) {
        const msgHash = typedSignatureHash(msgParams.data);
        const publicKey = recoverPublicKey(msgHash, msgParams.sig);
        const sender = ethUtil.publicToAddress(publicKey);
        return ethUtil.bufferToHex(sender);
      }
    };
    function typedSignatureHash(typedData) {
      const error2 = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length)
        throw error2;
      const data = typedData.map(function(e5) {
        return e5.type === "bytes" ? ethUtil.toBuffer(e5.value) : e5.value;
      });
      const types = typedData.map(function(e5) {
        return e5.type;
      });
      const schema = typedData.map(function(e5) {
        if (!e5.name)
          throw error2;
        return e5.type + " " + e5.name;
      });
      return ethAbi.soliditySHA3(
        ["bytes32", "bytes32"],
        [
          ethAbi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
          ethAbi.soliditySHA3(types, data)
        ]
      );
    }
    function recoverPublicKey(hash, sig) {
      const signature = ethUtil.toBuffer(sig);
      const sigParams = ethUtil.fromRpcSig(signature);
      return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);
    }
    function getPublicKeyFor(msgParams) {
      const message = ethUtil.toBuffer(msgParams.data);
      const msgHash = ethUtil.hashPersonalMessage(message);
      return recoverPublicKey(msgHash, msgParams.sig);
    }
    function padWithZeroes(number, length) {
      var myString = "" + number;
      while (myString.length < length) {
        myString = "0" + myString;
      }
      return myString;
    }
  }
});

// node_modules/semaphore/lib/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/semaphore/lib/semaphore.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    (function(global2) {
      "use strict";
      var nextTick3 = function(fn) {
        setTimeout(fn, 0);
      };
      if (typeof process != "undefined" && process && typeof process.nextTick == "function") {
        nextTick3 = process.nextTick;
      }
      function semaphore(capacity) {
        var semaphore2 = {
          capacity: capacity || 1,
          current: 0,
          queue: [],
          firstHere: false,
          take: function() {
            if (semaphore2.firstHere === false) {
              semaphore2.current++;
              semaphore2.firstHere = true;
              var isFirst = 1;
            } else {
              var isFirst = 0;
            }
            var item = { n: 1 };
            if (typeof arguments[0] == "function") {
              item.task = arguments[0];
            } else {
              item.n = arguments[0];
            }
            if (arguments.length >= 2) {
              if (typeof arguments[1] == "function")
                item.task = arguments[1];
              else
                item.n = arguments[1];
            }
            var task = item.task;
            item.task = function() {
              task(semaphore2.leave);
            };
            if (semaphore2.current + item.n - isFirst > semaphore2.capacity) {
              if (isFirst === 1) {
                semaphore2.current--;
                semaphore2.firstHere = false;
              }
              return semaphore2.queue.push(item);
            }
            semaphore2.current += item.n - isFirst;
            item.task(semaphore2.leave);
            if (isFirst === 1)
              semaphore2.firstHere = false;
          },
          leave: function(n3) {
            n3 = n3 || 1;
            semaphore2.current -= n3;
            if (!semaphore2.queue.length) {
              if (semaphore2.current < 0) {
                throw new Error("leave called too many times.");
              }
              return;
            }
            var item = semaphore2.queue[0];
            if (item.n + semaphore2.current > semaphore2.capacity) {
              return;
            }
            semaphore2.queue.shift();
            semaphore2.current += item.n;
            nextTick3(item.task);
          },
          available: function(n3) {
            n3 = n3 || 1;
            return semaphore2.current + n3 <= semaphore2.capacity;
          }
        };
        return semaphore2;
      }
      ;
      if (typeof exports === "object") {
        module.exports = semaphore;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return semaphore;
        });
      } else {
        global2.semaphore = semaphore;
      }
    })(exports);
  }
});

// node_modules/web3-provider-engine/util/estimate-gas.js
var require_estimate_gas = __commonJS({
  "node_modules/web3-provider-engine/util/estimate-gas.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var createPayload = require_create_payload();
    module.exports = estimateGas;
    function estimateGas(provider, txParams, cb) {
      provider.sendAsync(createPayload({
        method: "eth_estimateGas",
        params: [txParams]
      }), function(err, res) {
        if (err) {
          if (err.message === "no contract code at given address") {
            return cb(null, "0xcf08");
          } else {
            return cb(err);
          }
        }
        cb(null, res.result);
      });
    }
  }
});

// node_modules/web3-provider-engine/subproviders/hooked-wallet.js
var require_hooked_wallet = __commonJS({
  "node_modules/web3-provider-engine/subproviders/hooked-wallet.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var waterfall = require_waterfall();
    var parallel = require_parallel2();
    var inherits2 = require_util().inherits;
    var ethUtil = require_dist7();
    var sigUtil = require_eth_sig_util();
    var extend = require_immutable();
    var Semaphore = require_semaphore();
    var Subprovider = require_subprovider();
    var estimateGas = require_estimate_gas();
    var hexRegex = /^[0-9A-Fa-f]+$/g;
    module.exports = HookedWalletSubprovider2;
    inherits2(HookedWalletSubprovider2, Subprovider);
    function HookedWalletSubprovider2(opts) {
      const self2 = this;
      self2.nonceLock = Semaphore(1);
      if (opts.getAccounts)
        self2.getAccounts = opts.getAccounts;
      if (opts.processTransaction)
        self2.processTransaction = opts.processTransaction;
      if (opts.processMessage)
        self2.processMessage = opts.processMessage;
      if (opts.processPersonalMessage)
        self2.processPersonalMessage = opts.processPersonalMessage;
      if (opts.processTypedMessage)
        self2.processTypedMessage = opts.processTypedMessage;
      self2.approveTransaction = opts.approveTransaction || self2.autoApprove;
      self2.approveMessage = opts.approveMessage || self2.autoApprove;
      self2.approvePersonalMessage = opts.approvePersonalMessage || self2.autoApprove;
      self2.approveDecryptMessage = opts.approveDecryptMessage || self2.autoApprove;
      self2.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self2.autoApprove;
      self2.approveTypedMessage = opts.approveTypedMessage || self2.autoApprove;
      if (opts.signTransaction)
        self2.signTransaction = opts.signTransaction || mustProvideInConstructor("signTransaction");
      if (opts.signMessage)
        self2.signMessage = opts.signMessage || mustProvideInConstructor("signMessage");
      if (opts.signPersonalMessage)
        self2.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor("signPersonalMessage");
      if (opts.decryptMessage)
        self2.decryptMessage = opts.decryptMessage || mustProvideInConstructor("decryptMessage");
      if (opts.encryptionPublicKey)
        self2.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor("encryptionPublicKey");
      if (opts.signTypedMessage)
        self2.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor("signTypedMessage");
      if (opts.recoverPersonalSignature)
        self2.recoverPersonalSignature = opts.recoverPersonalSignature;
      if (opts.publishTransaction)
        self2.publishTransaction = opts.publishTransaction;
      self2.estimateGas = opts.estimateGas || self2.estimateGas;
      self2.getGasPrice = opts.getGasPrice || self2.getGasPrice;
    }
    HookedWalletSubprovider2.prototype.handleRequest = function(payload, next, end) {
      const self2 = this;
      self2._parityRequests = {};
      self2._parityRequestCount = 0;
      let txParams, msgParams, extraParams;
      let message, address;
      switch (payload.method) {
        case "eth_coinbase":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            let result = accounts[0] || null;
            end(null, result);
          });
          return;
        case "eth_accounts":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            end(null, accounts);
          });
          return;
        case "eth_sendTransaction":
          txParams = payload.params[0];
          waterfall([
            (cb) => self2.validateTransaction(txParams, cb),
            (cb) => self2.processTransaction(txParams, cb)
          ], end);
          return;
        case "eth_signTransaction":
          txParams = payload.params[0];
          waterfall([
            (cb) => self2.validateTransaction(txParams, cb),
            (cb) => self2.processSignTransaction(txParams, cb)
          ], end);
          return;
        case "eth_sign":
          address = payload.params[0];
          message = payload.params[1];
          extraParams = payload.params[2] || {};
          msgParams = extend(extraParams, {
            from: address,
            data: message
          });
          waterfall([
            (cb) => self2.validateMessage(msgParams, cb),
            (cb) => self2.processMessage(msgParams, cb)
          ], end);
          return;
        case "personal_sign":
          return function() {
            const first2 = payload.params[0];
            const second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first2)) {
              let warning = `The eth_personalSign method requires params ordered `;
              warning += `[message, address]. This was previously handled incorrectly, `;
              warning += `and has been corrected automatically. `;
              warning += `Please switch this param order for smooth behavior in the future.`;
              console.warn(warning);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([
              (cb) => self2.validatePersonalMessage(msgParams, cb),
              (cb) => self2.processPersonalMessage(msgParams, cb)
            ], end);
          }();
        case "eth_decryptMessage":
          return function() {
            const first2 = payload.params[0];
            const second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first2)) {
              let warning = `The eth_decryptMessage method requires params ordered `;
              warning += `[message, address]. This was previously handled incorrectly, `;
              warning += `and has been corrected automatically. `;
              warning += `Please switch this param order for smooth behavior in the future.`;
              console.warn(warning);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([
              (cb) => self2.validateDecryptMessage(msgParams, cb),
              (cb) => self2.processDecryptMessage(msgParams, cb)
            ], end);
          }();
        case "encryption_public_key":
          return function() {
            const address2 = payload.params[0];
            waterfall([
              (cb) => self2.validateEncryptionPublicKey(address2, cb),
              (cb) => self2.processEncryptionPublicKey(address2, cb)
            ], end);
          }();
        case "personal_ecRecover":
          return function() {
            message = payload.params[0];
            let signature = payload.params[1];
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              sig: signature,
              data: message
            });
            self2.recoverPersonalSignature(msgParams, end);
          }();
        case "eth_signTypedData":
        case "eth_signTypedData_v3":
        case "eth_signTypedData_v4":
          return function() {
            const first2 = payload.params[0];
            const second = payload.params[1];
            if (resemblesAddress(first2)) {
              address = first2;
              message = second;
            } else {
              message = first2;
              address = second;
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([
              (cb) => self2.validateTypedMessage(msgParams, cb),
              (cb) => self2.processTypedMessage(msgParams, cb)
            ], end);
          }();
        case "parity_postTransaction":
          txParams = payload.params[0];
          self2.parityPostTransaction(txParams, end);
          return;
        case "parity_postSign":
          address = payload.params[0];
          message = payload.params[1];
          self2.parityPostSign(address, message, end);
          return;
        case "parity_checkRequest":
          return function() {
            const requestId = payload.params[0];
            self2.parityCheckRequest(requestId, end);
          }();
        case "parity_defaultAccount":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            const account = accounts[0] || null;
            end(null, account);
          });
          return;
        default:
          next();
          return;
      }
    };
    HookedWalletSubprovider2.prototype.getAccounts = function(cb) {
      cb(null, []);
    };
    HookedWalletSubprovider2.prototype.processTransaction = function(txParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveTransaction(txParams, cb2),
        (didApprove, cb2) => self2.checkApproval("transaction", didApprove, cb2),
        (cb2) => self2.finalizeAndSubmitTx(txParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processSignTransaction = function(txParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveTransaction(txParams, cb2),
        (didApprove, cb2) => self2.checkApproval("transaction", didApprove, cb2),
        (cb2) => self2.finalizeTx(txParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
        (cb2) => self2.signMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processPersonalMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approvePersonalMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
        (cb2) => self2.signPersonalMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processDecryptMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveDecryptMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("decryptMessage", didApprove, cb2),
        (cb2) => self2.decryptMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processEncryptionPublicKey = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveEncryptionPublicKey(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("encryptionPublicKey", didApprove, cb2),
        (cb2) => self2.encryptionPublicKey(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processTypedMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveTypedMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
        (cb2) => self2.signTypedMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.autoApprove = function(txParams, cb) {
      cb(null, true);
    };
    HookedWalletSubprovider2.prototype.checkApproval = function(type2, didApprove, cb) {
      cb(didApprove ? null : new Error("User denied " + type2 + " signature."));
    };
    HookedWalletSubprovider2.prototype.parityPostTransaction = function(txParams, cb) {
      const self2 = this;
      const count2 = self2._parityRequestCount;
      const reqId = `0x${count2.toString(16)}`;
      self2._parityRequestCount++;
      self2.emitPayload({
        method: "eth_sendTransaction",
        params: [txParams]
      }, function(error2, res) {
        if (error2) {
          self2._parityRequests[reqId] = { error: error2 };
          return;
        }
        const txHash = res.result;
        self2._parityRequests[reqId] = txHash;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider2.prototype.parityPostSign = function(address, message, cb) {
      const self2 = this;
      const count2 = self2._parityRequestCount;
      const reqId = `0x${count2.toString(16)}`;
      self2._parityRequestCount++;
      self2.emitPayload({
        method: "eth_sign",
        params: [address, message]
      }, function(error2, res) {
        if (error2) {
          self2._parityRequests[reqId] = { error: error2 };
          return;
        }
        const result = res.result;
        self2._parityRequests[reqId] = result;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider2.prototype.parityCheckRequest = function(reqId, cb) {
      const self2 = this;
      const result = self2._parityRequests[reqId] || null;
      if (!result)
        return cb(null, null);
      if (result.error)
        return cb(result.error);
      cb(null, result);
    };
    HookedWalletSubprovider2.prototype.recoverPersonalSignature = function(msgParams, cb) {
      let senderHex;
      try {
        senderHex = sigUtil.recoverPersonalSignature(msgParams);
      } catch (err) {
        return cb(err);
      }
      cb(null, senderHex);
    };
    HookedWalletSubprovider2.prototype.validateTransaction = function(txParams, cb) {
      const self2 = this;
      if (txParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign transaction.`));
      self2.validateSender(txParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign transaction for this address: "${txParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateMessage = function(msgParams, cb) {
      const self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign message.`));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validatePersonalMessage = function(msgParams, cb) {
      const self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign personal message.`));
      if (msgParams.data === void 0)
        return cb(new Error(`Undefined message - message required to sign personal message.`));
      if (!isValidHex(msgParams.data))
        return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateDecryptMessage = function(msgParams, cb) {
      const self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to decrypt message.`));
      if (msgParams.data === void 0)
        return cb(new Error(`Undefined message - message required to decrypt message.`));
      if (!isValidHex(msgParams.data))
        return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to decrypt message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateEncryptionPublicKey = function(address, cb) {
      const self2 = this;
      self2.validateSender(address, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: "${address}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateTypedMessage = function(msgParams, cb) {
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign typed data.`));
      if (msgParams.data === void 0)
        return cb(new Error(`Undefined data - message required to sign typed data.`));
      this.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateSender = function(senderAddress, cb) {
      const self2 = this;
      if (!senderAddress)
        return cb(null, false);
      self2.getAccounts(function(err, accounts) {
        if (err)
          return cb(err);
        const senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;
        cb(null, senderIsValid);
      });
    };
    HookedWalletSubprovider2.prototype.finalizeAndSubmitTx = function(txParams, cb) {
      const self2 = this;
      self2.nonceLock.take(function() {
        waterfall([
          self2.fillInTxExtras.bind(self2, txParams),
          self2.signTransaction.bind(self2),
          self2.publishTransaction.bind(self2)
        ], function(err, txHash) {
          self2.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, txHash);
        });
      });
    };
    HookedWalletSubprovider2.prototype.finalizeTx = function(txParams, cb) {
      const self2 = this;
      self2.nonceLock.take(function() {
        waterfall([
          self2.fillInTxExtras.bind(self2, txParams),
          self2.signTransaction.bind(self2)
        ], function(err, signedTx) {
          self2.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, { raw: signedTx, tx: txParams });
        });
      });
    };
    HookedWalletSubprovider2.prototype.publishTransaction = function(rawTx, cb) {
      const self2 = this;
      self2.emitPayload({
        method: "eth_sendRawTransaction",
        params: [rawTx]
      }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider2.prototype.estimateGas = function(txParams, cb) {
      const self2 = this;
      estimateGas(self2.engine, txParams, cb);
    };
    HookedWalletSubprovider2.prototype.getGasPrice = function(cb) {
      const self2 = this;
      self2.emitPayload({ method: "eth_gasPrice", params: [] }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider2.prototype.fillInTxExtras = function(txParams, cb) {
      const self2 = this;
      const address = txParams.from;
      const tasks = {};
      if (txParams.gasPrice === void 0) {
        tasks.gasPrice = self2.getGasPrice.bind(self2);
      }
      if (txParams.nonce === void 0) {
        tasks.nonce = self2.emitPayload.bind(self2, { method: "eth_getTransactionCount", params: [address, "pending"] });
      }
      if (txParams.gas === void 0) {
        tasks.gas = self2.estimateGas.bind(self2, cloneTxParams(txParams));
      }
      parallel(tasks, function(err, taskResults) {
        if (err)
          return cb(err);
        const result = {};
        if (taskResults.gasPrice)
          result.gasPrice = taskResults.gasPrice;
        if (taskResults.nonce)
          result.nonce = taskResults.nonce.result;
        if (taskResults.gas)
          result.gas = taskResults.gas;
        cb(null, extend(txParams, result));
      });
    };
    function cloneTxParams(txParams) {
      return {
        from: txParams.from,
        to: txParams.to,
        value: txParams.value,
        data: txParams.data,
        gas: txParams.gas,
        gasPrice: txParams.gasPrice,
        nonce: txParams.nonce
      };
    }
    function toLowerCase(string) {
      return string.toLowerCase();
    }
    function resemblesAddress(string) {
      const fixed = ethUtil.addHexPrefix(string);
      const isValid = ethUtil.isValidAddress(fixed);
      return isValid;
    }
    function resemblesData(string) {
      const fixed = ethUtil.addHexPrefix(string);
      const isValidAddress2 = ethUtil.isValidAddress(fixed);
      return !isValidAddress2 && isValidHex(string);
    }
    function isValidHex(data) {
      const isString2 = typeof data === "string";
      if (!isString2)
        return false;
      const isHexPrefixed = data.slice(0, 2) === "0x";
      if (!isHexPrefixed)
        return false;
      const nonPrefixed = data.slice(2);
      const isValid = nonPrefixed.match(hexRegex);
      return isValid;
    }
    function mustProvideInConstructor(methodName) {
      return function(params, cb) {
        cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide "' + methodName + '" fn in constructor options'));
      };
    }
  }
});

// node_modules/ethereum-common/params.json
var require_params = __commonJS({
  "node_modules/ethereum-common/params.json"(exports, module) {
    module.exports = {
      genesisGasLimit: {
        v: 5e3,
        d: "Gas limit of the Genesis block."
      },
      genesisDifficulty: {
        v: 17179869184,
        d: "Difficulty of the Genesis block."
      },
      genesisNonce: {
        v: "0x0000000000000042",
        d: "the geneis nonce"
      },
      genesisExtraData: {
        v: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
        d: "extra data "
      },
      genesisHash: {
        v: "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3",
        d: "genesis hash"
      },
      genesisStateRoot: {
        v: "0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544",
        d: "the genesis state root"
      },
      minGasLimit: {
        v: 5e3,
        d: "Minimum the gas limit may ever be."
      },
      gasLimitBoundDivisor: {
        v: 1024,
        d: "The bound divisor of the gas limit, used in update calculations."
      },
      minimumDifficulty: {
        v: 131072,
        d: "The minimum that the difficulty may ever be."
      },
      difficultyBoundDivisor: {
        v: 2048,
        d: "The bound divisor of the difficulty, used in the update calculations."
      },
      durationLimit: {
        v: 13,
        d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not."
      },
      maximumExtraDataSize: {
        v: 32,
        d: "Maximum size extra data may be after Genesis."
      },
      epochDuration: {
        v: 3e4,
        d: "Duration between proof-of-work epochs."
      },
      stackLimit: {
        v: 1024,
        d: "Maximum size of VM stack allowed."
      },
      callCreateDepth: {
        v: 1024,
        d: "Maximum depth of call/create stack."
      },
      tierStepGas: {
        v: [0, 2, 3, 5, 8, 10, 20],
        d: "Once per operation, for a selection of them."
      },
      expGas: {
        v: 10,
        d: "Once per EXP instuction."
      },
      expByteGas: {
        v: 10,
        d: "Times ceil(log256(exponent)) for the EXP instruction."
      },
      sha3Gas: {
        v: 30,
        d: "Once per SHA3 operation."
      },
      sha3WordGas: {
        v: 6,
        d: "Once per word of the SHA3 operation's data."
      },
      sloadGas: {
        v: 50,
        d: "Once per SLOAD operation."
      },
      sstoreSetGas: {
        v: 2e4,
        d: "Once per SSTORE operation if the zeroness changes from zero."
      },
      sstoreResetGas: {
        v: 5e3,
        d: "Once per SSTORE operation if the zeroness does not change from zero."
      },
      sstoreRefundGas: {
        v: 15e3,
        d: "Once per SSTORE operation if the zeroness changes to zero."
      },
      jumpdestGas: {
        v: 1,
        d: "Refunded gas, once per SSTORE operation if the zeroness changes to zero."
      },
      logGas: {
        v: 375,
        d: "Per LOG* operation."
      },
      logDataGas: {
        v: 8,
        d: "Per byte in a LOG* operation's data."
      },
      logTopicGas: {
        v: 375,
        d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas."
      },
      createGas: {
        v: 32e3,
        d: "Once per CREATE operation & contract-creation transaction."
      },
      callGas: {
        v: 40,
        d: "Once per CALL operation & message call transaction."
      },
      callStipend: {
        v: 2300,
        d: "Free gas given at beginning of call."
      },
      callValueTransferGas: {
        v: 9e3,
        d: "Paid for CALL when the value transfor is non-zero."
      },
      callNewAccountGas: {
        v: 25e3,
        d: "Paid for CALL when the destination address didn't exist prior."
      },
      suicideRefundGas: {
        v: 24e3,
        d: "Refunded following a suicide operation."
      },
      memoryGas: {
        v: 3,
        d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL."
      },
      quadCoeffDiv: {
        v: 512,
        d: "Divisor for the quadratic particle of the memory cost equation."
      },
      createDataGas: {
        v: 200,
        d: ""
      },
      txGas: {
        v: 21e3,
        d: "Per transaction. NOTE: Not payable on data of calls between transactions."
      },
      txCreation: {
        v: 32e3,
        d: "the cost of creating a contract via tx"
      },
      txDataZeroGas: {
        v: 4,
        d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions."
      },
      txDataNonZeroGas: {
        v: 68,
        d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions."
      },
      copyGas: {
        v: 3,
        d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added."
      },
      ecrecoverGas: {
        v: 3e3,
        d: ""
      },
      sha256Gas: {
        v: 60,
        d: ""
      },
      sha256WordGas: {
        v: 12,
        d: ""
      },
      ripemd160Gas: {
        v: 600,
        d: ""
      },
      ripemd160WordGas: {
        v: 120,
        d: ""
      },
      identityGas: {
        v: 15,
        d: ""
      },
      identityWordGas: {
        v: 3,
        d: ""
      },
      minerReward: {
        v: "5000000000000000000",
        d: "the amount a miner get rewarded for mining a block"
      },
      ommerReward: {
        v: "625000000000000000",
        d: "The amount of wei a miner of an uncle block gets for being inculded in the blockchain"
      },
      niblingReward: {
        v: "156250000000000000",
        d: "the amount a miner gets for inculding a uncle"
      },
      homeSteadForkNumber: {
        v: 115e4,
        d: "the block that the Homestead fork started at"
      },
      homesteadRepriceForkNumber: {
        v: 2463e3,
        d: "the block that the Homestead Reprice (EIP150) fork started at"
      },
      timebombPeriod: {
        v: 1e5,
        d: "Exponential difficulty timebomb period"
      },
      freeBlockPeriod: {
        v: 2
      }
    };
  }
});

// node_modules/ethereumjs-tx/es5/index.js
var require_es5 = __commonJS({
  "node_modules/ethereumjs-tx/es5/index.js"(exports, module) {
    "use strict";
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ethUtil = require_dist7();
    var fees = require_params();
    var BN2 = ethUtil.BN;
    var N_DIV_2 = new BN2("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
    var Transaction = function() {
      function Transaction2(data) {
        _classCallCheck(this, Transaction2);
        data = data || {};
        var fields = [{
          name: "nonce",
          length: 32,
          allowLess: true,
          default: new Buffer2([])
        }, {
          name: "gasPrice",
          length: 32,
          allowLess: true,
          default: new Buffer2([])
        }, {
          name: "gasLimit",
          alias: "gas",
          length: 32,
          allowLess: true,
          default: new Buffer2([])
        }, {
          name: "to",
          allowZero: true,
          length: 20,
          default: new Buffer2([])
        }, {
          name: "value",
          length: 32,
          allowLess: true,
          default: new Buffer2([])
        }, {
          name: "data",
          alias: "input",
          allowZero: true,
          default: new Buffer2([])
        }, {
          name: "v",
          allowZero: true,
          default: new Buffer2([28])
        }, {
          name: "r",
          length: 32,
          allowZero: true,
          allowLess: true,
          default: new Buffer2([])
        }, {
          name: "s",
          length: 32,
          allowZero: true,
          allowLess: true,
          default: new Buffer2([])
        }];
        ethUtil.defineProperties(this, fields, data);
        Object.defineProperty(this, "from", {
          enumerable: true,
          configurable: true,
          get: this.getSenderAddress.bind(this)
        });
        var sigV = ethUtil.bufferToInt(this.v);
        var chainId = Math.floor((sigV - 35) / 2);
        if (chainId < 0)
          chainId = 0;
        this._chainId = chainId || data.chainId || 0;
        this._homestead = true;
      }
      Transaction2.prototype.toCreationAddress = function toCreationAddress() {
        return this.to.toString("hex") === "";
      };
      Transaction2.prototype.hash = function hash(includeSignature) {
        if (includeSignature === void 0)
          includeSignature = true;
        var items = void 0;
        if (includeSignature) {
          items = this.raw;
        } else {
          if (this._chainId > 0) {
            var raw = this.raw.slice();
            this.v = this._chainId;
            this.r = 0;
            this.s = 0;
            items = this.raw;
            this.raw = raw;
          } else {
            items = this.raw.slice(0, 6);
          }
        }
        return ethUtil.rlphash(items);
      };
      Transaction2.prototype.getChainId = function getChainId() {
        return this._chainId;
      };
      Transaction2.prototype.getSenderAddress = function getSenderAddress() {
        if (this._from) {
          return this._from;
        }
        var pubkey = this.getSenderPublicKey();
        this._from = ethUtil.publicToAddress(pubkey);
        return this._from;
      };
      Transaction2.prototype.getSenderPublicKey = function getSenderPublicKey() {
        if (!this._senderPubKey || !this._senderPubKey.length) {
          if (!this.verifySignature())
            throw new Error("Invalid Signature");
        }
        return this._senderPubKey;
      };
      Transaction2.prototype.verifySignature = function verifySignature() {
        var msgHash = this.hash(false);
        if (this._homestead && new BN2(this.s).cmp(N_DIV_2) === 1) {
          return false;
        }
        try {
          var v5 = ethUtil.bufferToInt(this.v);
          if (this._chainId > 0) {
            v5 -= this._chainId * 2 + 8;
          }
          this._senderPubKey = ethUtil.ecrecover(msgHash, v5, this.r, this.s);
        } catch (e5) {
          return false;
        }
        return !!this._senderPubKey;
      };
      Transaction2.prototype.sign = function sign(privateKey) {
        var msgHash = this.hash(false);
        var sig = ethUtil.ecsign(msgHash, privateKey);
        if (this._chainId > 0) {
          sig.v += this._chainId * 2 + 8;
        }
        Object.assign(this, sig);
      };
      Transaction2.prototype.getDataFee = function getDataFee() {
        var data = this.raw[5];
        var cost = new BN2(0);
        for (var i5 = 0; i5 < data.length; i5++) {
          data[i5] === 0 ? cost.iaddn(fees.txDataZeroGas.v) : cost.iaddn(fees.txDataNonZeroGas.v);
        }
        return cost;
      };
      Transaction2.prototype.getBaseFee = function getBaseFee() {
        var fee = this.getDataFee().iaddn(fees.txGas.v);
        if (this._homestead && this.toCreationAddress()) {
          fee.iaddn(fees.txCreation.v);
        }
        return fee;
      };
      Transaction2.prototype.getUpfrontCost = function getUpfrontCost() {
        return new BN2(this.gasLimit).imul(new BN2(this.gasPrice)).iadd(new BN2(this.value));
      };
      Transaction2.prototype.validate = function validate(stringError) {
        var errors2 = [];
        if (!this.verifySignature()) {
          errors2.push("Invalid Signature");
        }
        if (this.getBaseFee().cmp(new BN2(this.gasLimit)) > 0) {
          errors2.push(["gas limit is too low. Need at least " + this.getBaseFee()]);
        }
        if (stringError === void 0 || stringError === false) {
          return errors2.length === 0;
        } else {
          return errors2.join(" ");
        }
      };
      return Transaction2;
    }();
    module.exports = Transaction;
  }
});

// node_modules/web3-provider-engine/subproviders/nonce-tracker.js
var require_nonce_tracker = __commonJS({
  "node_modules/web3-provider-engine/subproviders/nonce-tracker.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_util().inherits;
    var Transaction = require_es5();
    var ethUtil = require_dist7();
    var Subprovider = require_subprovider();
    var blockTagForPayload = require_rpc_cache_utils().blockTagForPayload;
    module.exports = NonceTrackerSubprovider;
    inherits2(NonceTrackerSubprovider, Subprovider);
    function NonceTrackerSubprovider(opts) {
      const self2 = this;
      self2.nonceCache = {};
    }
    NonceTrackerSubprovider.prototype.handleRequest = function(payload, next, end) {
      const self2 = this;
      switch (payload.method) {
        case "eth_getTransactionCount":
          var blockTag = blockTagForPayload(payload);
          var address = payload.params[0].toLowerCase();
          var cachedResult = self2.nonceCache[address];
          if (blockTag === "pending") {
            if (cachedResult) {
              end(null, cachedResult);
            } else {
              next(function(err, result, cb) {
                if (err)
                  return cb();
                if (self2.nonceCache[address] === void 0) {
                  self2.nonceCache[address] = result;
                }
                cb();
              });
            }
          } else {
            next();
          }
          return;
        case "eth_sendRawTransaction":
          next(function(err, result, cb) {
            if (err)
              return cb();
            var rawTx = payload.params[0];
            var stripped = ethUtil.stripHexPrefix(rawTx);
            var rawData = Buffer2.from(ethUtil.stripHexPrefix(rawTx), "hex");
            var tx = new Transaction(Buffer2.from(ethUtil.stripHexPrefix(rawTx), "hex"));
            var address2 = "0x" + tx.getSenderAddress().toString("hex").toLowerCase();
            var nonce = ethUtil.bufferToInt(tx.nonce);
            nonce++;
            var hexNonce = nonce.toString(16);
            if (hexNonce.length % 2)
              hexNonce = "0" + hexNonce;
            hexNonce = "0x" + hexNonce;
            self2.nonceCache[address2] = hexNonce;
            cb();
          });
          return;
        case "evm_revert":
          self2.nonceCache = {};
          next();
          return;
        default:
          next();
          return;
      }
    };
  }
});

// node_modules/web3-provider-engine/subproviders/subscriptions.js
var require_subscriptions = __commonJS({
  "node_modules/web3-provider-engine/subproviders/subscriptions.js"(exports, module) {
    init_node_globals();
    init_virtual_process_polyfill();
    init_buffer();
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createSubscriptionManager = require_subscriptionManager();
    var SubscriptionsSubprovider2 = class extends ProviderSubprovider {
      constructor() {
        super(({ blockTracker, provider, engine }) => {
          const { events, middleware } = createSubscriptionManager({ blockTracker, provider });
          events.on("notification", (data) => engine.emit("data", null, data));
          return middleware;
        });
      }
    };
    module.exports = SubscriptionsSubprovider2;
  }
});

// build/web3-providers.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var import_wallet_sdk = __toESM(require_dist4());

// node_modules/@walletconnect/web3-provider/dist/esm/index.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/client/dist/esm/index.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/core/dist/esm/index.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/utils/dist/esm/index.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
init_esm2();

// node_modules/@walletconnect/utils/dist/esm/constants.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var reservedEvents = [
  "session_request",
  "session_update",
  "exchange_key",
  "connect",
  "disconnect",
  "display_uri",
  "modal_closed",
  "transport_open",
  "transport_close",
  "transport_error"
];
var signingMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];
var infuraNetworks = {
  1: "mainnet",
  3: "ropsten",
  4: "rinkeby",
  5: "goerli",
  42: "kovan"
};

// node_modules/@walletconnect/utils/dist/esm/encoding.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var import_bn = __toESM(require_bn8());

// node_modules/@walletconnect/encoding/dist/esm/index.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var import_is_typedarray = __toESM(require_is_typedarray());
var import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
var ENC_HEX = "hex";
var ENC_UTF8 = "utf8";
var STRING_ZERO = "0";
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
  const hex = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex) : hex;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function arrayToBuffer(arr) {
  return (0, import_typedarray_to_buffer.default)(arr);
}
function arrayToHex(arr, prefixed = false) {
  return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
  return bufferToUtf8(arrayToBuffer(arr));
}
function hexToBuffer(hex) {
  return Buffer2.from(removeHexPrefix(hex), ENC_HEX);
}
function hexToArray(hex) {
  return bufferToArray(hexToBuffer(hex));
}
function utf8ToBuffer(utf8) {
  return Buffer2.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function isHexString(str, length) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && str.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
function padLeft(str, length, padding = STRING_ZERO) {
  return padString(str, length, true, padding);
}
function removeHexPrefix(hex) {
  return hex.replace(/^0x/, "");
}
function addHexPrefix(hex) {
  return hex.startsWith("0x") ? hex : `0x${hex}`;
}
function sanitizeHex(hex) {
  hex = removeHexPrefix(hex);
  hex = sanitizeBytes(hex, 2);
  if (hex) {
    hex = addHexPrefix(hex);
  }
  return hex;
}
function removeHexLeadingZeros(hex) {
  const prefixed = hex.startsWith("0x");
  hex = removeHexPrefix(hex);
  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
  return prefixed ? addHexPrefix(hex) : hex;
}
function padString(str, length, left, padding = STRING_ZERO) {
  const diff = length - str.length;
  let result = str;
  if (diff > 0) {
    const pad2 = padding.repeat(diff);
    result = left ? pad2 + str : str + pad2;
  }
  return result;
}

// node_modules/@walletconnect/utils/dist/esm/encoding.js
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertHexToArrayBuffer(hex) {
  return hexToArray(hex).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex = removeHexPrefix(sanitizeHex(new import_bn.default(num).toString(16)));
  return noPrefix ? hex : addHexPrefix(hex);
}

// node_modules/@walletconnect/utils/dist/esm/ethereum.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var import_js_sha3 = __toESM(require_sha32());

// node_modules/@walletconnect/utils/dist/esm/misc.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
  IEvents: () => IEvents,
  IJsonRpcConnection: () => IJsonRpcConnection,
  IJsonRpcProvider: () => IJsonRpcProvider,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type2) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type2)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type2];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e5) => e5.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error2 = getErrorByCode(response.error.code);
    if (error2.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error2.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e5, url, type2) {
  return e5.message.includes("getaddrinfo ENOTFOUND") || e5.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type2} RPC url at ${url}`) : e5;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var import_environment = __toESM(require_cjs3());
__reExport(env_exports, __toESM(require_cjs3()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports4, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
function payloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error2, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error2, data)
  };
}
function formatErrorMessage(error2, data) {
  if (typeof error2 === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error2 === "string") {
    error2 = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error2 });
  }
  if (typeof data !== "undefined") {
    error2.data = data;
  }
  if (isReservedErrorCode(error2.code)) {
    error2 = getErrorByCode(error2.code);
  }
  return error2;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x5) => x5.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var IEvents = class {
};

// node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var IJsonRpcConnection = class extends IEvents {
  constructor(opts) {
    super();
  }
};
var IBaseJsonRpcProvider = class extends IEvents {
  constructor() {
    super();
  }
};
var IJsonRpcProvider = class extends IBaseJsonRpcProvider {
  constructor(connection) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex2) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex2).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/utils/dist/esm/misc.js
function sanitizeHex2(hex) {
  return sanitizeHex(hex);
}
function removeHexLeadingZeros2(hex) {
  return removeHexLeadingZeros(addHexPrefix(hex));
}
var payloadId2 = payloadId;
function uuid() {
  const result = ((a5, b4) => {
    for (b4 = a5 = ""; a5++ < 36; b4 += a5 * 51 & 52 ? (a5 ^ 15 ? 8 ^ Math.random() * (a5 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b4;
  })();
  return result;
}
function getInfuraRpcUrl(chainId, infuraId) {
  let rpcUrl;
  const network = infuraNetworks[chainId];
  if (network) {
    rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
  }
  return rpcUrl;
}
function getRpcUrl(chainId, rpc) {
  let rpcUrl;
  const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
  if (rpc.custom && rpc.custom[chainId]) {
    rpcUrl = rpc.custom[chainId];
  } else if (infuraUrl) {
    rpcUrl = infuraUrl;
  }
  return rpcUrl;
}

// node_modules/@walletconnect/utils/dist/esm/validators.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array) {
  return !(array && array.length);
}
function isHexString2(value, length) {
  return isHexString(value, length);
}
function isJsonRpcRequest2(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request3) {
  if (request3.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request3.method)) {
    return false;
  }
  return true;
}

// node_modules/@walletconnect/utils/dist/esm/ethereum.js
function toChecksumAddress(address) {
  address = removeHexPrefix(address.toLowerCase());
  const hash = removeHexPrefix((0, import_js_sha3.keccak_256)(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i5 = 0; i5 < address.length; i5++) {
    if (parseInt(hash[i5], 16) > 7) {
      checksum += address[i5].toUpperCase();
    } else {
      checksum += address[i5];
    }
  }
  return addHexPrefix(checksum);
}
var isValidAddress = (address) => {
  if (!address) {
    return false;
  } else if (address.toLowerCase().substring(0, 2) !== "0x") {
    return false;
  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return address === toChecksumAddress(address);
  }
};
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString2(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value) {
    let result = value;
    if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
      if (!isHexString2(value)) {
        result = convertNumberToHex(value);
      } else if (typeof value === "string") {
        result = sanitizeHex2(value);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros2(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex2(txData.from),
    to: typeof txData.to === "undefined" ? void 0 : sanitizeHex2(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex2(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key) => {
    if ((typeof txDataRPC[key] === "undefined" || typeof txDataRPC[key] === "string" && !txDataRPC[key].trim().length) && prunable.includes(key)) {
      delete txDataRPC[key];
    }
  });
  return txDataRPC;
}

// node_modules/@walletconnect/utils/dist/esm/payload.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
function formatRpcError(error2) {
  const message = error2.message || "Failed or Rejected Request";
  let code = -32e3;
  if (error2 && !error2.code) {
    switch (message) {
      case "Parse error":
        code = -32700;
        break;
      case "Invalid request":
        code = -32600;
        break;
      case "Method not found":
        code = -32601;
        break;
      case "Invalid params":
        code = -32602;
        break;
      case "Internal error":
        code = -32603;
        break;
      default:
        code = -32e3;
        break;
    }
  }
  const result = {
    code,
    message
  };
  if (error2.data) {
    result.data = error2.data;
  }
  return result;
}

// node_modules/@walletconnect/utils/dist/esm/session.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/utils/dist/esm/url.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var queryStringUtils = __toESM(require_query_string());
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString;
}
function appendToQueryString(queryString, newQueryParams) {
  let queryParams = parseQueryString(queryString);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString = formatQueryString(queryParams);
  return queryString;
}
function parseQueryString(queryString) {
  return queryStringUtils.parse(queryString);
}
function formatQueryString(queryParams) {
  return queryStringUtils.stringify(queryParams);
}

// node_modules/@walletconnect/utils/dist/esm/session.js
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString2) {
    const result2 = parseQueryString(queryString2);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/socket-transport/dist/esm/network.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var NetworkMonitor = class {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
};
var network_default = NetworkMonitor;

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
var WS = typeof globalThis.WebSocket !== "undefined" ? globalThis.WebSocket : require_browser13();
var SocketTransport = class {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new network_default();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({ event, callback });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS(url);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error2) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events = this._events.filter((event2) => event2.event === "message");
      if (events && events.length) {
        events.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e5) {
    const events = this._events.filter((event) => event.event === "error");
    if (events && events.length) {
      events.forEach((event) => event.callback(e5));
    }
  }
  _queueSubscriptions() {
    const subscriptions = this._subscriptions;
    subscriptions.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue4 = this._queue;
    queue4.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
};
function getWebSocketUrl(_url, protocol, version3) {
  var _a, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser() ? {
    protocol,
    version: version3,
    env: "browser",
    host: ((_a = getLocation2()) === null || _a === void 0 ? void 0 : _a.host) || ""
  } : {
    protocol,
    version: version3,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString;
}
var esm_default = SocketTransport;

// node_modules/@walletconnect/core/dist/esm/errors.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var ERROR_SESSION_CONNECTED = "Session currently connected";
var ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
var ERROR_SESSION_REJECTED = "Session Rejected";
var ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
var ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
var ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
var ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
var ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
var ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
var ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
var ERROR_INVALID_URI = "URI format is invalid";
var ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
var ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

// node_modules/@walletconnect/core/dist/esm/events.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var EventManager = class {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x5) => x5.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest2(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error2 = new Error(payload.error.message);
        eventEmitter.callback(error2, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
};
var events_default2 = EventManager;

// node_modules/@walletconnect/core/dist/esm/storage.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var SessionStorage = class {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json = getLocal(this.storageId);
    if (json && isWalletConnectSession(json)) {
      session = json;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
};
var storage_default = SessionStorage;

// node_modules/@walletconnect/core/dist/esm/url.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var domain2 = "walletconnect.org";
var alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
var bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url) {
  let hostname2 = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname2 = hostname2.split(":")[0];
  hostname2 = hostname2.split("?")[0];
  return hostname2;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain2;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}

// node_modules/@walletconnect/core/dist/esm/index.js
var Connector = class {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new events_default2();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new esm_default({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value) {
    if (!value) {
      return;
    }
    this._bridge = value;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value) {
    if (!value) {
      return;
    }
    const key = convertHexToArrayBuffer(value);
    this._key = key;
  }
  get key() {
    if (this._key) {
      const key = convertArrayBufferToHex(this._key, true);
      return key;
    }
    return "";
  }
  set clientId(value) {
    if (!value) {
      return;
    }
    this._clientId = value;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value) {
    if (!value) {
      return;
    }
    this._peerId = value;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value) {
    this._peerMeta = value;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value) {
    if (!value) {
      return;
    }
    this._handshakeTopic = value;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value) {
    if (!value) {
      return;
    }
    this._handshakeId = value;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value) {
    if (!value) {
      return;
    }
    const { handshakeTopic, bridge, key } = this._parseUri(value);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key;
  }
  set chainId(value) {
    this._chainId = value;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value) {
    this._networkId = value;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value) {
    this._accounts = value;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value) {
    this._rpcUrl = value;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value) {
    if (!value) {
      return;
    }
    this._connected = value.connected;
    this.accounts = value.accounts;
    this.chainId = value.chainId;
    this.bridge = value.bridge;
    this.key = value.key;
    this.clientId = value.clientId;
    this.clientMeta = value.clientMeta;
    this.peerId = value.peerId;
    this.peerMeta = value.peerMeta;
    this.handshakeId = value.handshakeId;
    this.handshakeTopic = value.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request3 = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(instantRequest)
        }
      ]
    });
    this.handshakeId = request3.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request3);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error2) {
      endInstantRequest();
      throw error2;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error2, payload) => {
        if (error2) {
          return reject(error2);
        }
        resolve(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request3 = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: opts && opts.chainId ? opts.chainId : null
        }
      ]
    });
    this.handshakeId = request3.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request3, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [
        {
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: { message }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request3 = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request3, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [
        {
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request3 = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request3);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request3 = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request3 = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request3 = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    params = parsePersonalSign(params);
    const request3 = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request3 = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request3 = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  unsafeSend(request3, options) {
    this._sendRequest(request3, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request: request3, options }]
    });
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(request3.id, (error2, payload) => {
        if (error2) {
          reject(error2);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve(payload);
      });
    });
  }
  async sendCustomRequest(request3, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request3.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request3.params) {
          request3.params[0] = parseTransactionData(request3.params[0]);
        }
        break;
      case "personal_sign":
        if (request3.params) {
          request3.params = parsePersonalSign(request3.params);
        }
        break;
      default:
        break;
    }
    const formattedRequest = this._formatRequest(request3);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request3, options) {
    const callRequest = this._formatRequest(request3);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request3, errorMsg, options) {
    this._sendRequest(request3, options);
    this._subscribeToSessionResponse(request3.id, errorMsg);
  }
  _sendCallRequest(request3, options) {
    this._sendRequest(request3, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request: request3, options }]
    });
    return this._subscribeToCallResponse(request3.id);
  }
  _formatRequest(request3) {
    if (typeof request3.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request3.id === "undefined" ? payloadId2() : request3.id,
      jsonrpc: "2.0",
      method: request3.method,
      params: typeof request3.params === "undefined" ? [] : request3.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = { id: response.id, jsonrpc: "2.0" };
    if (isJsonRpcResponseError(response)) {
      const error2 = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error: error2 });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(mobileLinkChoiceKey);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    if (this._peerId) {
      this._peerId = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error2) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id, callback) {
    this.on(`response:${id}`, callback);
  }
  _subscribeToSessionResponse(id, errorMsg) {
    this._subscribeToResponse(id, (error2, payload) => {
      if (error2) {
        this._handleSessionResponse(error2.message);
        return;
      }
      if (isJsonRpcResponseSuccess(payload)) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id) {
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(id, (error2, payload) => {
        if (error2) {
          reject(error2);
          return;
        }
        if (isJsonRpcResponseSuccess(payload)) {
          resolve(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(payload.error);
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error2, payload) => {
      const { request: request3 } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request3.method)) {
        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error2, payload) => {
      if (error2) {
        this._eventManager.trigger({
          event: "error",
          params: [
            {
              code: "SESSION_REQUEST_ERROR",
              message: error2.toString()
            }
          ]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error2, payload) => {
      if (error2) {
        this._handleSessionResponse(error2.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
    this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version3 = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version3}?bridge=${bridge}&key=${key}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key = result.key;
      return { handshakeTopic, bridge, key };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.encrypt(data, key);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.decrypt(payload, key);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error2, payload) => {
      if (error2) {
        throw error2;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json = await response.json();
        if (!json.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error3) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
};
var esm_default2 = Connector;

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  decrypt: () => decrypt,
  encrypt: () => encrypt,
  generateKey: () => generateKey,
  verifyHmac: () => verifyHmac
});
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
  AES_LENGTH: () => AES_LENGTH,
  AES_NODE_ALGO: () => AES_NODE_ALGO,
  DECRYPT_OP: () => DECRYPT_OP,
  ENCRYPT_OP: () => ENCRYPT_OP,
  ERROR_BAD_MAC: () => ERROR_BAD_MAC,
  HEX_ENC: () => HEX_ENC,
  HMAC_BROWSER: () => HMAC_BROWSER,
  HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
  HMAC_LENGTH: () => HMAC_LENGTH,
  HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
  IV_LENGTH: () => IV_LENGTH,
  KEY_LENGTH: () => KEY_LENGTH,
  LENGTH_0: () => LENGTH_0,
  LENGTH_1: () => LENGTH_1,
  LENGTH_1024: () => LENGTH_1024,
  LENGTH_128: () => LENGTH_128,
  LENGTH_16: () => LENGTH_16,
  LENGTH_256: () => LENGTH_256,
  LENGTH_32: () => LENGTH_32,
  LENGTH_512: () => LENGTH_512,
  LENGTH_64: () => LENGTH_64,
  MAC_LENGTH: () => MAC_LENGTH,
  PREFIX_LENGTH: () => PREFIX_LENGTH,
  RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
  SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
  SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
  SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
  SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
  SIGN_OP: () => SIGN_OP,
  UTF8_ENC: () => UTF8_ENC,
  VERIFY_OP: () => VERIFY_OP,
  aesCbcDecrypt: () => aesCbcDecrypt,
  aesCbcEncrypt: () => aesCbcEncrypt,
  assert: () => assert,
  hmacSha256Sign: () => hmacSha256Sign,
  hmacSha256Verify: () => hmacSha256Verify,
  hmacSha512Sign: () => hmacSha512Sign,
  hmacSha512Verify: () => hmacSha512Verify,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7,
  randomBytes: () => randomBytes,
  ripemd160: () => ripemd160,
  sha256: () => sha256,
  sha512: () => sha512
});
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var env3 = __toESM(require_cjs3());
function randomBytes(length) {
  const browserCrypto = env3.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var env4 = __toESM(require_cjs3());

// node_modules/@walletconnect/crypto/dist/esm/constants/index.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/constants/length.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var LENGTH_0 = 0;
var LENGTH_1 = 1;
var LENGTH_16 = 16;
var LENGTH_32 = 32;
var LENGTH_64 = 64;
var LENGTH_128 = 128;
var LENGTH_256 = 256;
var LENGTH_512 = 512;
var LENGTH_1024 = 1024;

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
var AES_LENGTH = LENGTH_256;
var HMAC_LENGTH = LENGTH_256;
var AES_BROWSER_ALGO = "AES-CBC";
var HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
var HMAC_BROWSER = "HMAC";
var SHA256_BROWSER_ALGO = "SHA-256";
var SHA512_BROWSER_ALGO = "SHA-512";
var AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
var HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
var SHA256_NODE_ALGO = "sha256";
var SHA512_NODE_ALGO = "sha512";
var RIPEMD160_NODE_ALGO = "ripemd160";
var PREFIX_LENGTH = LENGTH_1;
var KEY_LENGTH = LENGTH_32;
var IV_LENGTH = LENGTH_16;
var MAC_LENGTH = LENGTH_32;

// node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var HEX_ENC = "hex";
var UTF8_ENC = "utf8";

// node_modules/@walletconnect/crypto/dist/esm/constants/error.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var ERROR_BAD_MAC = "Bad MAC";

// node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var ENCRYPT_OP = "encrypt";
var DECRYPT_OP = "decrypt";
var SIGN_OP = "sign";
var VERIFY_OP = "verify";

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
function getAlgo(type2) {
  return type2 === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type2) {
  return type2 === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer2, type2 = AES_BROWSER_ALGO) {
  return env4.getSubtleCrypto().importKey("raw", buffer2, getAlgo(type2), true, getOps(type2));
}
async function browserAesEncrypt(iv, key, data) {
  const subtle = env4.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key, data) {
  const subtle = env4.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key, data) {
  const subtle = env4.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserHmacSha512Sign(key, data) {
  const subtle = env4.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: LENGTH_512,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserSha256(data) {
  const subtle = env4.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA256_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}
async function browserSha512(data) {
  const subtle = env4.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA512_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
function aesCbcEncrypt(iv, key, data) {
  return browserAesEncrypt(iv, key, data);
}
function aesCbcDecrypt(iv, key, data) {
  return browserAesDecrypt(iv, key, data);
}

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
var helpers_exports = {};
__export(helpers_exports, {
  assert: () => assert,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7
});
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
var env_exports2 = {};
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
__reExport(env_exports2, __toESM(require_cjs3()));

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
__reExport(helpers_exports, env_exports2);

// node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var PADDING = [
  [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
  [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
  [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
  [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
  [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
  [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
  [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
  [9, 9, 9, 9, 9, 9, 9, 9, 9],
  [8, 8, 8, 8, 8, 8, 8, 8],
  [7, 7, 7, 7, 7, 7, 7],
  [6, 6, 6, 6, 6, 6],
  [5, 5, 5, 5, 5],
  [4, 4, 4, 4],
  [3, 3, 3],
  [2, 2],
  [1]
];
var pkcs7 = {
  pad(plaintext) {
    const padding = PADDING[plaintext.byteLength % 16 || 0];
    const result = new Uint8Array(plaintext.byteLength + padding.length);
    result.set(plaintext);
    result.set(padding, plaintext.byteLength);
    return result;
  },
  unpad(padded) {
    return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
  }
};

// node_modules/@walletconnect/crypto/dist/esm/helpers/types.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isConstantTime(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let res = 0;
  for (let i5 = 0; i5 < arr1.length; i5++) {
    res |= arr1[i5] ^ arr2[i5];
  }
  return res === 0;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
async function hmacSha256Sign(key, msg) {
  const result = await browserHmacSha256Sign(key, msg);
  return result;
}
async function hmacSha256Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha256Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
async function hmacSha512Sign(key, msg) {
  const result = await browserHmacSha512Sign(key, msg);
  return result;
}
async function hmacSha512Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha512Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
async function sha256(msg) {
  const result = await browserSha256(msg);
  return result;
}
async function sha512(msg) {
  const result = await browserSha512(msg);
  return result;
}
async function ripemd160(msg) {
  throw new Error("Not supported for Browser async methods, use sync instead!");
}

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
__reExport(browser_exports, helpers_exports);

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt(data, key, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data);
  const content = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt(payload, key) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer2 = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer2);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error2) {
    return null;
  }
  return data;
}

// node_modules/@walletconnect/client/dist/esm/index.js
var WalletConnect = class extends esm_default2 {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib: esm_exports5,
      connectorOpts,
      pushServerOpts
    });
  }
};
var esm_default3 = WalletConnect;

// node_modules/@walletconnect/web3-provider/dist/esm/index.js
var import_qrcode_modal = __toESM(require_cjs4());

// node_modules/@walletconnect/http-connection/dist/esm/index.js
init_node_globals();
init_virtual_process_polyfill();
init_buffer();
var import_eventemitter3 = __toESM(require_eventemitter3());
var import_xhr2_cookies = __toESM(require_dist5());
var XHR = getFromWindow2("XMLHttpRequest") || import_xhr2_cookies.XMLHttpRequest;
var HTTPConnection = class extends import_eventemitter3.default {
  constructor(url) {
    super();
    this.url = url;
  }
  formatError(payload, message, code = -1) {
    return {
      error: { message, code },
      id: payload.id,
      jsonrpc: payload.jsonrpc
    };
  }
  send(payload, internal) {
    return new Promise((resolve) => {
      if (payload.method === "eth_subscribe") {
        const error2 = this.formatError(payload, "Subscriptions are not supported by this HTTP endpoint");
        this.emit("error", error2);
        return resolve(error2);
      }
      const xhr2 = new XHR();
      let responded = false;
      const res = (err, result) => {
        if (!responded) {
          xhr2.abort();
          responded = true;
          if (internal) {
            internal(err, result);
          } else {
            const { id, jsonrpc } = payload;
            const response = err ? { id, jsonrpc, error: { message: err.message, code: err.code } } : { id, jsonrpc, result };
            this.emit("payload", response);
            resolve(response);
          }
        }
      };
      xhr2.open("POST", this.url, true);
      xhr2.setRequestHeader("Content-Type", "application/json");
      xhr2.timeout = 60 * 1e3;
      xhr2.onerror = res;
      xhr2.ontimeout = res;
      xhr2.onreadystatechange = () => {
        if (xhr2.readyState === 4) {
          try {
            const response = JSON.parse(xhr2.responseText);
            res(response.error, response.result);
          } catch (e5) {
            res(e5);
          }
        }
      };
      xhr2.send(JSON.stringify(payload));
    });
  }
};
var esm_default4 = HTTPConnection;

// node_modules/@walletconnect/web3-provider/dist/esm/index.js
var ProviderEngine = require_web3_provider_engine();
var CacheSubprovider = require_cache();
var FixtureSubprovider = require_fixture();
var FilterSubprovider = require_filters();
var HookedWalletSubprovider = require_hooked_wallet();
var NonceSubprovider = require_nonce_tracker();
var SubscriptionsSubprovider = require_subscriptions();
var WalletConnectProvider = class extends ProviderEngine {
  constructor(opts) {
    super({ pollingInterval: opts.pollingInterval || 8e3 });
    this.bridge = "https://bridge.walletconnect.org";
    this.qrcode = true;
    this.qrcodeModal = import_qrcode_modal.default;
    this.qrcodeModalOptions = void 0;
    this.rpc = null;
    this.infuraId = "";
    this.http = null;
    this.isConnecting = false;
    this.connected = false;
    this.connectCallbacks = [];
    this.accounts = [];
    this.chainId = 1;
    this.rpcUrl = "";
    this.enable = async () => {
      const wc = await this.getWalletConnector();
      if (wc) {
        this.start();
        this.subscribeWalletConnector();
        return wc.accounts;
      } else {
        throw new Error("Failed to connect to WalleConnect");
      }
    };
    this.request = async (payload) => {
      return this.send(payload);
    };
    this.send = async (payload, callback) => {
      var _a;
      if (typeof payload === "string") {
        const method = payload;
        let params = callback;
        if (method === "personal_sign") {
          params = parsePersonalSign(params);
        }
        return this.sendAsyncPromise(method, params);
      }
      payload = Object.assign({ id: payloadId2(), jsonrpc: "2.0" }, payload);
      if (payload.method === "personal_sign") {
        payload.params = parsePersonalSign(payload.params);
      }
      if (callback) {
        this.sendAsync(payload, callback);
        return;
      }
      if (payload.method === "eth_signTypedData_v4" && ((_a = this.walletMeta) === null || _a === void 0 ? void 0 : _a.name) === "MetaMask") {
        const { result } = await this.handleOtherRequests(payload);
        return result;
      } else {
        return this.sendAsyncPromise(payload.method, payload.params);
      }
    };
    this.onConnect = (callback) => {
      this.connectCallbacks.push(callback);
    };
    this.triggerConnect = (result) => {
      if (this.connectCallbacks && this.connectCallbacks.length) {
        this.connectCallbacks.forEach((callback) => callback(result));
      }
    };
    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || "https://bridge.walletconnect.org";
    this.qrcode = typeof opts.qrcode === "undefined" || opts.qrcode !== false;
    this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;
    this.qrcodeModalOptions = opts.qrcodeModalOptions;
    this.wc = opts.connector || new esm_default3({
      bridge: this.bridge,
      qrcodeModal: this.qrcode ? this.qrcodeModal : void 0,
      qrcodeModalOptions: this.qrcodeModalOptions,
      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,
      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,
      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta
    });
    this.rpc = opts.rpc || null;
    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== "string" || !opts.infuraId.trim())) {
      throw new Error("Missing one of the required parameters: rpc or infuraId");
    }
    this.infuraId = opts.infuraId || "";
    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;
    this.initialize();
  }
  get isWalletConnect() {
    return true;
  }
  get connector() {
    return this.wc;
  }
  get walletMeta() {
    return this.wc.peerMeta;
  }
  async disconnect() {
    this.close();
  }
  async close() {
    const wc = await this.getWalletConnector({ disableSessionCreation: true });
    await wc.killSession();
    await this.onDisconnect();
  }
  async handleRequest(payload) {
    try {
      let response;
      let result = null;
      const wc = await this.getWalletConnector();
      switch (payload.method) {
        case "wc_killSession":
          await this.close();
          result = null;
          break;
        case "eth_accounts":
          result = wc.accounts;
          break;
        case "eth_coinbase":
          result = wc.accounts[0];
          break;
        case "eth_chainId":
          result = wc.chainId;
          break;
        case "net_version":
          result = wc.chainId;
          break;
        case "eth_uninstallFilter":
          this.sendAsync(payload, (_6) => _6);
          result = true;
          break;
        default:
          response = await this.handleOtherRequests(payload);
      }
      if (response) {
        return response;
      }
      return this.formatResponse(payload, result);
    } catch (error2) {
      this.emit("error", error2);
      throw error2;
    }
  }
  async handleOtherRequests(payload) {
    if (!signingMethods.includes(payload.method) && payload.method.startsWith("eth_")) {
      return this.handleReadRequests(payload);
    }
    const wc = await this.getWalletConnector();
    const result = await wc.sendCustomRequest(payload);
    return this.formatResponse(payload, result);
  }
  async handleReadRequests(payload) {
    if (!this.http) {
      const error2 = new Error("HTTP Connection not available");
      this.emit("error", error2);
      throw error2;
    }
    return this.http.send(payload);
  }
  formatResponse(payload, result) {
    return {
      id: payload.id,
      jsonrpc: payload.jsonrpc,
      result
    };
  }
  getWalletConnector(opts = {}) {
    const { disableSessionCreation = false } = opts;
    return new Promise((resolve, reject) => {
      const wc = this.wc;
      if (this.isConnecting) {
        this.onConnect((x5) => resolve(x5));
      } else if (!wc.connected && !disableSessionCreation) {
        this.isConnecting = true;
        wc.on("modal_closed", () => {
          reject(new Error("User closed modal"));
        });
        wc.createSession({ chainId: this.chainId }).then(() => {
          wc.on("connect", (error2, payload) => {
            if (error2) {
              this.isConnecting = false;
              return reject(error2);
            }
            this.isConnecting = false;
            this.connected = true;
            if (payload) {
              this.updateState(payload.params[0]);
            }
            this.emit("connect");
            this.triggerConnect(wc);
            resolve(wc);
          });
        }).catch((error2) => {
          this.isConnecting = false;
          reject(error2);
        });
      } else {
        if (!this.connected) {
          this.connected = true;
          this.updateState(wc.session);
        }
        resolve(wc);
      }
    });
  }
  async subscribeWalletConnector() {
    const wc = await this.getWalletConnector();
    wc.on("disconnect", (error2) => {
      if (error2) {
        this.emit("error", error2);
        return;
      }
      this.onDisconnect();
    });
    wc.on("session_update", (error2, payload) => {
      if (error2) {
        this.emit("error", error2);
        return;
      }
      this.updateState(payload.params[0]);
    });
  }
  async onDisconnect() {
    await this.stop();
    this.emit("close", 1e3, "Connection closed");
    this.emit("disconnect", 1e3, "Connection disconnected");
    this.connected = false;
  }
  async updateState(sessionParams) {
    const { accounts, chainId, networkId, rpcUrl } = sessionParams;
    if (!this.accounts || accounts && this.accounts !== accounts) {
      this.accounts = accounts;
      this.emit("accountsChanged", accounts);
    }
    if (!this.chainId || chainId && this.chainId !== chainId) {
      this.chainId = chainId;
      this.emit("chainChanged", chainId);
    }
    if (!this.networkId || networkId && this.networkId !== networkId) {
      this.networkId = networkId;
      this.emit("networkChanged", networkId);
    }
    this.updateRpcUrl(this.chainId, rpcUrl || "");
  }
  updateRpcUrl(chainId, rpcUrl = "") {
    const rpc = { infuraId: this.infuraId, custom: this.rpc || void 0 };
    rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);
    if (rpcUrl) {
      this.rpcUrl = rpcUrl;
      this.updateHttpConnection();
    } else {
      this.emit("error", new Error(`No RPC Url available for chainId: ${chainId}`));
    }
  }
  updateHttpConnection() {
    if (this.rpcUrl) {
      this.http = new esm_default4(this.rpcUrl);
      this.http.on("payload", (payload) => this.emit("payload", payload));
      this.http.on("error", (error2) => this.emit("error", error2));
    }
  }
  sendAsyncPromise(method, params) {
    return new Promise((resolve, reject) => {
      this.sendAsync({
        id: payloadId2(),
        jsonrpc: "2.0",
        method,
        params: params || []
      }, (error2, response) => {
        if (error2) {
          reject(error2);
          return;
        }
        resolve(response.result);
      });
    });
  }
  initialize() {
    this.updateRpcUrl(this.chainId);
    this.addProvider(new FixtureSubprovider({
      eth_hashrate: "0x00",
      eth_mining: false,
      eth_syncing: true,
      net_listening: true,
      web3_clientVersion: `WalletConnect/v1.x.x/javascript`
    }));
    this.addProvider(new CacheSubprovider());
    this.addProvider(new SubscriptionsSubprovider());
    this.addProvider(new FilterSubprovider());
    this.addProvider(new NonceSubprovider());
    this.addProvider(new HookedWalletSubprovider(this.configWallet()));
    this.addProvider({
      handleRequest: async (payload, next, end) => {
        try {
          const { error: error2, result } = await this.handleRequest(payload);
          end(error2, result);
        } catch (error2) {
          end(error2);
        }
      },
      setEngine: (_6) => _6
    });
  }
  configWallet() {
    return {
      getAccounts: async (cb) => {
        try {
          const wc = await this.getWalletConnector();
          const accounts = wc.accounts;
          if (accounts && accounts.length) {
            cb(null, accounts);
          } else {
            cb(new Error("Failed to get accounts"));
          }
        } catch (error2) {
          cb(error2);
        }
      },
      processMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signMessage([msgParams.from, msgParams.data]);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processPersonalMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processSignTransaction: async (txParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signTransaction(txParams);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processTransaction: async (txParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.sendTransaction(txParams);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processTypedMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signTypedData([msgParams.from, msgParams.data]);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      }
    };
  }
};
var esm_default5 = WalletConnectProvider;
var export_CoinbaseWalletProvider = import_wallet_sdk.CoinbaseWalletProvider;
var export_CoinbaseWalletSDK = import_wallet_sdk.CoinbaseWalletSDK;
export {
  export_CoinbaseWalletProvider as CoinbaseWalletProvider,
  export_CoinbaseWalletSDK as CoinbaseWalletSDK,
  esm_default5 as WalletConnectProvider
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! https://mths.be/punycode v1.4.1 by @mathias */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
//# sourceMappingURL=web3-providers.js.map
